import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Diagnostic provider that monitors coverage data and reports under-coverage files
 * to the VS Code Problems panel in real-time.
 */
export class CoverageDiagnosticProvider {
    private diagnosticCollection: vscode.DiagnosticCollection;
    private fileWatcher: vscode.FileSystemWatcher | undefined;
    private readonly coverageThreshold = 75; // 75% coverage target

    constructor() {
        this.diagnosticCollection = vscode.languages.createDiagnosticCollection('coverage');
    }

    /**
     * Activate the coverage provider
     */
    public activate(context: vscode.ExtensionContext): void {
        // Watch for coverage file changes
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) {
            return;
        }

        const coveragePattern = new vscode.RelativePattern(
            workspaceRoot,
            'coverage/coverage-final.json'
        );

        this.fileWatcher = vscode.workspace.createFileSystemWatcher(coveragePattern);

        // Update diagnostics when coverage file changes
        this.fileWatcher.onDidChange(() => this.updateDiagnostics(workspaceRoot));
        this.fileWatcher.onDidCreate(() => this.updateDiagnostics(workspaceRoot));

        context.subscriptions.push(
            this.fileWatcher,
            this.diagnosticCollection
        );

        // Initial update
        this.updateDiagnostics(workspaceRoot);

        // Also watch the quality-diagnostics.json file
        const qualityDiagnosticsPattern = new vscode.RelativePattern(
            workspaceRoot,
            '.vscode/quality-diagnostics.json'
        );

        const qualityWatcher = vscode.workspace.createFileSystemWatcher(qualityDiagnosticsPattern);
        qualityWatcher.onDidChange(() => this.updateFromQualityDiagnostics(workspaceRoot));
        qualityWatcher.onDidCreate(() => this.updateFromQualityDiagnostics(workspaceRoot));

        context.subscriptions.push(qualityWatcher);

        // Initial update from quality diagnostics
        this.updateFromQualityDiagnostics(workspaceRoot);
    }

    /**
     * Update diagnostics from coverage-final.json
     */
    private updateDiagnostics(workspaceRoot: string): void {
        const coveragePath = path.join(workspaceRoot, 'coverage', 'coverage-final.json');

        if (!fs.existsSync(coveragePath)) {
            // Clear diagnostics if coverage file doesn't exist
            this.diagnosticCollection.clear();
            return;
        }

        try {
            const coverageData = JSON.parse(fs.readFileSync(coveragePath, 'utf-8'));
            const diagnostics = new Map<string, vscode.Diagnostic[]>();

            for (const [filePath, fileData] of Object.entries<any>(coverageData)) {
                const { l } = fileData;

                // Calculate line coverage percentage
                const totalLines = Object.keys(l).length;
                const coveredLines = Object.values(l).filter((hits: any) => hits > 0).length;
                const lineCoverage = totalLines > 0 ? (coveredLines / totalLines) * 100 : 100;

                if (lineCoverage < this.coverageThreshold) {
                    const _fileUri = vscode.Uri.file(filePath);
                    const gap = this.coverageThreshold - lineCoverage;

                    const diagnostic = new vscode.Diagnostic(
                        new vscode.Range(0, 0, 0, 0), // First line of file
                        `Test coverage (${lineCoverage.toFixed(1)}%) is below threshold (${this.coverageThreshold}%). Add ${gap.toFixed(1)}% more coverage.`,
                        vscode.DiagnosticSeverity.Warning
                    );

                    diagnostic.source = 'Quality Gate: Coverage';
                    diagnostic.code = 'coverage-threshold';

                    if (!diagnostics.has(filePath)) {
                        diagnostics.set(filePath, []);
                    }
                    diagnostics.get(filePath)!.push(diagnostic);
                }
            }

            // Clear old diagnostics
            this.diagnosticCollection.clear();

            // Set new diagnostics
            for (const [filePath, fileDiagnostics] of diagnostics.entries()) {
                this.diagnosticCollection.set(vscode.Uri.file(filePath), fileDiagnostics);
            }

        } catch (error) {
            // eslint-disable-next-line no-empty
        }
    }

    /**
     * Update diagnostics from quality-diagnostics.json (generated by quality-gates.test.ts)
     */
    private updateFromQualityDiagnostics(workspaceRoot: string): void {
        const diagnosticsPath = path.join(workspaceRoot, '.vscode', 'quality-diagnostics.json');

        if (!fs.existsSync(diagnosticsPath)) {
            return;
        }

        try {
            const qualityData = JSON.parse(fs.readFileSync(diagnosticsPath, 'utf-8'));
            const underCoverageFiles = qualityData.underCoverageFiles || [];

            const diagnostics = new Map<string, vscode.Diagnostic[]>();

            for (const { file, coverage } of underCoverageFiles) {
                const fullPath = path.join(workspaceRoot, file);
                const fileUri = vscode.Uri.file(fullPath);
                const gap = this.coverageThreshold - coverage;

                const diagnostic = new vscode.Diagnostic(
                    new vscode.Range(0, 0, 0, 0),
                    `Test coverage (${coverage}%) is below threshold (${this.coverageThreshold}%). Add ${gap.toFixed(1)}% more coverage.`,
                    vscode.DiagnosticSeverity.Warning
                );

                diagnostic.source = 'Quality Gate: Coverage';
                diagnostic.code = 'coverage-threshold';

                if (!diagnostics.has(fullPath)) {
                    diagnostics.set(fullPath, []);
                }
                diagnostics.get(fullPath)!.push(diagnostic);
            }

            // Clear and set diagnostics
            this.diagnosticCollection.clear();
            for (const [filePath, fileDiagnostics] of diagnostics.entries()) {
                this.diagnosticCollection.set(vscode.Uri.file(filePath), fileDiagnostics);
            }

        } catch (error) {
            // eslint-disable-next-line no-empty
        }
    }

    /**
     * Dispose of resources
     */
    public dispose(): void {
        this.diagnosticCollection.dispose();
        this.fileWatcher?.dispose();
    }
}


