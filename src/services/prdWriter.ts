/**
 * PRD Writer Service
 * 
 * Writes generated PRD content to PRD.md and PRD.json files.
 * Creates backups and handles formatting.
 * 
 * @module prdWriter
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import * as vscode from 'vscode';

/**
 * üìù PRD Metadata
 */
export interface PRDMetadata {
    generatedAt: string;         // ISO 8601 timestamp
    version: string;             // Version number
    generatedFrom: string[];     // Source files
    tokenCount: number;          // Total tokens used
}

/**
 * üìã PRD JSON Structure (machine-readable)
 */
export interface PRDJSON {
    metadata: PRDMetadata;
    content: string;             // Full PRD markdown content
    sections: {
        [key: string]: string;   // Section name -> content
    };
}

/**
 * ‚úçÔ∏è  PRD Writer Service
 * Writes PRD files with backup and validation
 */
export class PRDWriter {
    /**
     * üíæ Write PRD to workspace
     * 
     * Creates:
     * - PRD.md (markdown for humans)
     * - PRD.json (JSON for machines/agents)
     * - PRD.backup-[timestamp].md (backup of previous)
     * 
     * @param prdContent - Generated PRD markdown content
     * @param metadata - PRD metadata
     * @returns Object with paths, URIs, and success status
     * @throws Error if write fails
     */
    static async writePRD(prdContent: string, metadata: PRDMetadata): Promise<{
        mdPath: string;
        jsonPath: string;
        mdUri: vscode.Uri;
        jsonUri: vscode.Uri;
        backupPath?: string;
        success: boolean;
        message: string;
    }> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            throw new Error('No workspace folder found');
        }

        // Use workspace root URI for proper path construction
        const workspaceRootUri = workspaceFolders[0].uri;
        const mdUri = vscode.Uri.joinPath(workspaceRootUri, 'PRD.md');
        const jsonUri = vscode.Uri.joinPath(workspaceRootUri, 'PRD.json');
        const mdPath = mdUri.fsPath;
        const jsonPath = jsonUri.fsPath;


        try {
            // Create backup of existing PRD.md
            let backupPath: string | undefined;
            try {
                await fs.access(mdPath);
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                backupPath = path.join(workspaceRootUri.fsPath, `PRD.backup-${timestamp}.md`);
                const existingContent = await fs.readFile(mdPath, 'utf-8');
                await fs.writeFile(backupPath, existingContent, 'utf-8');
            } catch {
                // No existing PRD or backup failed - that's OK
            }

            // Write markdown file with frontmatter
            const frontmatter = `<!-- Generated from Plans/ on ${metadata.generatedAt} -->
<!-- Generated by COE PRD Generator -->
<!-- Version: ${metadata.version} -->
<!-- Tokens used: ${metadata.tokenCount} -->

`;
            const mdContent = frontmatter + prdContent;
            await fs.writeFile(mdPath, mdContent, 'utf-8');

            // Write JSON file (machine-readable, can be parsed by agents)
            const prdjson: PRDJSON = {
                metadata,
                content: prdContent,
                sections: this.extractSections(prdContent),
            };
            await fs.writeFile(jsonPath, JSON.stringify(prdjson, null, 2), 'utf-8');

            // Refresh VS Code explorer so files appear immediately
            try {
                await vscode.commands.executeCommand('workbench.files.action.refreshFilesExplorer');
            } catch (error) {
                // Non-critical, continue
            }

            return {
                mdPath,
                jsonPath,
                mdUri,
                jsonUri,
                backupPath,
                success: true,
                message: `‚úÖ PRD regenerated successfully (${metadata.tokenCount} tokens)`,
            };
        } catch (error) {
            const errMsg = error instanceof Error ? error.message : String(error);
            throw new Error(`Failed to write PRD: ${errMsg}`);
        }
    }

    /**
     * üìÇ Extract sections from PRD markdown
     * Splits PRD by top-level headers (##)
     * 
     * @param prdContent - PR markdown content
     * @returns Object with sections
     */
    private static extractSections(prdContent: string): Record<string, string> {
        const sections: Record<string, string> = {};
        const lines = prdContent.split('\n');
        let currentSection = 'Overview';
        let currentContent: string[] = [];

        for (const line of lines) {
            if (line.startsWith('## ')) {
                // Save previous section
                if (currentContent.length > 0) {
                    sections[currentSection] = currentContent.join('\n').trim();
                }
                // Start new section
                currentSection = line.substring(3).trim();
                currentContent = [];
            } else {
                currentContent.push(line);
            }
        }

        // Save last section
        if (currentContent.length > 0) {
            sections[currentSection] = currentContent.join('\n').trim();
        }

        return sections;
    }

    /**
     * üîç Show diff preview before overwriting
     * 
     * Opens a diff view comparing old and new PRD
     * 
     * @param oldPath - Path to existing PRD
     * @param newPath - Path to temp new PRD
     */
    static async showDiffPreview(oldPath: string, newPath: string): Promise<void> {
        try {
            const oldUri = vscode.Uri.file(oldPath);
            const newUri = vscode.Uri.file(newPath);
            await vscode.commands.executeCommand('vscode.diff', oldUri, newUri, 'PRD Changes Preview');
        } catch (error) {
            const errMsg = error instanceof Error ? error.message : String(error);
        }
    }

    /**
     * üìä Create metadata for PRD
     * 
     * @param files - Source files that were included
     * @param tokens - Total tokens used
     * @returns Metadata object
     */
    static createMetadata(files: string[], tokens: number): PRDMetadata {
        return {
            generatedAt: new Date().toISOString(),
            version: '1.0.0',
            generatedFrom: files,
            tokenCount: tokens,
        };
    }

    /**
     * üìã Format PRD for preview in notification
     * 
     * @param prdContent - Full PRD content
     * @returns Shortened preview (first 500 chars)
     */
    static getContentPreview(prdContent: string, maxChars: number = 300): string {
        if (prdContent.length <= maxChars) {
            return prdContent;
        }
        return prdContent.substring(0, maxChars) + '\n... [truncated for display]';
    }
}


