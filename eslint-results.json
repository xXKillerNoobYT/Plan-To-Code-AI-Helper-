[{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\agents\\answerTeam.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'question' is defined but never used.","line":10,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'taskId' is defined but never used.","line":23,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[617,620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[617,620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'query' is defined but never used.","line":35,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[896,899],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[896,899],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Answer Team Agent\r\n * Provides context and answers questions about plans and codebase\r\n */\r\n\r\nexport class AnswerTeam {\r\n    /**\r\n     * Answer a question about the plan or codebase\r\n     */\r\n    async answerQuestion(question: string): Promise<string> {\r\n\r\n        // TODO: Search plan.json for relevant context\r\n        // TODO: Search codebase for related code\r\n        // TODO: Search documentation\r\n        // TODO: Generate answer with references\r\n\r\n        return 'Not implemented yet';\r\n    }\r\n\r\n    /**\r\n     * Find relevant context for a task\r\n     */\r\n    async findContext(taskId: string): Promise<any> {\r\n\r\n        // TODO: Locate related plan sections\r\n        // TODO: Find related files\r\n        // TODO: Identify dependencies\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Search the plan for specific information\r\n     */\r\n    async searchPlan(query: string): Promise<any[]> {\r\n        // TODO: Full-text search in plan.json\r\n        // TODO: Semantic search\r\n        // TODO: Return ranked results\r\n\r\n        return [];\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\agents\\orchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'taskId' is defined but never used.","line":19,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Programming Orchestrator\r\n * Master coordinator for all agent teams\r\n */\r\n\r\nexport class ProgrammingOrchestrator {\r\n    /**\r\n     * Initialize the orchestrator\r\n     */\r\n    async initialize(): Promise<void> {\r\n        // TODO: Initialize all agent teams\r\n        // TODO: Load configuration\r\n        // TODO: Set up communication channels\r\n    }\r\n\r\n    /**\r\n     * Coordinate task execution across teams\r\n     */\r\n    async executeTask(taskId: string): Promise<void> {\r\n\r\n        // TODO: Route to appropriate team\r\n        // TODO: Monitor progress\r\n        // TODO: Handle failures and retries\r\n\r\n    }\r\n\r\n    /**\r\n     * Shutdown the orchestrator\r\n     */\r\n    async shutdown(): Promise<void> {\r\n        // TODO: Stop all agent teams\r\n        // TODO: Save state\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\agents\\planningTeam.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'requirement' is defined but never used.","line":10,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":44},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[260,263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[260,263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'taskId' is defined but never used.","line":22,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[582,585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[582,585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'taskDescription' is defined but never used.","line":33,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Planning Team Agent\r\n * Generates tasks from requirements and breaks down complex work\r\n */\r\n\r\nexport class PlanningTeam {\r\n    /**\r\n     * Generate tasks from a requirement or user story\r\n     */\r\n    async generateTasks(requirement: string): Promise<any[]> {\r\n        // TODO: Analyze requirement\r\n        // TODO: Break down into atomic tasks\r\n        // TODO: Identify dependencies\r\n        // TODO: Assign priorities\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Refine an existing task (make it more specific)\r\n     */\r\n    async refineTask(taskId: string): Promise<any> {\r\n        // TODO: Analyze task complexity\r\n        // TODO: Break into subtasks if needed\r\n        // TODO: Add acceptance criteria\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Estimate task effort\r\n     */\r\n    estimateEffort(taskDescription: string): { hours: number; confidence: number } {\r\n        // TODO: Analyze task complexity\r\n        // TODO: Compare with similar tasks\r\n        // TODO: Return estimate with confidence level\r\n\r\n        return { hours: 0, confidence: 0 };\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\agents\\verificationTeam.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'taskId' is defined but never used.","line":10,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'taskId' is defined but never used.","line":28,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'taskId' is defined but never used.","line":41,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Verification Team Agent\r\n * Validates task completion through automated and visual checks\r\n */\r\n\r\nexport class VerificationTeam {\r\n    /**\r\n     * Verify task completion\r\n     */\r\n    async verifyTask(taskId: string): Promise<{ passed: boolean; issues: string[] }> {\r\n\r\n        const issues: string[] = [];\r\n\r\n        // TODO: Run automated tests\r\n        // TODO: Check acceptance criteria\r\n        // TODO: Validate code quality\r\n        // TODO: Check for regressions\r\n\r\n        return {\r\n            passed: false,\r\n            issues\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Run automated verification checks\r\n     */\r\n    async runAutomatedChecks(taskId: string): Promise<boolean> {\r\n\r\n        // TODO: Run unit tests\r\n        // TODO: Run integration tests\r\n        // TODO: Run linters\r\n        // TODO: Check code coverage\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Generate visual verification checklist\r\n     */\r\n    generateVisualChecklist(taskId: string): string[] {\r\n        // TODO: Create checklist based on task type\r\n        // TODO: Include UI verification items if applicable\r\n        // TODO: Include manual test steps\r\n\r\n        return [\r\n            'Feature works as expected',\r\n            'No visual regressions',\r\n            'Error handling works',\r\n            'Documentation updated'\r\n        ];\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\db\\migrations.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[173,176],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[173,176],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[473,476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[473,476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'targetVersion' is assigned a value but never used.","line":31,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":31,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Manages database schema versioning and migrations.\r\n * Handles upgrades from old DB format to new schema without data loss.\r\n */\r\n\r\nexport function getDbVersion(db: any): number {\r\n\ttry {\r\n\t\tconst result = db.prepare(\r\n\t\t\t`SELECT version FROM db_version LIMIT 1`\r\n\t\t).get() as { version: number } | undefined;\r\n\t\treturn result?.version ?? 0;\r\n\t} catch {\r\n\t\t// Old DB without version table - assume schema v0\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\nexport function migrateSchema(db: any): void {\r\n\ttry {\r\n\t\t// Step 1: Create version tracking table if not exists\r\n\t\tdb.exec(`\r\n\t\t\tCREATE TABLE IF NOT EXISTS db_version (\r\n\t\t\t\tversion INTEGER NOT NULL\r\n\t\t\t)\r\n\t\t`);\r\n\r\n\t\t// Initial version for old DBs\r\n\t\tdb.exec(`INSERT OR IGNORE INTO db_version (version) VALUES (0)`);\r\n\r\n\t\tconst currentVersion = getDbVersion(db);\r\n\t\tconst targetVersion = 1;\r\n\r\n\t\t// Migration v0 -> v1: Add completed_tasks table\r\n\t\tif (currentVersion < 1) {\r\n\t\t\tdb.exec(`\r\n\t\t\t\tCREATE TABLE IF NOT EXISTS completed_tasks (\r\n\t\t\t\t\ttask_id TEXT PRIMARY KEY,\r\n\t\t\t\t\toriginal_ticket_id TEXT,\r\n\t\t\t\t\ttitle TEXT NOT NULL,\r\n\t\t\t\t\tstatus TEXT NOT NULL,\r\n\t\t\t\t\tpriority INTEGER NOT NULL,\r\n\t\t\t\t\tcompleted_at TEXT NOT NULL,\r\n\t\t\t\t\tduration_minutes INTEGER,\r\n\t\t\t\t\toutcome TEXT,\r\n\t\t\t\t\tcreated_at TEXT NOT NULL\r\n\t\t\t\t);\r\n\t\t\t\tCREATE INDEX IF NOT EXISTS idx_completed_status ON completed_tasks(status);\r\n\t\t\t\tCREATE INDEX IF NOT EXISTS idx_completed_at ON completed_tasks(completed_at);\r\n\t\t\t`);\r\n\r\n\t\t\t// Update schema version\r\n\t\t\tdb.exec(`UPDATE db_version SET version = 1`);\r\n\t\t}\r\n\r\n\t\t// Future migrations here: if (currentVersion < 2) { ... }\r\n\r\n\t} catch (error) {\r\n\t\tconst message = error instanceof Error ? error.message : String(error);\r\n\t\tthrow new Error(`Database migration error: ${message}`);\r\n\t}\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\db\\ticketsDb.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'reject' is defined but never used.","line":142,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":142,"endColumn":44},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":281,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10519,10522],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10519,10522],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":382,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":382,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13779,13782],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13779,13782],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":419,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":419,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15075,15078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15075,15078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":551,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":551,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19027,19030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19027,19030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isEBUSY' is assigned a value but never used.","line":625,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":625,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":876,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":876,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30998,31001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30998,31001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":902,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":902,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31920,31923],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31920,31923],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":921,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":921,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32645,32648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32645,32648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":935,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":935,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33012,33015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33012,33015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1031,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1031,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36188,36191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36188,36191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ≡ƒùä∩╕Å Ticket Database Manager\r\n * \r\n * SQLite database for persistent ticket storage with automatic migrations.\r\n * Falls back to in-memory Map storage if SQLite fails.\r\n * \r\n * Features:\r\n * - Auto-create .coe/tickets.db on first run\r\n * - CRUD operations: create, get, update, addReply\r\n * - JSON thread storage (array of replies)\r\n * - Auto-migration with \"CREATE TABLE IF NOT EXISTS\"\r\n * - Fallback to in-memory storage on DB errors\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport * as sqlite3 from 'sqlite3';\r\nimport {\r\n    Ticket,\r\n    TicketReply,\r\n    CreateTicketParams,\r\n    UpdateTicketParams,\r\n    AddReplyParams\r\n} from '../types/ticket';\r\n\r\n/**\r\n * Database configuration\r\n */\r\ninterface TicketDbConfig {\r\n    dbPath: string;         // Path to SQLite database file\r\n    autoMigrate: boolean;   // Auto-run migrations on init\r\n    skipPlaceholder?: boolean; // Skip creating placeholder ticket (for testing)\r\n}\r\n\r\n/**\r\n * Default database configuration\r\n */\r\nconst DEFAULT_CONFIG: TicketDbConfig = {\r\n    dbPath: '.coe/tickets.db',\r\n    autoMigrate: true\r\n};\r\n\r\n/**\r\n * TicketDatabase - Manages ticket persistence with SQLite\r\n * \r\n * Usage:\r\n * ```typescript\r\n * const db = TicketDatabase.getInstance();\r\n * await db.initialize(workspaceRoot);\r\n * const ticket = await db.createTicket({ ... });\r\n * ```\r\n */\r\nexport class TicketDatabase {\r\n    private static instance: TicketDatabase | null = null;\r\n    private db: sqlite3.Database | null = null;\r\n    private fallbackStore: Map<string, Ticket> = new Map();\r\n    private useFallback: boolean = false;\r\n    private config: TicketDbConfig = DEFAULT_CONFIG;\r\n    private initialized: boolean = false;\r\n\r\n    private constructor() { }\r\n\r\n    /**\r\n     * Get singleton instance\r\n     */\r\n    static getInstance(): TicketDatabase {\r\n        if (!TicketDatabase.instance) {\r\n            TicketDatabase.instance = new TicketDatabase();\r\n        }\r\n        return TicketDatabase.instance;\r\n    }\r\n\r\n    /**\r\n     * Reset singleton instance (for testing only)\r\n     */\r\n    static resetInstance(): void {\r\n        TicketDatabase.instance = null;\r\n    }\r\n\r\n    /**\r\n     * Initialize database with workspace root\r\n     * - Creates .coe directory if missing\r\n     * - Creates tickets.db file if missing\r\n     * - Runs migrations (CREATE TABLE IF NOT EXISTS)\r\n     * - Falls back to in-memory Map on errors\r\n     * - Strategy B/C: Adds placeholder task on NEW database, leaves existing DB empty\r\n     * \r\n     * @param workspaceRoot - Path to workspace root (VS Code workspace folder)\r\n     * @param customConfig - Optional custom configuration\r\n     */\r\n    async initialize(workspaceRoot: string, customConfig?: Partial<TicketDbConfig>): Promise<void> {\r\n        if (this.initialized) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Merge custom config with defaults\r\n            this.config = { ...DEFAULT_CONFIG, ...customConfig };\r\n\r\n            // Build absolute DB path\r\n            const coeDir = path.join(workspaceRoot, '.coe');\r\n            const dbPath = path.join(workspaceRoot, this.config.dbPath);\r\n\r\n            // **B/C Strategy**: Check if database is NEW or EXISTING\r\n            const isNewDatabase = !fs.existsSync(dbPath);\r\n\r\n            // Create .coe directory if missing\r\n            if (!fs.existsSync(coeDir)) {\r\n                fs.mkdirSync(coeDir, { recursive: true });\r\n            }\r\n\r\n            // Initialize SQLite database\r\n            await this.initializeSqlite(dbPath);\r\n\r\n            // Run migrations\r\n            if (this.config.autoMigrate && !this.useFallback) {\r\n                await this.runMigrations();\r\n            }\r\n\r\n            // **P1.3**: Cleanup old completed tasks (retention policy)\r\n            if (!this.useFallback) {\r\n                await this.cleanupOldCompletedTasks();\r\n            }\r\n\r\n            // **Strategy B**: If NEW database, add placeholder task (unless skipPlaceholder is set)\r\n            if (isNewDatabase && !this.useFallback && !this.config.skipPlaceholder) {\r\n                await this.createPlaceholderTicket();\r\n            }\r\n            // **Strategy C**: If EXISTING database, do nothing (leave empty or as-is)\r\n\r\n            this.initialized = true;\r\n        } catch (error) {\r\n            this.useFallback = true;\r\n            this.initialized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize SQLite database connection\r\n     */\r\n    private async initializeSqlite(dbPath: string): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                this.db = new sqlite3.Database(dbPath, (err) => {\r\n                    if (err) {\r\n                        this.useFallback = true;\r\n                        resolve(); // Don't reject, fall back to in-memory\r\n                    } else {\r\n                        resolve();\r\n                    }\r\n                });\r\n            } catch (error) {\r\n                this.useFallback = true;\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Run database migrations with versioning\r\n     * Creates/upgrades schema and tracks version for future migrations\r\n     */\r\n    private async runMigrations(): Promise<void> {\r\n        if (!this.db) {\r\n            return;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            if (!this.db) {\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            // Step 1: Create version tracking table if not exists\r\n            const versionTableSql = `\r\n                CREATE TABLE IF NOT EXISTS db_version (\r\n                    version INTEGER NOT NULL\r\n                );\r\n            `;\r\n\r\n            this.db.run(versionTableSql, (err) => {\r\n                if (err) {\r\n                    this.useFallback = true;\r\n                    resolve();\r\n                    return;\r\n                }\r\n\r\n                // Step 2: Initialize version if not already set\r\n                this.db?.run(`INSERT OR IGNORE INTO db_version (version) VALUES (0)`, (err) => {\r\n                    if (err) {\r\n                        // Ignore initialization errors\r\n                    }\r\n\r\n                    // Step 3: Create tickets table\r\n                    const createTicketsTableSql = `\r\n                        CREATE TABLE IF NOT EXISTS tickets (\r\n                            ticket_id TEXT PRIMARY KEY,\r\n                            type TEXT NOT NULL CHECK(type IN ('ai_to_human', 'human_to_ai')),\r\n                            status TEXT NOT NULL CHECK(status IN ('open', 'in_review', 'resolved', 'escalated', 'rejected')),\r\n                            priority INTEGER NOT NULL CHECK(priority IN (1, 2, 3)),\r\n                            creator TEXT NOT NULL,\r\n                            assignee TEXT NOT NULL,\r\n                            task_id TEXT,\r\n                            title TEXT NOT NULL,\r\n                            description TEXT NOT NULL,\r\n                            thread TEXT NOT NULL DEFAULT '[]',\r\n                            resolution TEXT,\r\n                            created_at TEXT NOT NULL,\r\n                            updated_at TEXT NOT NULL\r\n                        );\r\n                    `;\r\n\r\n                    this.db?.run(createTicketsTableSql, (err) => {\r\n                        if (err) {\r\n                            this.useFallback = true;\r\n                            resolve();\r\n                            return;\r\n                        }\r\n\r\n                        // Step 4: Check schema version and run v1 migration if needed\r\n                        this.getDbVersion((err, version) => {\r\n                            if (err || version === undefined) {\r\n                                resolve();\r\n                                return;\r\n                            }\r\n\r\n                            // Migration v0 ΓåÆ v1: Add completed_tasks table\r\n                            if (version < 1) {\r\n                                const createCompletedTableSql = `\r\n                                    CREATE TABLE IF NOT EXISTS completed_tasks (\r\n                                        task_id TEXT PRIMARY KEY,\r\n                                        original_ticket_id TEXT,\r\n                                        title TEXT NOT NULL,\r\n                                        status TEXT NOT NULL,\r\n                                        priority INTEGER NOT NULL,\r\n                                        completed_at TEXT NOT NULL,\r\n                                        duration_minutes INTEGER,\r\n                                        outcome TEXT,\r\n                                        created_at TEXT NOT NULL\r\n                                    );\r\n                                    CREATE INDEX IF NOT EXISTS idx_completed_status ON completed_tasks(status);\r\n                                    CREATE INDEX IF NOT EXISTS idx_completed_at ON completed_tasks(completed_at);\r\n                                `;\r\n\r\n                                this.db?.run(createCompletedTableSql, (err) => {\r\n                                    if (err) {\r\n                                        resolve();\r\n                                        return;\r\n                                    }\r\n\r\n                                    // Update schema version\r\n                                    this.db?.run(`UPDATE db_version SET version = 1`, (err) => {\r\n                                        if (err) {\r\n                                            // Ignore version update errors\r\n                                        } else {\r\n                                            // Version updated successfully\r\n                                        }\r\n                                        resolve();\r\n                                    });\r\n                                });\r\n                            } else {\r\n                                resolve();\r\n                            }\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get current database schema version\r\n     * @param callback - Returns (error, version) where version is 0 for old DBs\r\n     */\r\n    private getDbVersion(callback: (err: Error | null, version?: number) => void): void {\r\n        if (!this.db) {\r\n            callback(new Error('No database connection'));\r\n            return;\r\n        }\r\n\r\n        this.db.get('SELECT version FROM db_version LIMIT 1', (err: Error | null, row: any) => {\r\n            if (err) {\r\n                // Old DB without version table - assume v0\r\n                callback(null, 0);\r\n            } else {\r\n                callback(null, row?.version ?? 0);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new ticket\r\n     * \r\n     * @param params - Ticket creation parameters\r\n     * @returns Created ticket with generated ID and timestamps\r\n     */\r\n    async createTicket(params: CreateTicketParams): Promise<Ticket> {\r\n        const ticketId = this.generateTicketId();\r\n        const now = new Date();\r\n\r\n        const ticket: Ticket = {\r\n            ticket_id: ticketId,\r\n            type: params.type,\r\n            status: 'open',\r\n            priority: params.priority,\r\n            creator: params.creator,\r\n            assignee: params.assignee,\r\n            task_id: params.task_id,\r\n            title: params.title.substring(0, 200), // Max 200 chars\r\n            description: params.description.substring(0, 800), // Max 800 chars\r\n            thread: [],\r\n            created_at: now,\r\n            updated_at: now\r\n        };\r\n\r\n        if (this.useFallback) {\r\n            // In-memory fallback\r\n            this.fallbackStore.set(ticketId, ticket);\r\n            return ticket;\r\n        }\r\n\r\n        // SQLite storage\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            const sql = `\r\n                INSERT INTO tickets (\r\n                    ticket_id, type, status, priority, creator, assignee, task_id,\r\n                    title, description, thread, created_at, updated_at\r\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r\n            `;\r\n\r\n            const values = [\r\n                ticket.ticket_id,\r\n                ticket.type,\r\n                ticket.status,\r\n                ticket.priority,\r\n                ticket.creator,\r\n                ticket.assignee,\r\n                ticket.task_id || null,\r\n                ticket.title,\r\n                ticket.description,\r\n                JSON.stringify(ticket.thread),\r\n                ticket.created_at.toISOString(),\r\n                ticket.updated_at.toISOString()\r\n            ];\r\n\r\n            this.db.run(sql, values, (err) => {\r\n                if (err) {\r\n                    // Fallback to in-memory\r\n                    this.fallbackStore.set(ticketId, ticket);\r\n                    resolve(ticket);\r\n                } else {\r\n                    resolve(ticket);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get ticket by ID\r\n     * \r\n     * @param ticketId - Ticket ID to retrieve\r\n     * @returns Ticket or null if not found\r\n     */\r\n    async getTicket(ticketId: string): Promise<Ticket | null> {\r\n        if (this.useFallback) {\r\n            return this.fallbackStore.get(ticketId) || null;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            const sql = `SELECT * FROM tickets WHERE ticket_id = ?`;\r\n\r\n            this.db.get(sql, [ticketId], (err, row: any) => {\r\n                if (err) {\r\n                    // Try fallback\r\n                    resolve(this.fallbackStore.get(ticketId) || null);\r\n                } else if (!row) {\r\n                    resolve(null);\r\n                } else {\r\n                    resolve(this.rowToTicket(row));\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get all tickets (optionally filtered by status)\r\n     * \r\n     * @param status - Optional status filter\r\n     * @returns Array of tickets\r\n     */\r\n    async getAllTickets(status?: Ticket['status']): Promise<Ticket[]> {\r\n        if (this.useFallback) {\r\n            const tickets = Array.from(this.fallbackStore.values());\r\n            return status ? tickets.filter(t => t.status === status) : tickets;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            const sql = status\r\n                ? `SELECT * FROM tickets WHERE status = ? ORDER BY priority ASC, created_at DESC`\r\n                : `SELECT * FROM tickets ORDER BY priority ASC, created_at DESC`;\r\n\r\n            const params = status ? [status] : [];\r\n\r\n            this.db.all(sql, params, (err, rows: any[]) => {\r\n                if (err) {\r\n                    resolve(Array.from(this.fallbackStore.values()));\r\n                } else {\r\n                    resolve(rows.map(row => this.rowToTicket(row)));\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update ticket status and/or assignee\r\n     * \r\n     * @param params - Update parameters\r\n     * @returns Updated ticket or null if not found\r\n     */\r\n    async updateTicket(params: UpdateTicketParams): Promise<Ticket | null> {\r\n        const ticket = await this.getTicket(params.ticket_id);\r\n        if (!ticket) {\r\n            return null;\r\n        }\r\n\r\n        // Update fields\r\n        if (params.status) {\r\n            ticket.status = params.status;\r\n        }\r\n        if (params.assignee) {\r\n            ticket.assignee = params.assignee;\r\n        }\r\n        if (params.resolution !== undefined) {\r\n            ticket.resolution = params.resolution;\r\n        }\r\n        ticket.updated_at = new Date();\r\n\r\n        if (this.useFallback) {\r\n            this.fallbackStore.set(ticket.ticket_id, ticket);\r\n            return ticket;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            const sql = `\r\n                UPDATE tickets\r\n                SET status = ?, assignee = ?, resolution = ?, updated_at = ?\r\n                WHERE ticket_id = ?\r\n            `;\r\n\r\n            const values = [\r\n                ticket.status,\r\n                ticket.assignee,\r\n                ticket.resolution || null,\r\n                ticket.updated_at.toISOString(),\r\n                ticket.ticket_id\r\n            ];\r\n\r\n            this.db.run(sql, values, (err) => {\r\n                if (err) {\r\n                    // Update fallback anyway\r\n                    this.fallbackStore.set(ticket.ticket_id, ticket);\r\n                    resolve(ticket);\r\n                } else {\r\n                    resolve(ticket);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add reply to ticket thread\r\n     * \r\n     * @param params - Reply parameters\r\n     * @returns Updated ticket or null if ticket not found\r\n     */\r\n    async addReply(params: AddReplyParams): Promise<Ticket | null> {\r\n        const ticket = await this.getTicket(params.ticket_id);\r\n        if (!ticket) {\r\n            return null;\r\n        }\r\n\r\n        const reply: TicketReply = {\r\n            reply_id: this.generateReplyId(),\r\n            author: params.author,\r\n            content: params.content.substring(0, 2000), // Max 2000 chars\r\n            clarity_score: params.clarity_score,\r\n            created_at: new Date()\r\n        };\r\n\r\n        ticket.thread.push(reply);\r\n        ticket.updated_at = new Date();\r\n\r\n        if (this.useFallback) {\r\n            this.fallbackStore.set(ticket.ticket_id, ticket);\r\n            return ticket;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            const sql = `\r\n                UPDATE tickets\r\n                SET thread = ?, updated_at = ?\r\n                WHERE ticket_id = ?\r\n            `;\r\n\r\n            const values = [\r\n                JSON.stringify(ticket.thread),\r\n                ticket.updated_at.toISOString(),\r\n                ticket.ticket_id\r\n            ];\r\n\r\n            this.db.run(sql, values, (err) => {\r\n                if (err) {\r\n                    // Update fallback anyway\r\n                    this.fallbackStore.set(ticket.ticket_id, ticket);\r\n                    resolve(ticket);\r\n                } else {\r\n                    resolve(ticket);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Convert SQLite row to Ticket object\r\n     */\r\n    private rowToTicket(row: any): Ticket {\r\n        let thread: TicketReply[] = [];\r\n        try {\r\n            thread = JSON.parse(row.thread || '[]');\r\n        } catch (error) {\r\n            thread = [];\r\n        }\r\n\r\n        return {\r\n            ticket_id: row.ticket_id,\r\n            type: row.type,\r\n            status: row.status,\r\n            priority: row.priority,\r\n            creator: row.creator,\r\n            assignee: row.assignee,\r\n            task_id: row.task_id || undefined,\r\n            title: row.title,\r\n            description: row.description,\r\n            thread: thread,\r\n            resolution: row.resolution || undefined,\r\n            created_at: new Date(row.created_at),\r\n            updated_at: new Date(row.updated_at)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generate unique ticket ID (TK-XXXX format)\r\n     */\r\n    private generateTicketId(): string {\r\n        const timestamp = Date.now().toString().slice(-6);\r\n        const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\r\n        return `TK-${timestamp}${random}`;\r\n    }\r\n\r\n    /**\r\n     * Generate unique reply ID (RPL-XXXX format)\r\n     */\r\n    private generateReplyId(): string {\r\n        const timestamp = Date.now().toString().slice(-6);\r\n        const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\r\n        return `RPL-${timestamp}${random}`;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÆ╛ Close database connection gracefully\r\n     * \r\n     * Closes SQLite connection with retry logic for EBUSY (OneDrive/Windows file locks).\r\n     * Max 3 attempts with 500ms delay between retries.\r\n     * Logs warning if close fails but doesn't crash.\r\n     * Always sets db to null after attempt and switches to fallback Map.\r\n     * \r\n     * This method is safe to call on extension deactivate/reload.\r\n     * If close fails due to file lock, logs warning but continues gracefully.\r\n     * Fallback Map is always available if DB stays locked or after close.\r\n     * \r\n     * @async\r\n     * @returns Promise that resolves when DB is closed (or after retries exhausted)\r\n     */\r\n    async close(): Promise<void> {\r\n        if (!this.db) {\r\n            return; // Already closed or never opened\r\n        }\r\n\r\n        const maxAttempts = 3;\r\n        const retryDelayMs = 500;\r\n\r\n        for (let attempt = 1; attempt <= maxAttempts; attempt++) {\r\n            try {\r\n                await this.closeAsync();\r\n                this.db = null;\r\n                this.useFallback = true; // Switch to fallback Map for any further operations\r\n                return;\r\n            } catch (error) {\r\n                const errMsg = error instanceof Error ? error.message : String(error);\r\n                const isEBUSY = errMsg.includes('EBUSY') || errMsg.includes('locked');\r\n\r\n                if (attempt < maxAttempts) {\r\n                    // Retry with exponential backoff\r\n                    await new Promise((resolve) => setTimeout(resolve, retryDelayMs));\r\n                } else {\r\n                    // Give up but keep fallback available\r\n                    this.db = null; // Null it anyway so we don't try again\r\n                    this.useFallback = true; // Ensure fallback is used\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ΓÜÖ∩╕Å Private helper to close database (promisified)\r\n     * Wraps sqlite3.Database.close() callback in a Promise\r\n     * \r\n     * @private\r\n     * @async\r\n     * @returns Promise that rejects if close fails\r\n     */\r\n    private closeAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            this.db.close((err) => {\r\n                if (err) reject(err);\r\n                else resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get database statistics\r\n     */\r\n    async getStats(): Promise<{\r\n        total: number;\r\n        open: number;\r\n        inReview: number;\r\n        resolved: number;\r\n        escalated: number;\r\n        usingFallback: boolean;\r\n    }> {\r\n        const tickets = await this.getAllTickets();\r\n        return {\r\n            total: tickets.length,\r\n            open: tickets.filter(t => t.status === 'open').length,\r\n            inReview: tickets.filter(t => t.status === 'in_review').length,\r\n            resolved: tickets.filter(t => t.status === 'resolved').length,\r\n            escalated: tickets.filter(t => t.status === 'escalated').length,\r\n            usingFallback: this.useFallback\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create placeholder ticket for new databases (Strategy B)\r\n     * Used on first initialization to avoid confusing empty state\r\n     * \r\n     * @private\r\n     * @async\r\n     */\r\n    private async createPlaceholderTicket(): Promise<void> {\r\n        try {\r\n            await this.createTicket({\r\n                type: 'ai_to_human',\r\n                priority: 3,\r\n                creator: 'SYSTEM',\r\n                assignee: 'SYSTEM',\r\n                title: '[PLACEHOLDER] New Database - Delete this task',\r\n                description: 'This is a temporary placeholder ticket created on first run. You can safely delete this ticket by changing its status to resolved or updating any field.'\r\n            });\r\n        } catch (error) {\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒùæ∩╕Å Cleanup old completed tasks based on retention policy (P1.3)\r\n     * \r\n     * Removes completed tasks older than taskRetentionDays from config.json.\r\n     * Default retention: 30 days (can be overridden in .coe/config.json).\r\n     * \r\n     * Error handling:\r\n     * - Config missing/invalid: Uses default 30 days\r\n     * - DB error: Logs warning but doesn't crash\r\n     * - Cleanup runs silently (no user notification unless error)\r\n     * \r\n     * Called automatically on initialize() after migrations complete.\r\n     * \r\n     * @private\r\n     * @async\r\n     */\r\n    private async cleanupOldCompletedTasks(): Promise<void> {\r\n        if (!this.db) {\r\n            return; // DB not initialized, skip cleanup\r\n        }\r\n\r\n        try {\r\n            // Load taskRetentionDays from config.json (default: 30 days)\r\n            const retentionDays = await this.getTaskRetentionDays();\r\n            const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000).toISOString();\r\n\r\n            return new Promise((resolve) => {\r\n                if (!this.db) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n\r\n                // Delete completed tasks older than cutoff date\r\n                this.db.run(\r\n                    `DELETE FROM completed_tasks WHERE completed_at < ?`,\r\n                    [cutoffDate],\r\n                    (err) => {\r\n                        if (err) {\r\n                            // eslint-disable-next-line no-empty\r\n                        } else {\r\n                            // eslint-disable-next-line no-empty\r\n                        }\r\n                        resolve();\r\n                    }\r\n                );\r\n            });\r\n        } catch (error) {\r\n            // Fallback error handler - connection cleanup\r\n            void error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load taskRetentionDays from .coe/config.json\r\n     * \r\n     * Returns the configured retention period in days.\r\n     * Falls back to 30 days if config missing or invalid.\r\n     * \r\n     * @private\r\n     * @async\r\n     * @returns Promise<number> - Days to retain completed tasks\r\n     */\r\n    private async getTaskRetentionDays(): Promise<number> {\r\n        const defaultRetention = 30;\r\n\r\n        try {\r\n            const configPath = path.join(path.dirname(this.config.dbPath), '..', 'config.json');\r\n            const configContent = fs.readFileSync(configPath, 'utf8');\r\n            const config = JSON.parse(configContent);\r\n\r\n            const retention = config?.database?.taskRetentionDays;\r\n            if (typeof retention === 'number' && retention > 0) {\r\n                return retention;\r\n            }\r\n        } catch (error) {\r\n            // Config file not found or invalid - use default\r\n        }\r\n\r\n        return defaultRetention;\r\n    }\r\n\r\n    /**\r\n     * Archive a task to completed_tasks table (P1.1 - Task History)\r\n     * Moves task from active tracking to history; used when task completes or is archived.\r\n     * \r\n     * **Option A (Reusable TicketIds)**: \r\n     * - `originalTicketId` is stored as reference (can be duplicated across multiple test runs)\r\n     * - Each run gets unique `task_id` (PRIMARY KEY, timestamp-based)\r\n     * - Allows same ticketId to be reused in future test/production cycles\r\n     * - Active queue (hasTaskForTicket) only checks active statuses, not archived\r\n     * - Multiple archived entries with same originalTicketId = safe, expected\r\n     * \r\n     * Example Flow:\r\n     * ```\r\n     * Run 1: Create ticket 'TEST_001' ΓåÆ archive with originalTicketId='TEST_001'\r\n     * Run 2: Create ticket 'TEST_001' ΓåÆ archive with originalTicketId='TEST_001' \r\n     *        (different task_id each time, both stored in completed_tasks)\r\n     * Run 3: Create ticket 'TEST_001' ΓåÆ hasTaskForTicket('TEST_001') ΓåÆ false\r\n     *        (active queue is clean, previous archived entries ignored)\r\n     * ```\r\n     * \r\n     * @param taskId - Unique task identifier (PRIMARY KEY, generated per run)\r\n     * @param title - Task title\r\n     * @param status - Final status ('completed' | 'failed' | 'archived')\r\n     * @param originalTicketId - Reference to original ticket (Option A: can duplicate)\r\n     * @param durationMinutes - How long task took (optional)\r\n     * @returns Promise<void>\r\n     */\r\n    async archiveTask(\r\n        taskId: string,\r\n        title: string,\r\n        status: 'completed' | 'failed' | 'archived' = 'completed',\r\n        originalTicketId?: string,\r\n        durationMinutes?: number\r\n    ): Promise<void> {\r\n        if (!taskId || !title) {\r\n            throw new Error('archiveTask: taskId and title are required');\r\n        }\r\n\r\n        if (this.useFallback) {\r\n            // Fallback: store in memory\r\n            const now = new Date().toISOString();\r\n            if (!this.fallbackCompletedTasks) {\r\n                this.fallbackCompletedTasks = new Map();\r\n            }\r\n            this.fallbackCompletedTasks.set(taskId, {\r\n                task_id: taskId,\r\n                original_ticket_id: originalTicketId,\r\n                title,\r\n                status,\r\n                priority: 2, // Default priority for archived tasks\r\n                completed_at: now,\r\n                duration_minutes: durationMinutes,\r\n                outcome: undefined,\r\n                created_at: now\r\n            });\r\n            return;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            const now = new Date().toISOString();\r\n            this.db!.run(\r\n                `INSERT INTO completed_tasks (task_id, original_ticket_id, title, status, priority, completed_at, duration_minutes, created_at)\r\n                 VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\r\n                [taskId, originalTicketId || null, title, status, 2, now, durationMinutes || null, now],\r\n                (err) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve();\r\n                    }\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get all completed tasks from history (P1.1 - Task History)\r\n     * Retrieves tasks moved to completed_tasks table.\r\n     * \r\n     * @param filters - Optional: { status?: string; minDaysAgo?: number }\r\n     * @returns Promise<CompletedTask[]>\r\n     */\r\n    async getAllCompleted(filters?: {\r\n        status?: 'completed' | 'failed' | 'archived';\r\n        minDaysAgo?: number;\r\n    }): Promise<any[]> {\r\n        if (this.useFallback) {\r\n            // Fallback: return from memory\r\n            if (!this.fallbackCompletedTasks) {\r\n                return [];\r\n            }\r\n            let tasks = Array.from(this.fallbackCompletedTasks.values());\r\n\r\n            if (filters?.status) {\r\n                tasks = tasks.filter(t => t.status === filters.status);\r\n            }\r\n            if (filters?.minDaysAgo !== undefined) {\r\n                const cutoffDate = new Date(Date.now() - filters.minDaysAgo * 24 * 60 * 60 * 1000).toISOString();\r\n                tasks = tasks.filter(t => t.completed_at >= cutoffDate);\r\n            }\r\n\r\n            return tasks;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            let where = '';\r\n            const params: any[] = [];\r\n\r\n            if (filters?.status) {\r\n                where += `WHERE status = ?`;\r\n                params.push(filters.status);\r\n            }\r\n\r\n            if (filters?.minDaysAgo !== undefined) {\r\n                const cutoffDate = new Date(Date.now() - filters.minDaysAgo * 24 * 60 * 60 * 1000).toISOString();\r\n                if (where) {\r\n                    where += ` AND completed_at >= ?`;\r\n                } else {\r\n                    where = `WHERE completed_at >= ?`;\r\n                }\r\n                params.push(cutoffDate);\r\n            }\r\n\r\n            const query = `SELECT * FROM completed_tasks ${where} ORDER BY completed_at DESC`;\r\n\r\n            this.db!.all(query, params, (err, rows: any[]) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve(rows);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Private fallback storage for completed tasks (in-memory)\r\n     * Used when SQLite is unavailable\r\n     */\r\n    private fallbackCompletedTasks?: Map<string, any>;\r\n\r\n    /**\r\n     * Check if a ticket exists by ID (for orphan detection)\r\n     * \r\n     * @param ticketId - Ticket ID to check\r\n     * @returns Promise<boolean> - True if ticket exists, false otherwise\r\n     */\r\n    async doesTicketExist(ticketId: string): Promise<boolean> {\r\n        if (this.useFallback) {\r\n            return this.fallbackStore.has(ticketId);\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            if (!this.db) {\r\n                resolve(false);\r\n                return;\r\n            }\r\n\r\n            this.db!.get(\r\n                `SELECT 1 FROM tickets WHERE ticket_id = ? LIMIT 1`,\r\n                [ticketId],\r\n                (err, row) => {\r\n                    if (err) {\r\n                        resolve(false);\r\n                    } else {\r\n                        resolve(!!row);\r\n                    }\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Cleanup old completed tasks based on retention policy (P1.3 - Cleanup)\r\n     * Supports dual-mode cleanup: age-based OR count-based OR both\r\n     * \r\n     * @param maxAgeHours - Delete tasks older than N hours (0 = disabled)\r\n     * @param maxCount - Keep only last N tasks (0 = unlimited)\r\n     * @returns Promise<number> - Number of tasks deleted\r\n     */\r\n    async cleanupOldTasks(maxAgeHours: number, maxCount: number): Promise<number> {\r\n        // Validate inputs\r\n        const ageHours = Math.max(0, maxAgeHours || 0);\r\n        const keepCount = Math.max(0, maxCount || 0);\r\n\r\n        // Both disabled = no cleanup\r\n        if (ageHours === 0 && keepCount === 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (this.useFallback) {\r\n            // Fallback cleanup (in-memory)\r\n            if (!this.fallbackCompletedTasks) {\r\n                return 0;\r\n            }\r\n\r\n            let deleted = 0;\r\n            const tasks = Array.from(this.fallbackCompletedTasks.entries());\r\n\r\n            // Sort by completed_at DESC (newest first)\r\n            tasks.sort((a, b) => b[1].completed_at.localeCompare(a[1].completed_at));\r\n\r\n            tasks.forEach(([taskId, task], index) => {\r\n                let shouldDelete = false;\r\n\r\n                // Age-based check\r\n                if (ageHours > 0) {\r\n                    const cutoffTime = Date.now() - ageHours * 60 * 60 * 1000;\r\n                    const taskTime = new Date(task.completed_at).getTime();\r\n                    if (taskTime < cutoffTime) {\r\n                        shouldDelete = true;\r\n                    }\r\n                }\r\n\r\n                // Count-based check (keep only newest N)\r\n                if (keepCount > 0 && index >= keepCount) {\r\n                    shouldDelete = true;\r\n                }\r\n\r\n                if (shouldDelete) {\r\n                    this.fallbackCompletedTasks!.delete(taskId);\r\n                    deleted++;\r\n                }\r\n            });\r\n\r\n            return deleted;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            let query = '';\r\n            const params: any[] = [];\r\n\r\n            if (ageHours > 0 && keepCount > 0) {\r\n                // Both modes enabled: Delete if too old OR beyond count limit\r\n                const cutoffTime = new Date(Date.now() - ageHours * 60 * 60 * 1000).toISOString();\r\n                query = `\r\n                    DELETE FROM completed_tasks \r\n                    WHERE completed_at < ?\r\n                       OR task_id IN (\r\n                           SELECT task_id FROM completed_tasks \r\n                           ORDER BY completed_at DESC \r\n                           LIMIT -1 OFFSET ?\r\n                       )\r\n                `;\r\n                params.push(cutoffTime, keepCount);\r\n            } else if (ageHours > 0) {\r\n                // Age-based only\r\n                const cutoffTime = new Date(Date.now() - ageHours * 60 * 60 * 1000).toISOString();\r\n                query = `DELETE FROM completed_tasks WHERE completed_at < ?`;\r\n                params.push(cutoffTime);\r\n            } else if (keepCount > 0) {\r\n                // Count-based only: Keep newest N, delete rest\r\n                query = `\r\n                    DELETE FROM completed_tasks \r\n                    WHERE task_id IN (\r\n                        SELECT task_id FROM completed_tasks \r\n                        ORDER BY completed_at DESC \r\n                        LIMIT -1 OFFSET ?\r\n                    )\r\n                `;\r\n                params.push(keepCount);\r\n            }\r\n\r\n            this.db!.run(query, params, function (err) {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    const deletedCount = this.changes || 0;\r\n                    resolve(deletedCount);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\diagnostics\\coverageProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2915,2918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2915,2918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3163,3166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3163,3166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fileUri' is assigned a value but never used.","line":88,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fileUri' is assigned a value but never used.","line":138,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":138,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n/**\r\n * Diagnostic provider that monitors coverage data and reports under-coverage files\r\n * to the VS Code Problems panel in real-time.\r\n */\r\nexport class CoverageDiagnosticProvider {\r\n    private diagnosticCollection: vscode.DiagnosticCollection;\r\n    private fileWatcher: vscode.FileSystemWatcher | undefined;\r\n    private readonly coverageThreshold = 75; // 75% coverage target\r\n\r\n    constructor() {\r\n        this.diagnosticCollection = vscode.languages.createDiagnosticCollection('coverage');\r\n    }\r\n\r\n    /**\r\n     * Activate the coverage provider\r\n     */\r\n    public activate(context: vscode.ExtensionContext): void {\r\n        // Watch for coverage file changes\r\n        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\r\n        if (!workspaceRoot) {\r\n            return;\r\n        }\r\n\r\n        const coveragePattern = new vscode.RelativePattern(\r\n            workspaceRoot,\r\n            'coverage/coverage-final.json'\r\n        );\r\n\r\n        this.fileWatcher = vscode.workspace.createFileSystemWatcher(coveragePattern);\r\n\r\n        // Update diagnostics when coverage file changes\r\n        this.fileWatcher.onDidChange(() => this.updateDiagnostics(workspaceRoot));\r\n        this.fileWatcher.onDidCreate(() => this.updateDiagnostics(workspaceRoot));\r\n\r\n        context.subscriptions.push(\r\n            this.fileWatcher,\r\n            this.diagnosticCollection\r\n        );\r\n\r\n        // Initial update\r\n        this.updateDiagnostics(workspaceRoot);\r\n\r\n        // Also watch the quality-diagnostics.json file\r\n        const qualityDiagnosticsPattern = new vscode.RelativePattern(\r\n            workspaceRoot,\r\n            '.vscode/quality-diagnostics.json'\r\n        );\r\n\r\n        const qualityWatcher = vscode.workspace.createFileSystemWatcher(qualityDiagnosticsPattern);\r\n        qualityWatcher.onDidChange(() => this.updateFromQualityDiagnostics(workspaceRoot));\r\n        qualityWatcher.onDidCreate(() => this.updateFromQualityDiagnostics(workspaceRoot));\r\n\r\n        context.subscriptions.push(qualityWatcher);\r\n\r\n        // Initial update from quality diagnostics\r\n        this.updateFromQualityDiagnostics(workspaceRoot);\r\n    }\r\n\r\n    /**\r\n     * Update diagnostics from coverage-final.json\r\n     */\r\n    private updateDiagnostics(workspaceRoot: string): void {\r\n        const coveragePath = path.join(workspaceRoot, 'coverage', 'coverage-final.json');\r\n\r\n        if (!fs.existsSync(coveragePath)) {\r\n            // Clear diagnostics if coverage file doesn't exist\r\n            this.diagnosticCollection.clear();\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const coverageData = JSON.parse(fs.readFileSync(coveragePath, 'utf-8'));\r\n            const diagnostics = new Map<string, vscode.Diagnostic[]>();\r\n\r\n            for (const [filePath, fileData] of Object.entries<any>(coverageData)) {\r\n                const { l } = fileData;\r\n\r\n                // Calculate line coverage percentage\r\n                const totalLines = Object.keys(l).length;\r\n                const coveredLines = Object.values(l).filter((hits: any) => hits > 0).length;\r\n                const lineCoverage = totalLines > 0 ? (coveredLines / totalLines) * 100 : 100;\r\n\r\n                if (lineCoverage < this.coverageThreshold) {\r\n                    const fileUri = vscode.Uri.file(filePath);\r\n                    const gap = this.coverageThreshold - lineCoverage;\r\n\r\n                    const diagnostic = new vscode.Diagnostic(\r\n                        new vscode.Range(0, 0, 0, 0), // First line of file\r\n                        `Test coverage (${lineCoverage.toFixed(1)}%) is below threshold (${this.coverageThreshold}%). Add ${gap.toFixed(1)}% more coverage.`,\r\n                        vscode.DiagnosticSeverity.Warning\r\n                    );\r\n\r\n                    diagnostic.source = 'Quality Gate: Coverage';\r\n                    diagnostic.code = 'coverage-threshold';\r\n\r\n                    if (!diagnostics.has(filePath)) {\r\n                        diagnostics.set(filePath, []);\r\n                    }\r\n                    diagnostics.get(filePath)!.push(diagnostic);\r\n                }\r\n            }\r\n\r\n            // Clear old diagnostics\r\n            this.diagnosticCollection.clear();\r\n\r\n            // Set new diagnostics\r\n            for (const [filePath, fileDiagnostics] of diagnostics.entries()) {\r\n                this.diagnosticCollection.set(vscode.Uri.file(filePath), fileDiagnostics);\r\n            }\r\n\r\n        } catch (error) {\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update diagnostics from quality-diagnostics.json (generated by quality-gates.test.ts)\r\n     */\r\n    private updateFromQualityDiagnostics(workspaceRoot: string): void {\r\n        const diagnosticsPath = path.join(workspaceRoot, '.vscode', 'quality-diagnostics.json');\r\n\r\n        if (!fs.existsSync(diagnosticsPath)) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const qualityData = JSON.parse(fs.readFileSync(diagnosticsPath, 'utf-8'));\r\n            const underCoverageFiles = qualityData.underCoverageFiles || [];\r\n\r\n            const diagnostics = new Map<string, vscode.Diagnostic[]>();\r\n\r\n            for (const { file, coverage } of underCoverageFiles) {\r\n                const fullPath = path.join(workspaceRoot, file);\r\n                const fileUri = vscode.Uri.file(fullPath);\r\n                const gap = this.coverageThreshold - coverage;\r\n\r\n                const diagnostic = new vscode.Diagnostic(\r\n                    new vscode.Range(0, 0, 0, 0),\r\n                    `Test coverage (${coverage}%) is below threshold (${this.coverageThreshold}%). Add ${gap.toFixed(1)}% more coverage.`,\r\n                    vscode.DiagnosticSeverity.Warning\r\n                );\r\n\r\n                diagnostic.source = 'Quality Gate: Coverage';\r\n                diagnostic.code = 'coverage-threshold';\r\n\r\n                if (!diagnostics.has(fullPath)) {\r\n                    diagnostics.set(fullPath, []);\r\n                }\r\n                diagnostics.get(fullPath)!.push(diagnostic);\r\n            }\r\n\r\n            // Clear and set diagnostics\r\n            this.diagnosticCollection.clear();\r\n            for (const [filePath, fileDiagnostics] of diagnostics.entries()) {\r\n                this.diagnosticCollection.set(vscode.Uri.file(filePath), fileDiagnostics);\r\n            }\r\n\r\n        } catch (error) {\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose of resources\r\n     */\r\n    public dispose(): void {\r\n        this.diagnosticCollection.dispose();\r\n        this.fileWatcher?.dispose();\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\diagnostics\\skippedTestsProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uri' is defined but never used.","line":108,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":108,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fileUri' is assigned a value but never used.","line":180,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":180,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n/**\r\n * Diagnostic provider that scans test files for .skip, .only, .pending patterns\r\n * and reports them to the VS Code Problems panel in real-time.\r\n */\r\nexport class SkippedTestsDiagnosticProvider {\r\n    private diagnosticCollection: vscode.DiagnosticCollection;\r\n    private fileWatcher: vscode.FileSystemWatcher | undefined;\r\n    private documentChangeListener: vscode.Disposable | undefined;\r\n\r\n    constructor() {\r\n        this.diagnosticCollection = vscode.languages.createDiagnosticCollection('skipped-tests');\r\n    }\r\n\r\n    /**\r\n     * Activate the skipped tests provider\r\n     */\r\n    public activate(context: vscode.ExtensionContext): void {\r\n        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\r\n        if (!workspaceRoot) {\r\n            return;\r\n        }\r\n\r\n        // Watch for test file changes\r\n        const testFilePattern = new vscode.RelativePattern(\r\n            workspaceRoot,\r\n            '**/*.{test,spec}.ts'\r\n        );\r\n\r\n        this.fileWatcher = vscode.workspace.createFileSystemWatcher(testFilePattern);\r\n\r\n        this.fileWatcher.onDidChange((uri) => this.updateFileSync(uri));\r\n        this.fileWatcher.onDidCreate((uri) => this.updateFileSync(uri));\r\n        this.fileWatcher.onDidDelete((uri) => this.diagnosticCollection.delete(uri));\r\n\r\n        // Listen to document changes for real-time updates\r\n        this.documentChangeListener = vscode.workspace.onDidChangeTextDocument((event) => {\r\n            const uri = event.document.uri;\r\n            if (uri.fsPath.match(/\\.(test|spec)\\.ts$/)) {\r\n                this.updateFileAsync(event.document);\r\n            }\r\n        });\r\n\r\n        // Listen to document opens\r\n        const documentOpenListener = vscode.workspace.onDidOpenTextDocument((document) => {\r\n            if (document.uri.fsPath.match(/\\.(test|spec)\\.ts$/)) {\r\n                this.updateFileAsync(document);\r\n            }\r\n        });\r\n\r\n        context.subscriptions.push(\r\n            this.fileWatcher,\r\n            this.diagnosticCollection,\r\n            this.documentChangeListener,\r\n            documentOpenListener\r\n        );\r\n\r\n        // Scan all open test files initially\r\n        for (const document of vscode.workspace.textDocuments) {\r\n            if (document.uri.fsPath.match(/\\.(test|spec)\\.ts$/)) {\r\n                this.updateFileAsync(document);\r\n            }\r\n        }\r\n\r\n        // Also watch quality-diagnostics.json for batch updates\r\n        const qualityDiagnosticsPattern = new vscode.RelativePattern(\r\n            workspaceRoot,\r\n            '.vscode/quality-diagnostics.json'\r\n        );\r\n\r\n        const qualityWatcher = vscode.workspace.createFileSystemWatcher(qualityDiagnosticsPattern);\r\n        qualityWatcher.onDidChange(() => this.updateFromQualityDiagnostics(workspaceRoot));\r\n        qualityWatcher.onDidCreate(() => this.updateFromQualityDiagnostics(workspaceRoot));\r\n\r\n        context.subscriptions.push(qualityWatcher);\r\n\r\n        // Initial update from quality diagnostics\r\n        this.updateFromQualityDiagnostics(workspaceRoot);\r\n    }\r\n\r\n    /**\r\n     * Update diagnostics for a file synchronously (from file system)\r\n     */\r\n    private updateFileSync(uri: vscode.Uri): void {\r\n        try {\r\n            const content = fs.readFileSync(uri.fsPath, 'utf-8');\r\n            const diagnostics = this.scanForSkippedTests(content, uri);\r\n            this.diagnosticCollection.set(uri, diagnostics);\r\n        } catch (error) {\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update diagnostics for a file asynchronously (from open document)\r\n     */\r\n    private updateFileAsync(document: vscode.TextDocument): void {\r\n        const diagnostics = this.scanForSkippedTests(document.getText(), document.uri);\r\n        this.diagnosticCollection.set(document.uri, diagnostics);\r\n    }\r\n\r\n    /**\r\n     * Scan file content for skipped test patterns\r\n     */\r\n    private scanForSkippedTests(content: string, uri: vscode.Uri): vscode.Diagnostic[] {\r\n        const diagnostics: vscode.Diagnostic[] = [];\r\n        const lines = content.split('\\n');\r\n\r\n        const patterns = [\r\n            { regex: /\\b(describe|it|test)\\.skip\\s*\\(/g, name: '.skip', severity: vscode.DiagnosticSeverity.Warning },\r\n            { regex: /\\b(describe|it|test)\\.only\\s*\\(/g, name: '.only', severity: vscode.DiagnosticSeverity.Error },\r\n            { regex: /\\b(describe|it|test)\\.pending\\s*\\(/g, name: '.pending', severity: vscode.DiagnosticSeverity.Information },\r\n            { regex: /\\bxdescribe\\s*\\(/g, name: 'xdescribe', severity: vscode.DiagnosticSeverity.Warning },\r\n            { regex: /\\bxit\\s*\\(/g, name: 'xit', severity: vscode.DiagnosticSeverity.Warning },\r\n            { regex: /\\bxtest\\s*\\(/g, name: 'xtest', severity: vscode.DiagnosticSeverity.Warning }\r\n        ];\r\n\r\n        lines.forEach((line, lineIndex) => {\r\n            for (const { regex, name, severity } of patterns) {\r\n                const matches = line.matchAll(regex);\r\n                for (const match of matches) {\r\n                    const startCol = match.index || 0;\r\n                    const endCol = startCol + match[0].length;\r\n\r\n                    const range = new vscode.Range(\r\n                        lineIndex,\r\n                        startCol,\r\n                        lineIndex,\r\n                        endCol\r\n                    );\r\n\r\n                    let message = '';\r\n                    if (name === '.only') {\r\n                        message = `Test is focused with ${name}. This will prevent other tests from running! Remove before committing.`;\r\n                    } else if (name === '.skip' || name.startsWith('x')) {\r\n                        message = `Test is skipped with ${name}. This test will not run in CI.`;\r\n                    } else {\r\n                        message = `Test is pending with ${name}.`;\r\n                    }\r\n\r\n                    const diagnostic = new vscode.Diagnostic(\r\n                        range,\r\n                        message,\r\n                        severity\r\n                    );\r\n\r\n                    diagnostic.source = 'Quality Gate: Tests';\r\n                    diagnostic.code = `skipped-test-${name.replace('.', '')}`;\r\n\r\n                    diagnostics.push(diagnostic);\r\n                }\r\n            }\r\n        });\r\n\r\n        return diagnostics;\r\n    }\r\n\r\n    /**\r\n     * Update diagnostics from quality-diagnostics.json (generated by quality-gates.test.ts)\r\n     */\r\n    private updateFromQualityDiagnostics(workspaceRoot: string): void {\r\n        const diagnosticsPath = path.join(workspaceRoot, '.vscode', 'quality-diagnostics.json');\r\n\r\n        if (!fs.existsSync(diagnosticsPath)) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const qualityData = JSON.parse(fs.readFileSync(diagnosticsPath, 'utf-8'));\r\n            const skippedTests = qualityData.skippedTests || [];\r\n\r\n            // Group by file\r\n            const diagnosticsByFile = new Map<string, vscode.Diagnostic[]>();\r\n\r\n            for (const { file, line, pattern, match } of skippedTests) {\r\n                const fullPath = path.join(workspaceRoot, file);\r\n                const fileUri = vscode.Uri.file(fullPath);\r\n\r\n                const severity = pattern === '.only'\r\n                    ? vscode.DiagnosticSeverity.Error\r\n                    : vscode.DiagnosticSeverity.Warning;\r\n\r\n                const diagnostic = new vscode.Diagnostic(\r\n                    new vscode.Range(line - 1, 0, line - 1, 200),\r\n                    `Skipped test detected: ${pattern} - ${match}`,\r\n                    severity\r\n                );\r\n\r\n                diagnostic.source = 'Quality Gate: Tests';\r\n                diagnostic.code = `skipped-test-${pattern.replace('.', '')}`;\r\n\r\n                if (!diagnosticsByFile.has(fullPath)) {\r\n                    diagnosticsByFile.set(fullPath, []);\r\n                }\r\n                diagnosticsByFile.get(fullPath)!.push(diagnostic);\r\n            }\r\n\r\n            // Update diagnostics for each file\r\n            for (const [filePath, fileDiagnostics] of diagnosticsByFile.entries()) {\r\n                this.diagnosticCollection.set(vscode.Uri.file(filePath), fileDiagnostics);\r\n            }\r\n\r\n        } catch (error) {\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose of resources\r\n     */\r\n    public dispose(): void {\r\n        this.diagnosticCollection.dispose();\r\n        this.fileWatcher?.dispose();\r\n        this.documentChangeListener?.dispose();\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\extension.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setupMissingFiles' is defined but never used.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2472,2475],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2472,2475],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":144,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5721,5724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5721,5724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5793,5796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5793,5796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is defined but never used.","line":201,"column":69,"nodeType":"Identifier","messageId":"unusedVar","endLine":201,"endColumn":75},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'validConfig' is defined but never used.","line":203,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":203,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":304,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":304,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15387,15390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15387,15390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'t' is defined but never used.","line":375,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":375,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":951,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":951,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[49979,49982],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[49979,49982],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":960,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":960,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50720,50723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50720,50723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":961,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":961,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50867,50870],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50867,50870],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1207,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1207,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[64933,64936],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[64933,64936],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1208,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1208,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[65014,65017],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[65014,65017],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorMsg' is assigned a value but never used.","line":1314,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":1314,"endColumn":23}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentProcessingTask' is assigned a value but never used.","line":52,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":52,"endColumn":86,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Copilot Orchestration Extension (COE) - Main Entry Point\r\n * \r\n * This file is the \"brain\" of the extension. It activates when VS Code starts\r\n * and sets up all the features like the MCP server, task management, and UI.\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport { ProgrammingOrchestrator, SimpleLogger, TaskPriority, TaskStatus, Task } from './orchestrator/programmingOrchestrator';\r\nimport { loadTasksFromPlanFile } from './plans/planningStub';\r\nimport { setupMissingFiles } from './utils/setupFiles';\r\nimport { CoeTaskTreeProvider } from './tree/CoeTaskTreeProvider';\r\nimport { CompletedTasksTreeProvider } from './ui/completedTasksTreeProvider';\r\nimport { FileConfigManager, LLMConfig as FileLLMConfig } from './utils/fileConfig';\r\nimport { LLMConfigManager } from './services/llmConfigManager';\r\nimport { callLLMWithStreaming } from './utils/streamingLLM';\r\nimport { PRDGenerator } from './services/prdGenerator';\r\nimport { PlansFileWatcher } from './services/plansWatcher';\r\nimport { TicketDatabase } from './db/ticketsDb';\r\nimport { CoverageDiagnosticProvider } from './diagnostics/coverageProvider';\r\nimport { SkippedTestsDiagnosticProvider } from './diagnostics/skippedTestsProvider';\r\nimport { ConfigManager } from './utils/config';\r\n\r\n// ============================================================================\r\n// Global State\r\n// ============================================================================\r\n\r\n/**\r\n * ≡ƒÄ» Global Programming Orchestrator instance\r\n * Accessible throughout the extension for coordinating task execution\r\n */\r\nlet programmingOrchestrator: ProgrammingOrchestrator | null = null;\r\n\r\n/**\r\n * ≡ƒô¥ Output channel for COE logging\r\n * Shows orchestrator initialization and task events\r\n */\r\nlet orchestratorOutputChannel: vscode.OutputChannel | null = null;\r\n\r\n/**\r\n * ∩┐╜ Status Bar Item for COE status display\r\n * Shows current queue status and allows quick access to process next task\r\n */\r\nlet statusBarItem: vscode.StatusBarItem | null = null;\r\n\r\n/**\r\n * ≡ƒöä Currently processing task (for status bar display)\r\n * Reserved for future use - currently status comes from orchestrator.getQueueStatus()\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nlet currentProcessingTask: { taskId: string; title: string; priority: string } | null = null;\r\n\r\n/**\r\n * ≡ƒÄ½ Global TicketDb instance\r\n * Manages ticket persistence with SQLite + fallback Map\r\n */\r\nlet globalTicketDb: any = null; // Will be initialized on first use\r\n\r\n/**\r\n * ≡ƒöì Get the current orchestrator instance\r\n * Used by other parts of the extension to access the orchestrator\r\n */\r\nexport function getOrchestrator(): ProgrammingOrchestrator | null {\r\n    return programmingOrchestrator;\r\n}\r\n\r\n/**\r\n * ≡ƒôè Get the current status bar item\r\n * Used for testing and status updates\r\n */\r\nexport function getStatusBarItem(): vscode.StatusBarItem | null {\r\n    return statusBarItem;\r\n}\r\n\r\n/**\r\n * ≡ƒöº Get the current LLM configuration\r\n * Reads from .coe/config.json (tool-agnostic, no hardcoded defaults)\r\n */\r\nexport function getLLMConfig(): FileLLMConfig {\r\n    return FileConfigManager.getLLMConfig();\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\n/**\r\n * ≡ƒöä Update the VS Code status bar with current queue information\r\n * Shows priority-aware queue status and allows interaction\r\n * \r\n * Updates based on orchestrator state:\r\n * - Green when idle/ready\r\n * - Yellow when tasks are being worked on\r\n * - Gray when no tasks in queue\r\n */\r\nfunction updateStatusBar(): void {\r\n    if (!statusBarItem || !programmingOrchestrator) {\r\n        return;\r\n    }\r\n\r\n    const readyCount = programmingOrchestrator.getReadyTasksCount();\r\n    const inProgressCount = programmingOrchestrator.getInProgressTasksCount();\r\n    const totalCount = programmingOrchestrator.getAllTasks().length;\r\n\r\n    // Update text and icon based on queue state\r\n    if (inProgressCount > 0) {\r\n        statusBarItem.text = `$(sync~spin) COE: ${inProgressCount} active`;\r\n        statusBarItem.color = '#ffff00'; // Yellow\r\n        statusBarItem.tooltip = `${inProgressCount} tasks in progress, ${readyCount} ready`;\r\n    } else if (readyCount > 0) {\r\n        statusBarItem.text = `$(checklist) COE Tasks: ${readyCount} ready`;\r\n        statusBarItem.color = '#00ff00'; // Green\r\n        statusBarItem.tooltip = `${readyCount} tasks ready to process`;\r\n    } else if (totalCount > 0) {\r\n        statusBarItem.text = '$(check) COE: All tasks complete';\r\n        statusBarItem.color = '#888888'; // Gray\r\n        statusBarItem.tooltip = `${totalCount} total tasks (all done)`;\r\n    } else {\r\n        statusBarItem.text = '$(checklist) COE: No tasks';\r\n        statusBarItem.color = '#888888'; // Gray\r\n        statusBarItem.tooltip = 'No tasks in queue. Create a ticket to get started.';\r\n    }\r\n\r\n    statusBarItem.show();\r\n}\r\n\r\n// ============================================================================\r\n// Extension Lifecycle\r\n// ============================================================================\r\n\r\n/**\r\n * This function runs when the extension starts up.\r\n * Think of it as the \"power on\" button for COE.\r\n * \r\n * @param context - VS Code provides this to help manage the extension's lifecycle\r\n */\r\nexport async function activate(context: vscode.ExtensionContext) {\r\n\r\n    try {\r\n        let treeDataProvider: CoeTaskTreeProvider | null = null;\r\n        let completedTasksProvider: CompletedTasksTreeProvider | null = null;\r\n        let planWatcher: vscode.FileSystemWatcher | null = null;\r\n        let explorerTree: vscode.TreeView<any> | undefined = undefined;\r\n        let sidebarTree: vscode.TreeView<any> | undefined = undefined;\r\n\r\n        // ====================================================================\r\n        // 1. Create Output Channel for COE logging\r\n        // ====================================================================\r\n        orchestratorOutputChannel = vscode.window.createOutputChannel('COE Orchestrator');\r\n        context.subscriptions.push(orchestratorOutputChannel);\r\n\r\n        orchestratorOutputChannel.appendLine('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n        orchestratorOutputChannel.appendLine('≡ƒÜÇ Copilot Orchestration Extension (COE) Starting Up');\r\n        orchestratorOutputChannel.appendLine('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n        orchestratorOutputChannel.show(true);\r\n\r\n        // ====================================================================\r\n        // 2. Create Status Bar Item for real-time queue status\r\n        // ====================================================================\r\n        statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);\r\n        statusBarItem.text = '$(sync~spin) COE: Initializing...';\r\n        statusBarItem.tooltip = 'Click to process next task';\r\n        statusBarItem.command = 'coe.processNextTask';\r\n        statusBarItem.color = '#ffff00'; // Yellow during initialization\r\n        statusBarItem.show();\r\n        context.subscriptions.push(statusBarItem);\r\n\r\n        orchestratorOutputChannel.appendLine('≡ƒôè Status Bar Item created');\r\n\r\n        // ====================================================================\r\n        // 2.5 Initialize File Configuration Manager (.coe/config.json)\r\n        // ====================================================================\r\n        orchestratorOutputChannel.appendLine('ΓÜÖ∩╕Å  Initializing File Configuration Manager...');\r\n        try {\r\n            await FileConfigManager.initialize();\r\n            const configPath = FileConfigManager.getConfigPath();\r\n            orchestratorOutputChannel.appendLine(`Γ£à Config manager initialized (file: ${configPath})`);\r\n        } catch (configError) {\r\n            const errorMsg = configError instanceof Error ? configError.message : String(configError);\r\n            orchestratorOutputChannel.appendLine(`ΓÜá∩╕Å  Could not initialize config manager: ${errorMsg}`);\r\n        }\r\n\r\n        // ====================================================================\r\n        // 2.6 Validate and Load LLM configuration (VS Code settings > .coe/config.json > defaults)\r\n        // ====================================================================\r\n        try {\r\n            const llmConfig = await LLMConfigManager.getConfigOrDefault();\r\n            const configSources = LLMConfigManager.getConfigSources();\r\n            orchestratorOutputChannel.appendLine(`Γ£à LLM config validated and loaded (${configSources.source})`);\r\n            orchestratorOutputChannel.appendLine(\r\n                `Using LLM: ${llmConfig.model} @ ${llmConfig.url} (input limit ${llmConfig.inputTokenLimit} tokens, output max ${llmConfig.maxOutputTokens}, timeout ${llmConfig.timeoutSeconds}s)`\r\n            );\r\n        } catch (llmError) {\r\n            const errorMsg = llmError instanceof Error ? llmError.message : String(llmError);\r\n            orchestratorOutputChannel.appendLine(`ΓÜá∩╕Å  LLM config validation failed: ${errorMsg}`);\r\n            orchestratorOutputChannel.appendLine('   Using safe defaults (localhost:1234, mistral-7b)');\r\n        }\r\n\r\n        // Subscribe to config changes - re-validate when file changes\r\n        const configUnsubscribe = FileConfigManager.onConfigChange((config) => {\r\n            LLMConfigManager.getConfig()\r\n                .then((validConfig) => {\r\n                    orchestratorOutputChannel?.appendLine('≡ƒô¥ LLM config file changed and re-validated');\r\n                })\r\n                .catch((error) => {\r\n                    orchestratorOutputChannel?.appendLine(`ΓÜá∩╕Å  LLM config re-validation failed: ${error.message}`);\r\n                });\r\n        });\r\n        context.subscriptions.push({ dispose: configUnsubscribe });\r\n\r\n        orchestratorOutputChannel.appendLine('');\r\n\r\n        // ====================================================================\r\n        // 2.7 Initialize Ticket Database (.coe/tickets.db)\r\n        // ====================================================================\r\n        orchestratorOutputChannel.appendLine('≡ƒùä∩╕Å  Initializing Ticket Database...');\r\n        try {\r\n            const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\r\n            if (workspaceRoot) {\r\n                const ticketDb = TicketDatabase.getInstance();\r\n                await ticketDb.initialize(workspaceRoot);\r\n                const stats = await ticketDb.getStats();\r\n                orchestratorOutputChannel.appendLine(\r\n                    `Γ£à Ticket Database initialized (${stats.total} tickets, fallback: ${stats.usingFallback})`\r\n                );\r\n                // Add cleanup on deactivation\r\n                context.subscriptions.push({\r\n                    dispose: async () => {\r\n                        await ticketDb.close();\r\n                    }\r\n                });\r\n            } else {\r\n                orchestratorOutputChannel.appendLine('ΓÜá∩╕Å  No workspace folder found - ticket DB not initialized');\r\n            }\r\n        } catch (dbError) {\r\n            const errorMsg = dbError instanceof Error ? dbError.message : String(dbError);\r\n            orchestratorOutputChannel.appendLine(`ΓÜá∩╕Å  Ticket Database initialization failed: ${errorMsg}`);\r\n            orchestratorOutputChannel.appendLine('   Using in-memory fallback for tickets');\r\n        }\r\n\r\n        orchestratorOutputChannel.appendLine('');\r\n\r\n        // ====================================================================\r\n        // 3. Initialize Programming Orchestrator\r\n        // ====================================================================\r\n        try {\r\n            const logger = new SimpleLogger('COE.Extension');\r\n            programmingOrchestrator = new ProgrammingOrchestrator(undefined, logger);\r\n\r\n            orchestratorOutputChannel.appendLine('≡ƒô¥ Initializing Programming Orchestrator...');\r\n            await programmingOrchestrator.init();\r\n\r\n            // Initialize persistence to load previously saved tasks\r\n            orchestratorOutputChannel.appendLine('≡ƒÆ╛ Loading persisted tasks from workspace state...');\r\n            await programmingOrchestrator.initializeWithPersistence(context.workspaceState);\r\n\r\n            orchestratorOutputChannel.appendLine('Γ£à Programming Orchestrator initialized ΓÇô waiting for tasksΓÇª');\r\n            orchestratorOutputChannel.appendLine('');\r\n        } catch (orchestratorError) {\r\n            const errorMsg = orchestratorError instanceof Error ? orchestratorError.message : String(orchestratorError);\r\n            orchestratorOutputChannel.appendLine(`Γ¥î Programming Orchestrator initialization failed: ${errorMsg}`);\r\n            orchestratorOutputChannel.appendLine('   Extension will continue with limited functionality');\r\n            // Create minimal orchestrator for fallback\r\n            const logger = new SimpleLogger('COE.Extension');\r\n            programmingOrchestrator = new ProgrammingOrchestrator(undefined, logger);\r\n        }\r\n\r\n        // ====================================================================\r\n        // 3.2 Initialize Tasks Tree View\r\n        // ====================================================================\r\n        try {\r\n            treeDataProvider = new CoeTaskTreeProvider(programmingOrchestrator);\r\n            explorerTree = vscode.window.createTreeView('coe.tasksQueue', { treeDataProvider });\r\n            sidebarTree = vscode.window.createTreeView('coe-tasks', { treeDataProvider });\r\n            context.subscriptions.push(explorerTree, sidebarTree);\r\n\r\n            // Link TreeView provider to orchestrator for auto-refresh on queue changes\r\n            programmingOrchestrator.setTreeDataProvider(treeDataProvider);\r\n        } catch (treeError) {\r\n            const errorMsg = treeError instanceof Error ? treeError.message : String(treeError);\r\n            orchestratorOutputChannel.appendLine(`Γ¥î Tasks Tree View initialization failed: ${errorMsg}`);\r\n            orchestratorOutputChannel.appendLine('   Task queue will work but UI may not update');\r\n        }\r\n\r\n        // ====================================================================\r\n        // 3.2.5 Initialize Completed Tasks History Tree View\r\n        // ====================================================================\r\n        try {\r\n            const ticketDb = TicketDatabase.getInstance();\r\n            completedTasksProvider = new CompletedTasksTreeProvider(ticketDb);\r\n            const completedTree = vscode.window.createTreeView('coe.completedTasks', {\r\n                treeDataProvider: completedTasksProvider\r\n            });\r\n            context.subscriptions.push(completedTree);\r\n\r\n            // Link CompletedTasksTreeProvider to orchestrator\r\n            programmingOrchestrator.setCompletedTasksProvider(completedTasksProvider);\r\n\r\n            // Read retention config from VS Code settings\r\n            const config = vscode.workspace.getConfiguration('coe.history');\r\n            const retentionConfig = config?.get('retention', { maxAgeHours: 168, maxCount: 0 }) || { maxAgeHours: 168, maxCount: 0 };\r\n            if (typeof retentionConfig === 'object' && 'maxAgeHours' in retentionConfig) {\r\n                const maxAgeHours = (retentionConfig as any).maxAgeHours || 168;\r\n                completedTasksProvider.updateRetention(maxAgeHours);\r\n                orchestratorOutputChannel.appendLine(`Γ£à Completed Tasks view retention: ${maxAgeHours}h`);\r\n            }\r\n\r\n            orchestratorOutputChannel.appendLine('Γ£à Completed Tasks Tree View initialized');\r\n            orchestratorOutputChannel.appendLine('');\r\n        } catch (completedTasksError) {\r\n            const errorMsg = completedTasksError instanceof Error ? completedTasksError.message : String(completedTasksError);\r\n            orchestratorOutputChannel.appendLine(`Γ¥î Completed Tasks Tree View initialization failed: ${errorMsg}`);\r\n            orchestratorOutputChannel.appendLine('   History tracking will be unavailable');\r\n        }\r\n\r\n        // ====================================================================\r\n        // 3.2.6 Initialize Quality Gate Diagnostic Providers\r\n        // ====================================================================\r\n        orchestratorOutputChannel.appendLine('≡ƒö¼ Initializing Quality Gate Diagnostic Providers...');\r\n\r\n        try {\r\n            // Coverage diagnostic provider (monitors coverage files)\r\n            const coverageProvider = new CoverageDiagnosticProvider();\r\n            coverageProvider.activate(context);\r\n            orchestratorOutputChannel.appendLine('Γ£à Coverage Diagnostic Provider activated');\r\n        } catch (coverageError) {\r\n            const errorMsg = coverageError instanceof Error ? coverageError.message : String(coverageError);\r\n            orchestratorOutputChannel.appendLine(`Γ¥î Coverage Diagnostic Provider failed: ${errorMsg}`);\r\n        }\r\n\r\n        try {\r\n            // Skipped tests diagnostic provider (monitors test files)\r\n            const skippedTestsProvider = new SkippedTestsDiagnosticProvider();\r\n            skippedTestsProvider.activate(context);\r\n            orchestratorOutputChannel.appendLine('Γ£à Skipped Tests Diagnostic Provider activated');\r\n        } catch (skippedTestsError) {\r\n            const errorMsg = skippedTestsError instanceof Error ? skippedTestsError.message : String(skippedTestsError);\r\n            orchestratorOutputChannel.appendLine(`Γ¥î Skipped Tests Diagnostic Provider failed: ${errorMsg}`);\r\n        }\r\n\r\n        orchestratorOutputChannel.appendLine('≡ƒÆí Quality warnings will appear in Problems panel');\r\n        orchestratorOutputChannel.appendLine('');\r\n\r\n        // ====================================================================\r\n        // 3.3 Load tasks from plan file\r\n        // ====================================================================\r\n        try {\r\n            orchestratorOutputChannel.appendLine('≡ƒôé Loading tasks from plan file...');\r\n            const planTasks = await loadTasksFromPlanFile();\r\n            if (planTasks.length > 0) {\r\n                planTasks.forEach((task) => programmingOrchestrator?.addTask(task));\r\n                orchestratorOutputChannel.appendLine(`Γ£à Loaded and added ${planTasks.length} tasks from plan file`);\r\n            } else {\r\n                orchestratorOutputChannel.appendLine('Γä╣∩╕Å  No tasks loaded from plan file ΓÇô using test mode only');\r\n            }\r\n            orchestratorOutputChannel.appendLine('');\r\n        } catch (planLoadError) {\r\n            const errorMsg = planLoadError instanceof Error ? planLoadError.message : String(planLoadError);\r\n            orchestratorOutputChannel.appendLine(`Γ¥î Failed to load tasks from plan file: ${errorMsg}`);\r\n            orchestratorOutputChannel.appendLine('   Continuing with empty task queue');\r\n        }\r\n\r\n        updateStatusBar();\r\n        if (treeDataProvider) {\r\n            treeDataProvider.refresh();\r\n        }\r\n\r\n        // ====================================================================\r\n        // 3.3.5 Debug Summary: Tree View Status\r\n        // ====================================================================\r\n        if (programmingOrchestrator) {\r\n            const readyTasks = programmingOrchestrator.getReadyTasks();\r\n            if (readyTasks.length > 0) {\r\n                readyTasks.forEach(t => {\r\n                    // eslint-disable-next-line no-empty\r\n                });\r\n            } else {\r\n                // eslint-disable-next-line no-empty\r\n            }\r\n        }\r\n\r\n        // ====================================================================\r\n        // 3.4 Watch plan file for changes and refresh queue/tree\r\n        // ====================================================================\r\n        try {\r\n            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\r\n            if (workspaceFolder) {\r\n                planWatcher = vscode.workspace.createFileSystemWatcher('**/Docs/Plans/current-plan.md');\r\n                const reloadTasks = async () => {\r\n                    try {\r\n                        orchestratorOutputChannel?.appendLine('≡ƒöä Plan file changed ΓÇö reloading tasks...');\r\n                        const tasks = await loadTasksFromPlanFile();\r\n                        programmingOrchestrator?.setTasks(tasks);\r\n                        treeDataProvider?.refresh();\r\n                        updateStatusBar();\r\n                    } catch (reloadError) {\r\n                        const errorMsg = reloadError instanceof Error ? reloadError.message : String(reloadError);\r\n                        orchestratorOutputChannel?.appendLine(`Γ¥î Failed to reload tasks: ${errorMsg}`);\r\n                    }\r\n                };\r\n                planWatcher.onDidChange(reloadTasks, null, context.subscriptions);\r\n                planWatcher.onDidCreate(reloadTasks, null, context.subscriptions);\r\n                planWatcher.onDidDelete(reloadTasks, null, context.subscriptions);\r\n                context.subscriptions.push(planWatcher);\r\n\r\n                const planSaveListener = vscode.workspace.onDidSaveTextDocument((doc) => {\r\n                    const normalizedPath = doc.uri.fsPath.replace(/\\\\/g, '/');\r\n                    if (normalizedPath.endsWith('Docs/Plans/current-plan.md')) {\r\n                        reloadTasks();\r\n                    }\r\n                });\r\n                context.subscriptions.push(planSaveListener);\r\n            }\r\n        } catch (watcherError) {\r\n            const errorMsg = watcherError instanceof Error ? watcherError.message : String(watcherError);\r\n            orchestratorOutputChannel.appendLine(`Γ¥î Plan file watcher setup failed: ${errorMsg}`);\r\n            orchestratorOutputChannel.appendLine('   Plan files won\\'t auto-reload on changes');\r\n        }\r\n\r\n        // ====================================================================\r\n        // 5. Register existing commands\r\n        // ====================================================================\r\n        const activateCommand = vscode.commands.registerCommand('coe.activate', () => {\r\n            vscode.window.showInformationMessage('COE: Orchestration system ready!');\r\n        });\r\n        context.subscriptions.push(activateCommand);\r\n\r\n        // ====================================================================\r\n        // 5.1 Register GitHub token management command\r\n        // ====================================================================\r\n        const setGitHubTokenCommand = vscode.commands.registerCommand('coe.setGitHubToken', async () => {\r\n            const token = await vscode.window.showInputBox({\r\n                prompt: 'Enter your GitHub Personal Access Token',\r\n                password: true,\r\n                placeHolder: 'ghp_xxxxxxxxxxxxxxxxxxxx',\r\n                ignoreFocusOut: true,\r\n                validateInput: (value) => {\r\n                    if (!value || value.trim().length === 0) {\r\n                        return 'Token cannot be empty';\r\n                    }\r\n                    if (!value.startsWith('ghp_') && !value.startsWith('github_pat_')) {\r\n                        return 'Invalid token format. Should start with ghp_ or github_pat_';\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n\r\n            if (token) {\r\n                await ConfigManager.setGitHubToken(context, token);\r\n                vscode.window.showInformationMessage('Γ£à GitHub token saved securely');\r\n                orchestratorOutputChannel?.appendLine('Γ£à GitHub token updated via SecretStorage');\r\n            }\r\n        });\r\n        context.subscriptions.push(setGitHubTokenCommand);\r\n\r\n        // Check for GitHub token on activation\r\n        orchestratorOutputChannel.appendLine('≡ƒöæ Checking GitHub token...');\r\n        const existingToken = await ConfigManager.getGitHubToken(context);\r\n        if (!existingToken) {\r\n            orchestratorOutputChannel.appendLine('ΓÜá∩╕Å  No GitHub token found');\r\n            const response = await vscode.window.showWarningMessage(\r\n                'GitHub token not configured. Required for GitHub Issues sync.',\r\n                'Set Token Now',\r\n                'Later'\r\n            );\r\n            if (response === 'Set Token Now') {\r\n                await vscode.commands.executeCommand('coe.setGitHubToken');\r\n            }\r\n        } else {\r\n            orchestratorOutputChannel.appendLine('Γ£à GitHub token found in SecretStorage');\r\n        }\r\n\r\n        const executeTask = async (nextTask: Task): Promise<void> => {\r\n            orchestratorOutputChannel?.appendLine('');\r\n            orchestratorOutputChannel?.appendLine(`≡ƒÜÇ Processing task ${nextTask.taskId}...`);\r\n\r\n            orchestratorOutputChannel?.appendLine(`≡ƒôï Task: ${nextTask.title}`);\r\n            orchestratorOutputChannel?.appendLine(`≡ƒÄ» Priority: ${nextTask.priority}`);\r\n\r\n            const shortTitle = nextTask.title.length > 20\r\n                ? nextTask.title.substring(0, 20) + '...'\r\n                : nextTask.title;\r\n            currentProcessingTask = {\r\n                taskId: nextTask.taskId,\r\n                title: shortTitle,\r\n                priority: nextTask.priority,\r\n            };\r\n            updateStatusBar();\r\n\r\n            orchestratorOutputChannel?.appendLine('≡ƒöä Generating routing directive...');\r\n            const directive = await programmingOrchestrator!.routeTask(nextTask);\r\n\r\n            orchestratorOutputChannel?.appendLine('');\r\n            orchestratorOutputChannel?.appendLine('≡ƒô¥ Generated Prompt for Copilot:');\r\n            orchestratorOutputChannel?.appendLine('ΓöÇ'.repeat(60));\r\n            orchestratorOutputChannel?.appendLine(JSON.stringify(directive, null, 2));\r\n            orchestratorOutputChannel?.appendLine('ΓöÇ'.repeat(60));\r\n            orchestratorOutputChannel?.appendLine('');\r\n\r\n            const fullPromptFromRouteTask = directive.contextBundle ?? JSON.stringify(directive, null, 2);\r\n            const estimatedInputTokens = Math.ceil(fullPromptFromRouteTask.length / 4);\r\n            const config = getLLMConfig();\r\n            orchestratorOutputChannel?.appendLine(\r\n                `≡ƒôè Estimated input tokens: ${estimatedInputTokens} / ${config.inputTokenLimit}`\r\n            );\r\n\r\n            let finalPrompt = fullPromptFromRouteTask;\r\n            if (estimatedInputTokens > config.inputTokenLimit) {\r\n                const maxChars = config.inputTokenLimit * 4;\r\n                finalPrompt = fullPromptFromRouteTask.slice(-maxChars);\r\n                orchestratorOutputChannel?.appendLine(\r\n                    `ΓÜá∩╕Å Prompt truncated from ${estimatedInputTokens} to ${config.inputTokenLimit} tokens`\r\n                );\r\n                vscode.window.showWarningMessage(\r\n                    `ΓÜá∩╕Å Prompt truncated from ${estimatedInputTokens} to ${config.inputTokenLimit} tokens`\r\n                );\r\n            }\r\n\r\n            const completeTaskAndNotify = async (completionMessage: string) => {\r\n                await programmingOrchestrator?.onTaskComplete(\r\n                    nextTask.taskId,\r\n                    completionMessage,\r\n                );\r\n                orchestratorOutputChannel?.appendLine('Γ£à Task marked complete');\r\n                currentProcessingTask = null;\r\n\r\n                const finalStatus = programmingOrchestrator?.getQueueStatus();\r\n                const remainingCount = finalStatus?.byStatus.ready || 0;\r\n\r\n                updateStatusBar();\r\n                treeDataProvider?.refresh();\r\n\r\n                if (remainingCount > 0) {\r\n                    vscode.window.showInformationMessage(\r\n                        `AI responded ΓÇö task complete! ${remainingCount} tasks left.`\r\n                    );\r\n                } else {\r\n                    vscode.window.showInformationMessage(\r\n                        'AI responded ΓÇö task complete!'\r\n                    );\r\n                }\r\n            };\r\n\r\n            const llm = getLLMConfig();\r\n            orchestratorOutputChannel?.appendLine(\r\n                `≡ƒîè Streaming from ${llm.model} (inactivity timeout: ${llm.timeoutSeconds}s)...`\r\n            );\r\n\r\n            try {\r\n                if (statusBarItem) {\r\n                    statusBarItem.text = `$(sync~spin) Receiving from ${llm.model}...`;\r\n                    statusBarItem.color = '#ffff00';\r\n                    statusBarItem.show();\r\n                }\r\n\r\n                const start = Date.now();\r\n\r\n                const result = await callLLMWithStreaming({\r\n                    config: llm,\r\n                    systemPrompt: 'You are a senior TypeScript developer helping build a VS Code extension.',\r\n                    userPrompt: finalPrompt,\r\n                    temperature: 0.7,\r\n                    maxTokens: llm.maxOutputTokens,\r\n                    onToken: () => {\r\n                        // Callback exists for future use with advanced logging\r\n                    },\r\n                    onError: (error) => {\r\n                        orchestratorOutputChannel?.appendLine(`ΓÜá∩╕Å  Streaming error: ${error}`);\r\n                    },\r\n                    onComplete: () => {\r\n                        orchestratorOutputChannel?.appendLine('Γ£à Streaming ended');\r\n                    },\r\n                });\r\n\r\n                const elapsedMs = Date.now() - start;\r\n\r\n                if (!result.success) {\r\n                    const errorMsg = result.error || 'Unknown streaming error';\r\n                    orchestratorOutputChannel?.appendLine(`Γ¥î LLM call failed: ${errorMsg}`);\r\n                    throw new Error(errorMsg);\r\n                }\r\n\r\n                const fullReply = result.content || 'Model returned no text content';\r\n\r\n                // Validate we received content\r\n                const trimmedReply = fullReply.trim();\r\n                if (!trimmedReply) {\r\n                    throw new Error('No content received from model');\r\n                }\r\n\r\n                orchestratorOutputChannel?.appendLine(`Γ£à Received response in ${elapsedMs}ms (method: ${result.method})`);\r\n                orchestratorOutputChannel?.appendLine('ΓöÇ'.repeat(60));\r\n                orchestratorOutputChannel?.appendLine('≡ƒºá Model Reply:');\r\n                orchestratorOutputChannel?.appendLine('ΓöÇ'.repeat(60));\r\n                orchestratorOutputChannel?.appendLine(fullReply);\r\n                orchestratorOutputChannel?.appendLine('ΓöÇ'.repeat(60));\r\n\r\n                await completeTaskAndNotify(`Task completed via ${getLLMConfig().model}`);\r\n            } catch (error) {\r\n                const message = error instanceof Error ? error.message : String(error);\r\n                orchestratorOutputChannel?.appendLine(`Γ¥î Error while calling model: ${message}`);\r\n                vscode.window.showErrorMessage(`LLM not responding ΓÇö ${message}`);\r\n                // Return task to ready state so it can be retried\r\n                nextTask.status = TaskStatus.READY;\r\n                if (programmingOrchestrator) {\r\n                    (programmingOrchestrator as unknown as { currentTask: Task | null }).currentTask = null;\r\n                }\r\n                currentProcessingTask = null;\r\n                updateStatusBar();\r\n                treeDataProvider?.refresh();\r\n                return;\r\n            }\r\n        };\r\n\r\n        // ====================================================================\r\n        // 6. Register processNextTask command for real task execution\r\n        // ====================================================================\r\n        const processNextCommand = vscode.commands.registerCommand('coe.processNextTask', async () => {\r\n            if (!programmingOrchestrator || !orchestratorOutputChannel) {\r\n                vscode.window.showErrorMessage('Γ¥î COE Orchestrator not initialized');\r\n                return;\r\n            }\r\n\r\n            // Check if orchestrator is busy\r\n            if (programmingOrchestrator.isBusy()) {\r\n                vscode.window.showInformationMessage('ΓÅ│ Busy processing current task ΓÇö try again in a few seconds');\r\n                return;\r\n            }\r\n\r\n            const nextTask = programmingOrchestrator.getNextTask();\r\n            if (!nextTask) {\r\n                vscode.window.showInformationMessage('Γ£à All tasks complete! Edit Docs/Plans/current-plan.md to add more.');\r\n                orchestratorOutputChannel.appendLine('Γä╣∩╕Å  No more ready tasks in queue');\r\n                return;\r\n            }\r\n\r\n            await executeTask(nextTask);\r\n        });\r\n        context.subscriptions.push(processNextCommand);\r\n\r\n        // ====================================================================\r\n        // 6.1 Register processTask command for specific task execution\r\n        // ====================================================================\r\n        const processTaskCommand = vscode.commands.registerCommand('coe.processTask', async (taskId: string) => {\r\n\r\n            if (!programmingOrchestrator || !orchestratorOutputChannel) {\r\n                vscode.window.showErrorMessage('Γ¥î COE Orchestrator not initialized');\r\n                return;\r\n            }\r\n\r\n            if (programmingOrchestrator.isBusy()) {\r\n                vscode.window.showInformationMessage('ΓÅ│ Busy processing current task ΓÇö try again in a few seconds');\r\n                return;\r\n            }\r\n\r\n            const target = programmingOrchestrator.getTaskById(taskId);\r\n            if (!target) {\r\n                vscode.window.showWarningMessage(`Task not found: ${taskId}`);\r\n                return;\r\n            }\r\n\r\n\r\n            if (target.status !== TaskStatus.READY) {\r\n                vscode.window.showWarningMessage(`Task ${taskId} is not ready (status: ${target.status})`);\r\n                return;\r\n            }\r\n\r\n            await executeTask(target);\r\n        });\r\n        context.subscriptions.push(processTaskCommand);\r\n\r\n        // ====================================================================\r\n        // 7. Register PRD Generation Command\r\n        // ====================================================================\r\n        const regeneratePRDCommand = vscode.commands.registerCommand('coe.regeneratePRD', async () => {\r\n            orchestratorOutputChannel?.appendLine('');\r\n            orchestratorOutputChannel?.appendLine('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n            orchestratorOutputChannel?.appendLine('≡ƒÜÇ PRD Generation Started');\r\n            orchestratorOutputChannel?.appendLine('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n\r\n            try {\r\n                // Show progress notification\r\n                await vscode.window.withProgress(\r\n                    {\r\n                        location: vscode.ProgressLocation.Notification,\r\n                        title: 'Generating PRD from Plans/',\r\n                        cancellable: false,\r\n                    },\r\n                    async (progress) => {\r\n                        progress.report({ message: 'Reading Plans/ folder...' });\r\n\r\n                        const llmCfg = getLLMConfig();\r\n                        const llmConfigCopy = {\r\n                            url: llmCfg.url,\r\n                            model: llmCfg.model,\r\n                            maxOutputTokens: llmCfg.maxOutputTokens,\r\n                            timeoutSeconds: llmCfg.timeoutSeconds,\r\n                        };\r\n\r\n                        const result = await PRDGenerator.generate(\r\n                            {\r\n                                tokenLimit: llmCfg.inputTokenLimit,\r\n                                retryOnFailure: true,\r\n                                showPreview: false,\r\n                                llmConfig: llmConfigCopy,\r\n                            },\r\n                            (status) => {\r\n                                orchestratorOutputChannel?.appendLine(status);\r\n                                progress.report({ message: status });\r\n                            },\r\n                            orchestratorOutputChannel || undefined\r\n                        );\r\n\r\n                        if (result.success) {\r\n                            orchestratorOutputChannel?.appendLine('');\r\n                            orchestratorOutputChannel?.appendLine(result.message);\r\n                            if (result.mdPath) {\r\n                                orchestratorOutputChannel?.appendLine(`≡ƒôä PRD.md: ${result.mdPath}`);\r\n                            }\r\n                            if (result.jsonPath) {\r\n                                orchestratorOutputChannel?.appendLine(`≡ƒôä PRD.json: ${result.jsonPath}`);\r\n                            }\r\n                            if (result.warning) {\r\n                                orchestratorOutputChannel?.appendLine(`ΓÜá∩╕Å  ${result.warning}`);\r\n                            }\r\n                            if (result.duration) {\r\n                                orchestratorOutputChannel?.appendLine(\r\n                                    `ΓÅ▒∩╕Å  Duration: ${(result.duration / 1000).toFixed(2)}s`\r\n                                );\r\n                            }\r\n\r\n                            // Show popup with Open button\r\n                            const openButton = 'Open PRD.md';\r\n                            vscode.window.showInformationMessage(\r\n                                'Γ£à PRD generated successfully!',\r\n                                openButton\r\n                            ).then(selection => {\r\n                                if (selection === openButton && result.mdUri) {\r\n                                    vscode.commands.executeCommand('vscode.open', result.mdUri);\r\n                                }\r\n                            });\r\n                        } else {\r\n                            orchestratorOutputChannel?.appendLine(result.message);\r\n                            vscode.window.showErrorMessage(result.message);\r\n                        }\r\n\r\n                        orchestratorOutputChannel?.appendLine('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n                        orchestratorOutputChannel?.appendLine('');\r\n                    }\r\n                );\r\n            } catch (error) {\r\n                const errMsg = error instanceof Error ? error.message : String(error);\r\n                orchestratorOutputChannel?.appendLine(`Γ¥î Error: ${errMsg}`);\r\n                vscode.window.showErrorMessage(`Γ¥î PRD Generation failed: ${errMsg}`);\r\n            }\r\n        });\r\n        context.subscriptions.push(regeneratePRDCommand);\r\n\r\n        // ====================================================================\r\n        // 7.5 Start PRD Auto-Regeneration Watcher\r\n        // ====================================================================\r\n        try {\r\n            orchestratorOutputChannel.appendLine('≡ƒöº Setting up Plans/ folder watcher...');\r\n            PlansFileWatcher.startWatching(context, true, orchestratorOutputChannel);\r\n        } catch (prdWatcherError) {\r\n            const errorMsg = prdWatcherError instanceof Error ? prdWatcherError.message : String(prdWatcherError);\r\n            orchestratorOutputChannel.appendLine(`Γ¥î Plans/ folder watcher setup failed: ${errorMsg}`);\r\n            orchestratorOutputChannel.appendLine('   PRD auto-regeneration will be unavailable');\r\n        }\r\n\r\n        // ====================================================================\r\n        // 8. Register test command for quick verification (backward compat)\r\n        // ====================================================================\r\n        const testCommand = vscode.commands.registerCommand('coe.testOrchestrator', async () => {\r\n            if (!programmingOrchestrator || !orchestratorOutputChannel) {\r\n                vscode.window.showErrorMessage('Γ¥î COE Orchestrator not initialized');\r\n                return;\r\n            }\r\n\r\n            // Check if real tasks are loaded - if so, disable test command completely\r\n            const queueStatus = programmingOrchestrator.getQueueStatus();\r\n            if (queueStatus.totalTasks > 0) {\r\n                vscode.window.showInformationMessage(\r\n                    'Real tasks loaded ΓÇö click status bar to process plan tasks!'\r\n                );\r\n                orchestratorOutputChannel.appendLine('Γä╣∩╕Å  Test command disabled ΓÇö real plan tasks are loaded');\r\n                return;\r\n            }\r\n\r\n            try {\r\n                orchestratorOutputChannel.appendLine('');\r\n                orchestratorOutputChannel.appendLine('≡ƒº¬ TEST: Creating and retrieving fake task...');\r\n\r\n                // Create a fake P1 task for testing with unique timestamp ID\r\n                const timestamp = Date.now();\r\n                const fakeTask = {\r\n                    taskId: `test-task-${timestamp}`,\r\n                    title: 'Test Task - Verify Orchestrator',\r\n                    description: 'This is a temporary test task to verify the orchestrator is working',\r\n                    priority: TaskPriority.P1,\r\n                    status: TaskStatus.READY,\r\n                    dependencies: [],\r\n                    blockedBy: [],\r\n                    estimatedHours: 1,\r\n                    acceptanceCriteria: [\r\n                        'Test task was successfully added to queue',\r\n                        'Test task was successfully retrieved as next task',\r\n                        'Test task was successfully marked as completed',\r\n                    ],\r\n                    fromPlanningTeam: true,\r\n                    createdAt: new Date(),\r\n                };\r\n\r\n                // Add task to queue\r\n                programmingOrchestrator.addTask(fakeTask);\r\n                orchestratorOutputChannel.appendLine(`Γ£à Fake task added to queue: ${fakeTask.taskId}`);\r\n\r\n                // Update status bar after adding task\r\n                updateStatusBar();\r\n\r\n                // Get next task\r\n                const nextTask = programmingOrchestrator.getNextTask();\r\n                if (nextTask && nextTask.taskId === fakeTask.taskId) {\r\n                    orchestratorOutputChannel.appendLine(`Γ£à Fake task retrieved successfully: \"${nextTask.title}\"`);\r\n\r\n                    const stats = programmingOrchestrator.getQueueStatus();\r\n                    orchestratorOutputChannel.appendLine(`≡ƒôè Queue Status: ${stats.totalTasks} total, ${stats.byStatus.ready} ready`);\r\n\r\n                    // ≡ƒöä CRITICAL: Mark task as IN_PROGRESS before completing it\r\n                    // This is necessary because onTaskComplete() requires task status to be IN_PROGRESS\r\n                    // In real execution, routeTask() would set this, but in tests we set it manually\r\n                    orchestratorOutputChannel.appendLine('≡ƒöä Simulating task completion for test...');\r\n                    nextTask.status = TaskStatus.IN_PROGRESS;\r\n\r\n                    // Now complete the task to clear active task state (for repeated test runs)\r\n                    try {\r\n                        await programmingOrchestrator.onTaskComplete(\r\n                            fakeTask.taskId,\r\n                            'Test task completed successfully'\r\n                        );\r\n                        orchestratorOutputChannel.appendLine('Γ£à Task marked complete ΓÇô ready for next test run');\r\n                    } catch (completeError) {\r\n                        const errorMsg = completeError instanceof Error ? completeError.message : String(completeError);\r\n                        orchestratorOutputChannel.appendLine(`Γ¥î Failed to mark task complete: ${errorMsg}`);\r\n                        vscode.window.showErrorMessage(`Γ¥î COE: Failed to complete test task: ${errorMsg}`);\r\n                        return;\r\n                    }\r\n\r\n                    // Update status bar after completion\r\n                    updateStatusBar();\r\n\r\n                    vscode.window.showInformationMessage('Γ£à COE: Orchestrator test passed!');\r\n                } else {\r\n                    orchestratorOutputChannel.appendLine('Γ¥î Failed to retrieve fake task');\r\n                    vscode.window.showErrorMessage('Γ¥î COE: Orchestrator test failed');\r\n                }\r\n            } catch (error) {\r\n                const errorMsg = error instanceof Error ? error.message : String(error);\r\n                orchestratorOutputChannel.appendLine(`Γ¥î Test error: ${errorMsg}`);\r\n                vscode.window.showErrorMessage(`Γ¥î COE: Orchestrator test error: ${errorMsg}`);\r\n            }\r\n        });\r\n        context.subscriptions.push(testCommand);\r\n\r\n        // ====================================================================\r\n        // 6. Register Test Ticket Command\r\n        // ====================================================================\r\n        const testCreateTicketCommand = vscode.commands.registerCommand(\r\n            'coe.testCreateTicket',\r\n            async () => {\r\n                try {\r\n                    if (!orchestratorOutputChannel) {\r\n                        vscode.window.showErrorMessage('Γ¥î COE: Output channel not initialized');\r\n                        return;\r\n                    }\r\n\r\n                    const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\r\n                    if (!workspaceRoot) {\r\n                        vscode.window.showErrorMessage('Γ¥î COE: No workspace folder open');\r\n                        return;\r\n                    }\r\n\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine('≡ƒöù Testing Ticket ΓåÆ Task Queue Integration (P1 Task 2)');\r\n                    orchestratorOutputChannel.appendLine('ΓòÉ'.repeat(70));\r\n\r\n                    // Get orchestrator to check queue status\r\n                    const orchestrator = getOrchestrator();\r\n                    if (!orchestrator) {\r\n                        vscode.window.showErrorMessage('Γ¥î COE: Orchestrator not initialized');\r\n                        return;\r\n                    }\r\n\r\n                    // Log initial queue status\r\n                    const beforeCount = orchestrator.getReadyTasksCount();\r\n                    const beforeStats = orchestrator.getQueueStatus();\r\n                    orchestratorOutputChannel.appendLine(`≡ƒôè Queue Status Before:`);\r\n                    orchestratorOutputChannel.appendLine(`   Ready Tasks: ${beforeCount}`);\r\n                    orchestratorOutputChannel.appendLine(`   Total Tasks: ${beforeStats.totalTasks}`);\r\n                    orchestratorOutputChannel.appendLine(`   By Priority: P1=${beforeStats.byPriority.P1}, P2=${beforeStats.byPriority.P2}, P3=${beforeStats.byPriority.P3}`);\r\n\r\n                    // Create or reuse global TicketDb instance\r\n                    if (!globalTicketDb) {\r\n                        const TicketDb = (await import('./services/ticketDb')).default;\r\n                        globalTicketDb = new TicketDb(path.join(workspaceRoot, '.coe'));\r\n                        await globalTicketDb.init();\r\n                        orchestratorOutputChannel.appendLine('Γ£à TicketDb initialized (new instance)');\r\n                    } else {\r\n                        orchestratorOutputChannel.appendLine('Γ£à TicketDb already initialized (reusing instance)');\r\n                    }\r\n\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine('≡ƒÄ½ Creating test ticket...');\r\n\r\n                    // Create test ticket - should automatically route and enqueue\r\n                    const ticket = await globalTicketDb.createTicket({\r\n                        type: 'human_to_ai',\r\n                        title: 'How do I implement error handling?',\r\n                        description: 'Need guidance on TypeScript error handling patterns for the project',\r\n                        priority: 2\r\n                    });\r\n\r\n                    orchestratorOutputChannel.appendLine(`Γ£à Ticket created: ${ticket.id}`);\r\n                    orchestratorOutputChannel.appendLine(`   Title: ${ticket.title}`);\r\n                    orchestratorOutputChannel.appendLine(`   Type: ${ticket.type}`);\r\n                    orchestratorOutputChannel.appendLine(`   Priority: P${ticket.priority}`);\r\n                    orchestratorOutputChannel.appendLine(`   Status: ${ticket.status}`);\r\n\r\n                    // Wait for async routing and TreeView refresh to complete\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine('ΓÅ│ Waiting for routing, persistence, and TreeView refresh...');\r\n                    await new Promise(resolve => setTimeout(resolve, 500));\r\n\r\n                    // Check queue status after routing\r\n                    const afterCount = orchestrator.getReadyTasksCount();\r\n                    const afterStats = orchestrator.getQueueStatus();\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine(`≡ƒôè Queue Status After:`);\r\n                    orchestratorOutputChannel.appendLine(`   Ready Tasks: ${afterCount}`);\r\n                    orchestratorOutputChannel.appendLine(`   Total Tasks: ${afterStats.totalTasks}`);\r\n\r\n                    // Verify task was added\r\n                    if (afterCount > beforeCount) {\r\n                        orchestratorOutputChannel.appendLine('');\r\n                        orchestratorOutputChannel.appendLine('Γ£à SUCCESS: Task added to queue!');\r\n                        orchestratorOutputChannel.appendLine(`   Tasks increased from ${beforeCount} to ${afterCount}`);\r\n\r\n                        // Find the newly added task\r\n                        const readyTasks = orchestrator.getReadyTasks();\r\n                        const newTask = readyTasks.find((t: Task) => (t as any)?.metadata?.ticketId === ticket.id);\r\n\r\n                        if (newTask) {\r\n                            orchestratorOutputChannel.appendLine('');\r\n                            orchestratorOutputChannel.appendLine('≡ƒôï Added Task Details:');\r\n                            orchestratorOutputChannel.appendLine(`   Task ID: ${newTask.taskId}`);\r\n                            orchestratorOutputChannel.appendLine(`   Title: ${newTask.title}`);\r\n                            orchestratorOutputChannel.appendLine(`   Priority: ${newTask.priority}`);\r\n                            orchestratorOutputChannel.appendLine(`   Status: ${newTask.status}`);\r\n                            orchestratorOutputChannel.appendLine(`   Routed To: ${(newTask as any)?.metadata?.routedTeam || 'unknown'}`);\r\n                            orchestratorOutputChannel.appendLine(`   Metadata.ticketId: ${(newTask as any)?.metadata?.ticketId}`);\r\n\r\n                            orchestratorOutputChannel.appendLine('');\r\n                            orchestratorOutputChannel.appendLine('≡ƒæÇ CHECK SIDEBAR & STATUS BAR:');\r\n                            orchestratorOutputChannel.appendLine('   ΓåÆ Sidebar: \"COE Tasks Queue\" should show 1 task');\r\n                            orchestratorOutputChannel.appendLine(`   ΓåÆ Status Bar: Should show \"COE Tasks: ${afterCount} ready\"`);\r\n                            orchestratorOutputChannel.appendLine('   ΓåÆ Task persisted to workspace storage Γ£à');\r\n                            orchestratorOutputChannel.appendLine('');\r\n                            orchestratorOutputChannel.appendLine('≡ƒöä TRY RELOADING (Ctrl+R):');\r\n                            orchestratorOutputChannel.appendLine('   ΓåÆ Task should still be in queue after reload');\r\n                            orchestratorOutputChannel.appendLine('   ΓåÆ Run test again ΓåÆ should skip duplicate (check logs for skip message)');\r\n                            orchestratorOutputChannel.appendLine('');\r\n                            orchestratorOutputChannel.appendLine('≡ƒÆí DUPLICATE DETECTION:');\r\n                            orchestratorOutputChannel.appendLine('   ΓåÆ If you run this command again, the duplicate will be skipped');\r\n                            orchestratorOutputChannel.appendLine('   ΓåÆ Check logs for \"Task already exists for ticket...\" message');\r\n\r\n                            vscode.window.showInformationMessage(\r\n                                `Γ£à Ticket ${ticket.id} created! Check sidebar & status bar (${afterCount} ready).`,\r\n                                'Open Sidebar',\r\n                                'Reload & Test'\r\n                            ).then(selection => {\r\n                                if (selection === 'Open Sidebar') {\r\n                                    vscode.commands.executeCommand('workbench.view.extension.coe-explorer');\r\n                                } else if (selection === 'Reload & Test') {\r\n                                    vscode.commands.executeCommand('workbench.action.reloadWindow');\r\n                                }\r\n                            });\r\n                        } else {\r\n                            orchestratorOutputChannel.appendLine('ΓÜá∩╕Å Task found in queue but metadata not matching');\r\n                        }\r\n                    } else {\r\n                        orchestratorOutputChannel.appendLine('');\r\n                        orchestratorOutputChannel.appendLine('ΓÜá∩╕Å Task not added to queue');\r\n\r\n                        // Check if it's a duplicate\r\n                        if (await orchestrator.hasTaskForTicket(ticket.id)) {\r\n                            orchestratorOutputChannel.appendLine('   Reason: Duplicate ticket detected');\r\n                            orchestratorOutputChannel.appendLine('   ΓåÆ Task for this ticket already exists in queue');\r\n                            orchestratorOutputChannel.appendLine('   ΓåÆ This is expected behavior (duplicate prevention working!)');\r\n                            vscode.window.showInformationMessage(`Duplicate skipped: Task already exists for ticket ${ticket.id}`);\r\n                        } else {\r\n                            orchestratorOutputChannel.appendLine('  - Routing/enqueue failed (check logs)');\r\n                            vscode.window.showWarningMessage(`Task not added to queue`);\r\n                        }\r\n                    }\r\n\r\n                    // Verify persistence by retrieving ticket\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine('≡ƒöä Verifying persistence...');\r\n                    const retrieved = await globalTicketDb.getTicket(ticket.id);\r\n                    if (retrieved) {\r\n                        orchestratorOutputChannel.appendLine(`Γ£à Ticket persisted: ${retrieved.title}`);\r\n                    } else {\r\n                        orchestratorOutputChannel.appendLine('Γ¥î Failed to retrieve ticket');\r\n                    }\r\n\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine('ΓòÉ'.repeat(70));\r\n                    orchestratorOutputChannel.show();\r\n\r\n                } catch (error) {\r\n                    const errorMsg = error instanceof Error ? error.message : String(error);\r\n                    if (orchestratorOutputChannel) {\r\n                        orchestratorOutputChannel.appendLine(`Γ¥î Error: ${errorMsg}`);\r\n                        orchestratorOutputChannel.appendLine(`Stack: ${error instanceof Error ? error.stack : 'N/A'}`);\r\n                        orchestratorOutputChannel.show();\r\n                    }\r\n                    vscode.window.showErrorMessage(\r\n                        `Γ¥î Failed to test ticket integration: ${errorMsg}`\r\n                    );\r\n                }\r\n            }\r\n        );\r\n        context.subscriptions.push(testCreateTicketCommand);\r\n\r\n        // ====================================================================\r\n        // Test Route Ticket Command\r\n        // ====================================================================\r\n        const testRouteTicketCommand = vscode.commands.registerCommand(\r\n            'coe.testRouteTicket',\r\n            async () => {\r\n                try {\r\n                    if (!orchestratorOutputChannel) {\r\n                        vscode.window.showErrorMessage('Γ¥î COE: Output channel not initialized');\r\n                        return;\r\n                    }\r\n\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine('≡ƒÄ» Testing Boss AI Router...');\r\n\r\n                    // Import BossRouter and AgentTeamType\r\n                    const { BossRouter } = await import('./services/bossRouter');\r\n                    const { AgentTeamType } = await import('./types/agentTeam');\r\n\r\n                    const router = BossRouter.getInstance();\r\n\r\n                    // Create sample tickets for testing\r\n                    const testTickets = [\r\n                        {\r\n                            ticket_id: 'TK-TEST-001',\r\n                            type: 'ai_to_human' as const,\r\n                            status: 'open' as const,\r\n                            priority: 1 as const,\r\n                            creator: 'Answer Team',\r\n                            assignee: 'unassigned',\r\n                            title: 'Need clarification on user requirement',\r\n                            description: 'What should happen when user clicks the save button?',\r\n                            thread: [],\r\n                            created_at: new Date(),\r\n                            updated_at: new Date()\r\n                        },\r\n                        {\r\n                            ticket_id: 'TK-TEST-002',\r\n                            type: 'human_to_ai' as const,\r\n                            status: 'open' as const,\r\n                            priority: 1 as const,\r\n                            creator: 'user',\r\n                            assignee: 'unassigned',\r\n                            title: 'Plan new authentication system',\r\n                            description: 'Need to define architecture for OAuth integration',\r\n                            thread: [],\r\n                            created_at: new Date(),\r\n                            updated_at: new Date()\r\n                        },\r\n                        {\r\n                            ticket_id: 'TK-TEST-003',\r\n                            type: 'human_to_ai' as const,\r\n                            status: 'open' as const,\r\n                            priority: 2 as const,\r\n                            creator: 'user',\r\n                            assignee: 'unassigned',\r\n                            title: 'Verify test coverage',\r\n                            description: 'Check that all new code has proper test coverage',\r\n                            thread: [],\r\n                            created_at: new Date(),\r\n                            updated_at: new Date()\r\n                        },\r\n                        {\r\n                            ticket_id: 'TK-TEST-004',\r\n                            type: 'human_to_ai' as const,\r\n                            status: 'open' as const,\r\n                            priority: 2 as const,\r\n                            creator: 'user',\r\n                            assignee: 'unassigned',\r\n                            title: 'Research best database for project',\r\n                            description: 'Investigate PostgreSQL vs MongoDB for our use case',\r\n                            thread: [],\r\n                            created_at: new Date(),\r\n                            updated_at: new Date()\r\n                        },\r\n                        {\r\n                            ticket_id: 'TK-TEST-005',\r\n                            type: 'human_to_ai' as const,\r\n                            status: 'open' as const,\r\n                            priority: 3 as const,\r\n                            creator: 'user',\r\n                            assignee: 'unassigned',\r\n                            title: 'Unknown task type',\r\n                            description: 'Something random with no keywords',\r\n                            thread: [],\r\n                            created_at: new Date(),\r\n                            updated_at: new Date()\r\n                        }\r\n                    ];\r\n\r\n                    // Route each ticket and display results\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine('Routing Test Tickets:');\r\n                    orchestratorOutputChannel.appendLine('ΓöÇ'.repeat(60));\r\n\r\n                    for (const ticket of testTickets) {\r\n                        const team = router.routeTicket(ticket);\r\n\r\n                        orchestratorOutputChannel.appendLine('');\r\n                        orchestratorOutputChannel.appendLine(`Ticket: ${ticket.ticket_id}`);\r\n                        orchestratorOutputChannel.appendLine(`  Title: ${ticket.title}`);\r\n                        orchestratorOutputChannel.appendLine(`  Type: ${ticket.type} | Priority: P${ticket.priority}`);\r\n                        orchestratorOutputChannel.appendLine(`  Γ₧£ Routed to: ${team.toUpperCase()} TEAM`);\r\n\r\n                        // Add explanation\r\n                        let explanation = '';\r\n                        switch (team) {\r\n                            case AgentTeamType.Answer:\r\n                                explanation = ticket.type === 'ai_to_human'\r\n                                    ? '(AI asking human for clarification)'\r\n                                    : '(Human question)';\r\n                                break;\r\n                            case AgentTeamType.Planning:\r\n                                explanation = '(Complex work breakdown needed)';\r\n                                break;\r\n                            case AgentTeamType.Verification:\r\n                                explanation = '(Testing/validation required)';\r\n                                break;\r\n                            case AgentTeamType.Research:\r\n                                explanation = '(Investigation needed)';\r\n                                break;\r\n                            case AgentTeamType.Escalate:\r\n                                explanation = '(No matching rule - escalating)';\r\n                                break;\r\n                        }\r\n                        orchestratorOutputChannel.appendLine(`  ${explanation}`);\r\n                    }\r\n\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine('ΓöÇ'.repeat(60));\r\n                    orchestratorOutputChannel.appendLine('Γ£à Boss AI Router test complete!');\r\n                    orchestratorOutputChannel.appendLine('');\r\n                    orchestratorOutputChannel.appendLine(`Total rules configured: ${router.getRules().length}`);\r\n\r\n                    orchestratorOutputChannel.show();\r\n                    vscode.window.showInformationMessage('Γ£à Boss AI Router test complete! Check output.');\r\n\r\n                } catch (error) {\r\n                    const errorMsg = error instanceof Error ? error.message : String(error);\r\n                    if (orchestratorOutputChannel) {\r\n                        orchestratorOutputChannel.appendLine(`Γ¥î Error testing router: ${errorMsg}`);\r\n                        orchestratorOutputChannel.show();\r\n                    }\r\n                    vscode.window.showErrorMessage(`Γ¥î Failed to test router: ${errorMsg}`);\r\n                }\r\n            }\r\n        );\r\n        context.subscriptions.push(testRouteTicketCommand);\r\n\r\n        // ====================================================================\r\n        // Cleanup History Command\r\n        // ====================================================================\r\n        const cleanupHistoryCommand = vscode.commands.registerCommand(\r\n            'coe.cleanupHistory',\r\n            async () => {\r\n                if (!completedTasksProvider) {\r\n                    vscode.window.showErrorMessage('Γ¥î Completed tasks provider not initialized');\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    orchestratorOutputChannel?.appendLine('≡ƒº╣ Starting completed tasks cleanup...');\r\n\r\n                    // Read retention config from VS Code settings\r\n                    const config = vscode.workspace.getConfiguration('coe.history');\r\n                    const retentionConfig = config?.get('retention', { maxAgeHours: 168, maxCount: 0 }) || { maxAgeHours: 168, maxCount: 0 };\r\n\r\n                    let maxAgeHours = 168;\r\n                    let maxCount = 0;\r\n\r\n                    if (typeof retentionConfig === 'object' && retentionConfig !== null) {\r\n                        maxAgeHours = (retentionConfig as any).maxAgeHours || 168;\r\n                        maxCount = (retentionConfig as any).maxCount || 0;\r\n                    }\r\n\r\n                    orchestratorOutputChannel?.appendLine(`   Config: maxAgeHours=${maxAgeHours}, maxCount=${maxCount}`);\r\n\r\n                    // Run cleanup\r\n                    const ticketDb = TicketDatabase.getInstance();\r\n                    const deletedCount = await ticketDb.cleanupOldTasks(maxAgeHours, maxCount);\r\n\r\n                    orchestratorOutputChannel?.appendLine(`Γ£à Cleanup complete: Deleted ${deletedCount} old completed tasks`);\r\n\r\n                    // Refresh completed tasks view\r\n                    completedTasksProvider.refresh();\r\n\r\n                    if (deletedCount > 0) {\r\n                        vscode.window.showInformationMessage(`Γ£à Deleted ${deletedCount} old completed task(s)`);\r\n                    } else {\r\n                        vscode.window.showInformationMessage('Γä╣∩╕Å No tasks to cleanup (within retention limits)');\r\n                    }\r\n\r\n                } catch (error) {\r\n                    const errorMsg = error instanceof Error ? error.message : String(error);\r\n                    orchestratorOutputChannel?.appendLine(`Γ¥î Error during cleanup: ${errorMsg}`);\r\n                    vscode.window.showErrorMessage(`Γ¥î Cleanup failed: ${errorMsg}`);\r\n                }\r\n            }\r\n        );\r\n        context.subscriptions.push(cleanupHistoryCommand);\r\n\r\n        orchestratorOutputChannel.appendLine('≡ƒôï Commands Registered:');\r\n        orchestratorOutputChannel.appendLine('  ΓÇó coe.activate - Activate orchestration');\r\n        orchestratorOutputChannel.appendLine('  ΓÇó coe.regeneratePRD - Regenerate PRD from Plans/ (Command Palette)');\r\n        orchestratorOutputChannel.appendLine('  ΓÇó coe.testOrchestrator - Test orchestrator (click status bar or use Command Palette)');\r\n        orchestratorOutputChannel.appendLine('  ΓÇó coe.testCreateTicket - Test ticket creation (Command Palette)');\r\n        orchestratorOutputChannel.appendLine('  ΓÇó coe.testRouteTicket - Test Boss AI Router (Command Palette)');\r\n        orchestratorOutputChannel.appendLine('  ΓÇó coe.cleanupHistory - Cleanup old completed tasks (Command Palette)');\r\n        orchestratorOutputChannel.appendLine('');\r\n        orchestratorOutputChannel.appendLine('Start using COE by running \"coe.testOrchestrator\" from Command Palette or clicking the status bar!');\r\n\r\n        // User-facing success toast\r\n        vscode.window.showInformationMessage('COE: Orchestrator started');\r\n\r\n        // ====================================================================\r\n        // 7. Log successful initialization\r\n        // ====================================================================\r\n\r\n    } catch (error) {\r\n        const errorMsg = error instanceof Error ? error.message : String(error);\r\n\r\n        if (orchestratorOutputChannel) {\r\n            orchestratorOutputChannel.appendLine(`Γ¥î ACTIVATION FAILED: ${errorMsg}`);\r\n        }\r\n\r\n        vscode.window.showErrorMessage(`Γ¥î COE: Failed to activate extension: ${errorMsg}`);\r\n    }\r\n}\r\n\r\n/**\r\n * This function runs when the extension shuts down.\r\n * Think of it as the \"power off\" button - it cleans up resources.\r\n */\r\nexport async function deactivate() {\r\n    try {\r\n\r\n        // Stop PRD watcher\r\n        PlansFileWatcher.stopWatching();\r\n        orchestratorOutputChannel?.appendLine('Γ£à Plans Watcher stopped');\r\n\r\n        // Dispose File Config Manager\r\n        FileConfigManager.dispose();\r\n        orchestratorOutputChannel?.appendLine('Γ£à File Config Manager disposed');\r\n\r\n        // Close TicketDb if open\r\n        if (globalTicketDb) {\r\n            try {\r\n                await globalTicketDb.close();\r\n                globalTicketDb = null;\r\n            } catch (error) {\r\n                // eslint-disable-next-line no-empty\r\n            }\r\n        }\r\n\r\n        // Dispose status bar item\r\n        if (statusBarItem) {\r\n            statusBarItem.dispose();\r\n            statusBarItem = null;\r\n        }\r\n\r\n        // Shutdown Programming Orchestrator gracefully\r\n        if (programmingOrchestrator) {\r\n            await programmingOrchestrator.shutdown();\r\n            programmingOrchestrator = null;\r\n        }\r\n\r\n        // Dispose output channel\r\n        if (orchestratorOutputChannel) {\r\n            orchestratorOutputChannel.appendLine('');\r\n            orchestratorOutputChannel.appendLine('≡ƒ¢æ COE: Extension deactivated');\r\n            orchestratorOutputChannel.dispose();\r\n            orchestratorOutputChannel = null;\r\n        }\r\n\r\n        // Small delay for OneDrive sync if needed (non-blocking)\r\n        await new Promise(resolve => setTimeout(resolve, 200));\r\n\r\n    } catch (error) {\r\n        const errorMsg = error instanceof Error ? error.message : String(error);\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\github\\__tests__\\issuesSync.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[923,926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[923,926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1498,1501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1498,1501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'performSyncSpy' is assigned a value but never used.","line":61,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":61,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1994,1997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1994,1997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is assigned a value but never used.","line":113,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":113,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":116,"column":113,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":116,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4024,4027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4024,4027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4787,4790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4787,4790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6119,6122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6119,6122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":182,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6689,6692],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6689,6692],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7294,7297],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7294,7297],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7615,7618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7615,7618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ≡ƒº¬ Unit Tests for GitHub Issues Sync\r\n *\r\n * Tests the bidirectional sync manager between GitHub Issues and local tasks\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport { IssuesSync } from '../issuesSync';\r\nimport { GitHubAPI } from '../api';\r\n\r\njest.mock('vscode', () => ({\r\n    window: {\r\n        showErrorMessage: jest.fn(),\r\n    },\r\n}));\r\n\r\ndescribe('IssuesSync', () => {\r\n    let issuesSync: IssuesSync;\r\n    let mockGitHubAPI: jest.Mocked<GitHubAPI>;\r\n\r\n    beforeEach(() => {\r\n        jest.clearAllMocks();\r\n        issuesSync = new IssuesSync();\r\n        mockGitHubAPI = {} as jest.Mocked<GitHubAPI>;\r\n    });\r\n\r\n    afterEach(() => {\r\n        // Clean up any active sync intervals\r\n        issuesSync.stopSync();\r\n    });\r\n\r\n    describe('startSync', () => {\r\n        it('should start the sync process and schedule periodic syncs', (done) => {\r\n            const performSyncSpy = jest.spyOn(issuesSync as any, 'performSync');\r\n\r\n            issuesSync.startSync(mockGitHubAPI);\r\n\r\n            // Initial sync should be called immediately\r\n            expect(performSyncSpy).toHaveBeenCalledTimes(1);\r\n            expect(performSyncSpy).toHaveBeenCalledWith(mockGitHubAPI);\r\n\r\n            // Verify sync interval is set (we won't wait for the full 5 minutes in tests)\r\n            issuesSync.stopSync();\r\n            done();\r\n        });\r\n\r\n        it('should call performSync with the GitHub API instance', (done) => {\r\n            const performSyncSpy = jest.spyOn(issuesSync as any, 'performSync');\r\n\r\n            issuesSync.startSync(mockGitHubAPI);\r\n\r\n            // Check that performSync was called with the correct API\r\n            expect(performSyncSpy).toHaveBeenCalledWith(mockGitHubAPI);\r\n\r\n            issuesSync.stopSync();\r\n            done();\r\n        });\r\n\r\n        it('should set up an interval for periodic sync', (done) => {\r\n            const setIntervalSpy = jest.spyOn(global, 'setInterval');\r\n            const performSyncSpy = jest.spyOn(issuesSync as any, 'performSync');\r\n\r\n            issuesSync.startSync(mockGitHubAPI);\r\n\r\n            // Should have called setInterval to schedule periodic syncs\r\n            expect(setIntervalSpy).toHaveBeenCalled();\r\n\r\n            issuesSync.stopSync();\r\n            setIntervalSpy.mockRestore();\r\n            done();\r\n        });\r\n    });\r\n\r\n    describe('stopSync', () => {\r\n        it('should clear the sync interval', () => {\r\n            issuesSync.startSync(mockGitHubAPI);\r\n\r\n            const clearIntervalSpy = jest.spyOn(global, 'clearInterval');\r\n            issuesSync.stopSync();\r\n\r\n            expect(clearIntervalSpy).toHaveBeenCalled();\r\n            clearIntervalSpy.mockRestore();\r\n        });\r\n\r\n        it('should set syncInterval to null after stopping', () => {\r\n            issuesSync.startSync(mockGitHubAPI);\r\n            issuesSync.stopSync();\r\n\r\n            // After stop, internal syncInterval should be cleared\r\n            // We can verify this by trying to stop again without errors\r\n            expect(() => issuesSync.stopSync()).not.toThrow();\r\n        });\r\n\r\n        it('should handle stopSync when no sync is running', () => {\r\n            // Should not throw error if stopSync called without startSync\r\n            expect(() => issuesSync.stopSync()).not.toThrow();\r\n        });\r\n\r\n        it('should be safe to call stopSync multiple times', () => {\r\n            issuesSync.startSync(mockGitHubAPI);\r\n            issuesSync.stopSync();\r\n            issuesSync.stopSync();\r\n            issuesSync.stopSync();\r\n\r\n            // Should not throw any errors\r\n            expect(true).toBe(true);\r\n        });\r\n    });\r\n\r\n    describe('performSync (private)', () => {\r\n        it('should handle sync errors gracefully', async () => {\r\n            const performSync = issuesSync['performSync'];\r\n            const error = new Error('Sync failed');\r\n\r\n            // Mock the to show error message\r\n            jest.spyOn(vscode.window, 'showErrorMessage').mockImplementation(() => Promise.resolve(undefined as any));\r\n\r\n            // Call performSync directly and verify error handling\r\n            await performSync.call(issuesSync, mockGitHubAPI);\r\n\r\n            // performSync is wrapped in try-catch, so it should not throw\r\n            expect(vscode.window.showErrorMessage).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('should execute without throwing errors', async () => {\r\n            const performSync = issuesSync['performSync'];\r\n\r\n            // This should not throw\r\n            await expect(performSync.call(issuesSync, mockGitHubAPI)).resolves.not.toThrow();\r\n        });\r\n    });\r\n\r\n    describe('syncNow', () => {\r\n        it('should trigger an immediate sync operation', async () => {\r\n            const performSyncSpy = jest.spyOn(issuesSync as any, 'performSync');\r\n\r\n            await issuesSync.syncNow(mockGitHubAPI);\r\n\r\n            expect(performSyncSpy).toHaveBeenCalledWith(mockGitHubAPI);\r\n        });\r\n\r\n        it('should call performSync without starting a periodic timer', async () => {\r\n            const setIntervalSpy = jest.spyOn(global, 'setInterval');\r\n\r\n            await issuesSync.syncNow(mockGitHubAPI);\r\n\r\n            // setInterval should NOT be called by syncNow\r\n            expect(setIntervalSpy).not.toHaveBeenCalled();\r\n\r\n            setIntervalSpy.mockRestore();\r\n        });\r\n\r\n        it('should work independently of startSync', async () => {\r\n            // Call syncNow without starting periodic sync\r\n            await expect(issuesSync.syncNow(mockGitHubAPI)).resolves.not.toThrow();\r\n        });\r\n\r\n        it('should handle multiple consecutive syncNow calls', async () => {\r\n            await expect(issuesSync.syncNow(mockGitHubAPI)).resolves.not.toThrow();\r\n            await expect(issuesSync.syncNow(mockGitHubAPI)).resolves.not.toThrow();\r\n            await expect(issuesSync.syncNow(mockGitHubAPI)).resolves.not.toThrow();\r\n        });\r\n    });\r\n\r\n    describe('integration', () => {\r\n        it('should handle full sync lifecycle: start -> sync -> stop', async () => {\r\n            const performSyncSpy = jest.spyOn(issuesSync as any, 'performSync');\r\n\r\n            issuesSync.startSync(mockGitHubAPI);\r\n            expect(performSyncSpy).toHaveBeenCalledTimes(1);\r\n\r\n            await issuesSync.syncNow(mockGitHubAPI);\r\n            expect(performSyncSpy).toHaveBeenCalledTimes(2);\r\n\r\n            issuesSync.stopSync();\r\n\r\n            // Stop should have been successful\r\n            expect(performSyncSpy).toHaveBeenCalledTimes(2); // No additional calls\r\n        });\r\n\r\n        it('should allow restarting sync after stopping', () => {\r\n            const performSyncSpy = jest.spyOn(issuesSync as any, 'performSync');\r\n\r\n            issuesSync.startSync(mockGitHubAPI);\r\n            expect(performSyncSpy).toHaveBeenCalledTimes(1);\r\n\r\n            issuesSync.stopSync();\r\n\r\n            issuesSync.startSync(mockGitHubAPI);\r\n            expect(performSyncSpy).toHaveBeenCalledTimes(2);\r\n        });\r\n\r\n        it('should use correct sync interval constant', () => {\r\n            // Verify 5-minute interval is configured correctly\r\n            const EXPECTED_INTERVAL = 5 * 60 * 1000; // 5 minutes in ms\r\n\r\n            // The class should have this interval configured\r\n            expect((issuesSync as any).SYNC_INTERVAL_MS).toBe(EXPECTED_INTERVAL);\r\n        });\r\n    });\r\n\r\n    describe('error scenarios', () => {\r\n        it('should not crash if GitHub API is undefined', async () => {\r\n            // TypeScript will complain, but at runtime this should handle:\r\n            await expect(issuesSync.syncNow(undefined as any)).resolves.not.toThrow();\r\n        });\r\n\r\n        it('should show error message on sync failure', async () => {\r\n            const showErrorSpy = jest.spyOn(vscode.window, 'showErrorMessage');\r\n\r\n            // Even though performSync is private and catches errors,\r\n            // we verify the error handling exists\r\n            await issuesSync.syncNow(mockGitHubAPI);\r\n\r\n            // For now, it should not show error (successful empty sync)\r\n            expect(showErrorSpy).not.toHaveBeenCalled();\r\n        });\r\n    });\r\n\r\n    describe('edge cases', () => {\r\n        it('should handle rapid start/stop cycles', () => {\r\n            issuesSync.startSync(mockGitHubAPI);\r\n            issuesSync.stopSync();\r\n            issuesSync.startSync(mockGitHubAPI);\r\n            issuesSync.stopSync();\r\n\r\n            // Should complete without errors\r\n            expect(true).toBe(true);\r\n        });\r\n\r\n        it('should maintain state correctly across multiple operations', async () => {\r\n            issuesSync.startSync(mockGitHubAPI);\r\n\r\n            await issuesSync.syncNow(mockGitHubAPI);\r\n            await issuesSync.syncNow(mockGitHubAPI);\r\n\r\n            issuesSync.stopSync();\r\n\r\n            // New start should work fresh\r\n            issuesSync.startSync(mockGitHubAPI);\r\n            issuesSync.stopSync();\r\n\r\n            // Should complete without state conflicts\r\n            expect(true).toBe(true);\r\n        });\r\n    });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\github\\api.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'owner' is defined but never used.","line":58,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'repo' is defined but never used.","line":58,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'issueNumber' is defined but never used.","line":58,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":68},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1647,1650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1647,1650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'owner' is defined but never used.","line":66,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":66,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'repo' is defined but never used.","line":66,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":66,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'title' is defined but never used.","line":66,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":66,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'body' is defined but never used.","line":66,"column":67,"nodeType":"Identifier","messageId":"unusedVar","endLine":66,"endColumn":79},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1885,1888],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1885,1888],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2120,2123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2120,2123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":96,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":99,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2134,2137],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2134,2137],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2600,2603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2600,2603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2614,2617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2614,2617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GitHub API Integration\r\n * Wrapper around Octokit for GitHub operations\r\n */\r\n\r\nimport { Octokit } from '@octokit/rest';\r\nimport * as vscode from 'vscode';\r\nimport { ConfigManager } from '../utils/config';\r\n\r\nexport class GitHubAPI {\r\n    private octokit: Octokit | null = null;\r\n    private isAuthenticated: boolean = false;\r\n    private context: vscode.ExtensionContext | null = null;\r\n\r\n    /**\r\n     * Set extension context for secure token access\r\n     */\r\n    setContext(context: vscode.ExtensionContext): void {\r\n        this.context = context;\r\n    }\r\n\r\n    /**\r\n     * Initialize GitHub API with authentication\r\n     * Uses SecretStorage for secure token retrieval\r\n     */\r\n    async authenticate(token?: string): Promise<boolean> {\r\n\r\n        try {\r\n            // Get token from SecretStorage if not provided\r\n            if (!token && this.context) {\r\n                token = await ConfigManager.getGitHubToken(this.context);\r\n            }\r\n\r\n            if (!token) {\r\n                this.isAuthenticated = false;\r\n                return false;\r\n            }\r\n\r\n            // Initialize Octokit client\r\n            this.octokit = new Octokit({\r\n                auth: token,\r\n            });\r\n\r\n            // Verify authentication by getting user info\r\n            await this.octokit.users.getAuthenticated();\r\n\r\n            this.isAuthenticated = true;\r\n            return true;\r\n        } catch (error) {\r\n            this.isAuthenticated = false;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a single issue\r\n     */\r\n    async getIssue(owner: string, repo: string, issueNumber: number): Promise<any> {\r\n        // TODO: Fetch issue from GitHub\r\n        throw new Error('Not implemented');\r\n    }\r\n\r\n    /**\r\n     * Create a new issue\r\n     */\r\n    async createIssue(owner: string, repo: string, title: string, body: string): Promise<any> {\r\n        // TODO: Create issue on GitHub\r\n        throw new Error('Not implemented');\r\n    }\r\n\r\n    /**\r\n     * Update an existing issue\r\n     */\r\n    async updateIssue(owner: string, repo: string, issueNumber: number, updates: any): Promise<any> {\r\n        if (!this.isAuthenticated || !this.octokit) {\r\n            throw new Error('Not authenticated');\r\n        }\r\n\r\n        const response = await this.octokit.issues.update({\r\n            owner,\r\n            repo,\r\n            issue_number: issueNumber,\r\n            ...updates,\r\n        });\r\n\r\n        return response.data;\r\n    }\r\n\r\n    /**\r\n     * List all issues for a repository\r\n     */\r\n    async listIssues(owner: string, repo: string, filters?: any): Promise<any[]> {\r\n        if (!this.isAuthenticated || !this.octokit) {\r\n            throw new Error('Not authenticated');\r\n        }\r\n\r\n        const response = await this.octokit.issues.listForRepo({\r\n            owner,\r\n            repo,\r\n            ...filters,\r\n        });\r\n\r\n        return response.data;\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\github\\issuesSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'githubAPI' is defined but never used.","line":42,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GitHub Issues Sync Manager\r\n * Handles bidirectional sync between GitHub Issues and local task queue\r\n * Sync interval: 5 minutes (as per architecture specs)\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport { GitHubAPI } from './api';\r\n\r\nexport class IssuesSync {\r\n    private syncInterval: NodeJS.Timeout | null = null;\r\n    private readonly SYNC_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n    /**\r\n     * Start the sync process\r\n     */\r\n    startSync(githubAPI: GitHubAPI): void {\r\n\r\n        // Initial sync\r\n        this.performSync(githubAPI);\r\n\r\n        // Schedule periodic sync\r\n        this.syncInterval = setInterval(() => {\r\n            this.performSync(githubAPI);\r\n        }, this.SYNC_INTERVAL_MS);\r\n\r\n    }\r\n\r\n    /**\r\n     * Stop the sync process\r\n     */\r\n    stopSync(): void {\r\n        if (this.syncInterval) {\r\n            clearInterval(this.syncInterval);\r\n            this.syncInterval = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Perform a single sync operation\r\n     */\r\n    private async performSync(githubAPI: GitHubAPI): Promise<void> {\r\n\r\n        try {\r\n            // TODO: Fetch latest issues from GitHub\r\n            // TODO: Compare with local task queue\r\n            // TODO: Push local changes to GitHub\r\n            // TODO: Pull remote changes to local\r\n            // TODO: Resolve conflicts\r\n\r\n        } catch (error) {\r\n            vscode.window.showErrorMessage(`GitHub sync failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger an immediate sync (manual)\r\n     */\r\n    async syncNow(githubAPI: GitHubAPI): Promise<void> {\r\n        await this.performSync(githubAPI);\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\github\\webhooks.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[155,158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[155,158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[180,183],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[180,183],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[202,205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[202,205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[220,223],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[220,223],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'event' is defined but never used.","line":36,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'event' is defined but never used.","line":40,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'event' is defined but never used.","line":44,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'event' is defined but never used.","line":48,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":48,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GitHub Webhook Handler\r\n * Processes incoming webhook events from GitHub\r\n */\r\n\r\nexport interface WebhookEvent {\r\n    action: string;\r\n    issue?: any;\r\n    pull_request?: any;\r\n    repository: any;\r\n    sender: any;\r\n}\r\n\r\n/**\r\n * Handle GitHub webhook events\r\n */\r\nexport function handleWebhook(event: WebhookEvent): void {\r\n\r\n    switch (event.action) {\r\n        case 'opened':\r\n            handleIssueOpened(event);\r\n            break;\r\n        case 'closed':\r\n            handleIssueClosed(event);\r\n            break;\r\n        case 'edited':\r\n            handleIssueEdited(event);\r\n            break;\r\n        case 'labeled':\r\n            handleIssueLabeled(event);\r\n            break;\r\n        default:\r\n    }\r\n}\r\n\r\nfunction handleIssueOpened(event: WebhookEvent): void {\r\n    // TODO: Add issue to task queue\r\n}\r\n\r\nfunction handleIssueClosed(event: WebhookEvent): void {\r\n    // TODO: Mark task as complete\r\n}\r\n\r\nfunction handleIssueEdited(event: WebhookEvent): void {\r\n    // TODO: Update task details\r\n}\r\n\r\nfunction handleIssueLabeled(event: WebhookEvent): void {\r\n    // TODO: Update task priority/category\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\protocol.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\server.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'validateRequest' is defined but never used.","line":28,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MCP Server Implementation\r\n * Handles Model Context Protocol communication with AI agents\r\n * \r\n * This is the \"waiter\" service that:\r\n * - Receives task requests from AI agents via JSON-RPC 2.0\r\n * - Routes requests to appropriate tool handlers\r\n * - Returns task data from the queue\r\n * - Reports task completion and status updates\r\n * - Handles Q&A for context\r\n * \r\n * Architecture:\r\n * - Uses JSON-RPC 2.0 protocol for communication\r\n * - Routes tool calls to registered handlers\r\n * - Manages server lifecycle (start/stop/error handling)\r\n * \r\n * References:\r\n * - Plans/COE-Master-Plan/05-MCP-API-Reference.md (Tool specifications)\r\n * - Plans/COE-Master-Plan/01-Architecture-Document.md (System design)\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport {\r\n    MCPRequest,\r\n    MCPResponse,\r\n    MCPErrorCode,\r\n    MCPProtocolError,\r\n    validateRequest,\r\n    createSuccessResponse,\r\n    createErrorResponse,\r\n    errorToResponse,\r\n    parseStdioMessage,\r\n    formatStdioResponse,\r\n} from './protocol';\r\n\r\n/**\r\n * Type for MCP tool handler functions\r\n */\r\nexport type MCPToolHandler = (params: Record<string, unknown>) => Promise<unknown>;\r\n\r\n/**\r\n * Server configuration options\r\n */\r\nexport interface MCPServerConfig {\r\n    name: string;\r\n    version: string;\r\n    enableLogging?: boolean;\r\n    logChannel?: vscode.OutputChannel;\r\n}\r\n\r\n/**\r\n * MCP Server - Main orchestration server for AI agent communication\r\n */\r\nexport class MCPServer {\r\n    private isRunning: boolean = false;\r\n    private toolHandlers: Map<string, MCPToolHandler> = new Map();\r\n    private config: MCPServerConfig;\r\n    private logChannel?: vscode.OutputChannel;\r\n\r\n    constructor(config: MCPServerConfig) {\r\n        this.config = config;\r\n        this.logChannel = config.logChannel;\r\n\r\n        this.log(`MCP Server initialized: ${config.name} v${config.version}`);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Server Lifecycle Management\r\n    // ========================================================================\r\n\r\n    /**\r\n     * Start the MCP server and register default tools\r\n     */\r\n    async start(): Promise<void> {\r\n        if (this.isRunning) {\r\n            this.log('Server already running, ignoring start request', 'warn');\r\n            return;\r\n        }\r\n\r\n        this.log('MCP Server: Starting...');\r\n        this.isRunning = true;\r\n\r\n        // Server is now ready to accept tool registrations\r\n        // Note: Tools are registered externally via registerTool()\r\n\r\n        this.log(`MCP Server: Started successfully (${this.toolHandlers.size} tools registered)`);\r\n    }\r\n\r\n    /**\r\n     * Stop the MCP server gracefully\r\n     */\r\n    async stop(): Promise<void> {\r\n        if (!this.isRunning) {\r\n            this.log('Server not running, ignoring stop request', 'warn');\r\n            return;\r\n        }\r\n\r\n        this.log('MCP Server: Stopping...');\r\n        this.isRunning = false;\r\n\r\n        // Clear tool handlers\r\n        const toolCount = this.toolHandlers.size;\r\n        this.toolHandlers.clear();\r\n\r\n        this.log(`MCP Server: Stopped (cleared ${toolCount} tool handlers)`);\r\n    }\r\n\r\n    /**\r\n     * Restart the server\r\n     */\r\n    async restart(): Promise<void> {\r\n        this.log('MCP Server: Restarting...');\r\n        await this.stop();\r\n        await this.start();\r\n        this.log('MCP Server: Restart complete');\r\n    }\r\n\r\n    /**\r\n     * Check if server is running\r\n     */\r\n    isServerRunning(): boolean {\r\n        return this.isRunning;\r\n    }\r\n\r\n    // ========================================================================\r\n    // Tool Registration\r\n    // ========================================================================\r\n\r\n    /**\r\n     * Register a new MCP tool handler\r\n     * @param method - Tool method name (e.g., 'getNextTask')\r\n     * @param handler - Async function to handle tool calls\r\n     */\r\n    registerTool(method: string, handler: MCPToolHandler): void {\r\n        if (this.toolHandlers.has(method)) {\r\n            this.log(`Warning: Overwriting existing handler for method '${method}'`, 'warn');\r\n        }\r\n\r\n        this.toolHandlers.set(method, handler);\r\n        this.log(`Registered tool: ${method}`);\r\n    }\r\n\r\n    /**\r\n     * Unregister a tool handler\r\n     */\r\n    unregisterTool(method: string): boolean {\r\n        const result = this.toolHandlers.delete(method);\r\n        if (result) {\r\n            this.log(`Unregistered tool: ${method}`);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get list of registered tool methods\r\n     */\r\n    getRegisteredTools(): string[] {\r\n        return Array.from(this.toolHandlers.keys());\r\n    }\r\n\r\n    // ========================================================================\r\n    // Request Handling\r\n    // ========================================================================\r\n\r\n    /**\r\n     * Handle an incoming MCP request\r\n     * @param request - Validated MCP request\r\n     * @returns MCP response\r\n     */\r\n    async handleRequest(request: MCPRequest): Promise<MCPResponse> {\r\n        this.log(`Handling request: ${request.method} (id: ${request.id})`);\r\n\r\n        if (!this.isRunning) {\r\n            return createErrorResponse(\r\n                MCPErrorCode.TASK_QUEUE_UNAVAILABLE,\r\n                'MCP Server is not running',\r\n                request.id\r\n            );\r\n        }\r\n\r\n        // Check if tool handler exists\r\n        const handler = this.toolHandlers.get(request.method);\r\n        if (!handler) {\r\n            this.log(`Method not found: ${request.method}`, 'error');\r\n            return createErrorResponse(\r\n                MCPErrorCode.METHOD_NOT_FOUND,\r\n                `Method '${request.method}' not found`,\r\n                request.id,\r\n                { availableMethods: this.getRegisteredTools() }\r\n            );\r\n        }\r\n\r\n        // Execute tool handler\r\n        try {\r\n            const params = request.params || {};\r\n            const result = await handler(params);\r\n\r\n            this.log(`Request ${request.id} completed successfully`);\r\n            return createSuccessResponse(result, request.id);\r\n        } catch (error) {\r\n            this.log(`Request ${request.id} failed: ${error}`, 'error');\r\n\r\n            if (error instanceof MCPProtocolError) {\r\n                return errorToResponse(error, request.id);\r\n            }\r\n\r\n            // Wrap unknown errors\r\n            return createErrorResponse(\r\n                MCPErrorCode.INTERNAL_ERROR,\r\n                error instanceof Error ? error.message : 'Unknown error occurred',\r\n                request.id,\r\n                { originalError: String(error) }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process a raw JSON-RPC message (from stdio or other transport)\r\n     * @param rawMessage - Raw JSON string\r\n     * @returns Formatted JSON-RPC response string\r\n     */\r\n    async processMessage(rawMessage: string): Promise<string> {\r\n        try {\r\n            // Parse and validate request\r\n            const request = parseStdioMessage(rawMessage);\r\n\r\n            // Handle request\r\n            const response = await this.handleRequest(request);\r\n\r\n            // Format response for stdio\r\n            return formatStdioResponse(response);\r\n        } catch (error) {\r\n            // Handle parse errors (invalid JSON-RPC format)\r\n            if (error instanceof MCPProtocolError) {\r\n                const errorResponse = createErrorResponse(\r\n                    error.code,\r\n                    error.message,\r\n                    'unknown', // No request ID available for parse errors\r\n                    error.data\r\n                );\r\n                return formatStdioResponse(errorResponse);\r\n            }\r\n\r\n            // Unexpected error\r\n            const errorResponse = createErrorResponse(\r\n                MCPErrorCode.INTERNAL_ERROR,\r\n                'Failed to process message',\r\n                'unknown'\r\n            );\r\n            return formatStdioResponse(errorResponse);\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Logging\r\n    // ========================================================================\r\n\r\n    /**\r\n     * Internal logging function\r\n     */\r\n    private log(message: string, level: 'info' | 'warn' | 'error' = 'info'): void {\r\n        if (!this.config.enableLogging && level !== 'error') {\r\n            return;\r\n        }\r\n\r\n        const timestamp = new Date().toISOString();\r\n        const logMessage = `[${timestamp}] [MCP Server] ${message}`;\r\n\r\n        if (this.logChannel) {\r\n            this.logChannel.appendLine(logMessage);\r\n        } else {\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Server Diagnostics\r\n    // ========================================================================\r\n\r\n    /**\r\n     * Get server diagnostic information\r\n     */\r\n    getDiagnostics(): {\r\n        isRunning: boolean;\r\n        toolsRegistered: number;\r\n        tools: string[];\r\n        config: MCPServerConfig;\r\n    } {\r\n        return {\r\n            isRunning: this.isRunning,\r\n            toolsRegistered: this.toolHandlers.size,\r\n            tools: this.getRegisteredTools(),\r\n            config: {\r\n                name: this.config.name,\r\n                version: this.config.version,\r\n                enableLogging: this.config.enableLogging,\r\n            },\r\n        };\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'params' is defined but never used.","line":20,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[701,704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[701,704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[715,718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[715,718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'params' is defined but never used.","line":27,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":49},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[966,969],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[966,969],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[980,983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[980,983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'params' is defined but never used.","line":34,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1186,1189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1186,1189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1200,1203],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1200,1203],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MCP Tools Implementation (DEPRECATED)\r\n * \r\n * ΓÜá∩╕Å This file is deprecated. Individual tools are now implemented in src/mcpServer/tools/\r\n * \r\n * Use the following imports instead:\r\n * - import { getNextTask } from './tools/getNextTask';\r\n * - import { reportTaskStatus } from './tools/reportTaskStatus';\r\n * \r\n * Or use the index:\r\n * - import { getNextTask, reportTaskStatus } from './tools';\r\n */\r\n\r\n// This file is kept for backwards compatibility but is no longer used.\r\n// All tool implementations have been moved to individual files in tools/ directory.\r\n\r\n/**\r\n * @deprecated Use import { getNextTask } from './tools/getNextTask' instead\r\n */\r\nexport async function getNextTask(params: any): Promise<any> {\r\n    throw new Error('This function is deprecated. Import from ./tools/getNextTask instead.');\r\n}\r\n\r\n/**\r\n * @deprecated Use import { reportTaskStatus } from './tools/reportTaskStatus' instead\r\n */\r\nexport async function reportTaskDone(params: any): Promise<any> {\r\n    throw new Error('This function is deprecated. Import from ./tools/reportTaskStatus instead.');\r\n}\r\n\r\n/**\r\n * @deprecated Tool not yet implemented\r\n */\r\nexport async function askQuestion(params: any): Promise<any> {\r\n    throw new Error('askQuestion tool not yet implemented. Coming soon!');\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\__tests__\\getNextTask.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":414,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":414,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14723,14726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14723,14726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":422,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":422,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15002,15005],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15002,15005],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":430,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":430,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15328,15331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15328,15331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":441,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":441,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15768,15771],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15768,15771],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":449,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":449,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16041,16044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16041,16044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":459,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":459,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16439,16442],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16439,16442],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":470,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":470,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16941,16944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16941,16944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":475,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":475,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17148,17151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17148,17151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ≡ƒº¬ Comprehensive Tests for getNextTask MCP Tool\r\n *\r\n * Tests all filtering, priority sorting, and error scenarios\r\n */\r\n\r\nimport { getNextTask, GetNextTaskRequest } from '../getNextTask';\r\nimport { TaskQueue, Task } from '../../../tasks/queue';\r\nimport { MCPProtocolError } from '../../protocol';\r\n\r\ndescribe('getNextTask - Complete Branch Coverage', () => {\r\n    let taskQueue: TaskQueue;\r\n    let tasks: Task[] = [];\r\n\r\n    beforeEach(() => {\r\n        taskQueue = new TaskQueue();\r\n        tasks = [];\r\n\r\n        // Add sample tasks with different priorities\r\n        const baseTask = {\r\n            dependencies: [],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n        };\r\n\r\n        tasks = [\r\n            {\r\n                taskId: 'CRITICAL-001',\r\n                title: 'Critical task',\r\n                description: 'Critical priority task',\r\n                priority: 'critical',\r\n                status: 'pending',\r\n                ...baseTask,\r\n            },\r\n            {\r\n                taskId: 'HIGH-001',\r\n                title: 'High priority task',\r\n                description: 'High priority task',\r\n                priority: 'high',\r\n                status: 'ready',\r\n                ...baseTask,\r\n            },\r\n            {\r\n                taskId: 'MEDIUM-001',\r\n                title: 'Medium priority task',\r\n                description: 'Medium priority task',\r\n                priority: 'medium',\r\n                status: 'pending',\r\n                ...baseTask,\r\n            },\r\n            {\r\n                taskId: 'LOW-001',\r\n                title: 'Low priority task',\r\n                description: 'Low priority task',\r\n                priority: 'low',\r\n                status: 'ready',\r\n                ...baseTask,\r\n            },\r\n        ];\r\n\r\n        tasks.forEach(task => taskQueue.addTask(task));\r\n    });\r\n\r\n    describe('Basic Task Retrieval', () => {\r\n        it('should return highest priority task (critical)', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.task).toBeDefined();\r\n            expect(result.task?.priority).toBe('critical');\r\n            expect(result.task?.taskId).toBe('CRITICAL-001');\r\n        });\r\n\r\n        it('should return null when queue is empty', async () => {\r\n            const emptyQueue = new TaskQueue();\r\n\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, emptyQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.task).toBeNull();\r\n            expect(result.queueLength).toBe(0);\r\n        });\r\n\r\n        it('should include queue length in response', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.queueLength).toBeGreaterThan(0);\r\n        });\r\n\r\n        it('should provide next tasks preview', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.nextTasksPreview).toBeDefined();\r\n            expect(Array.isArray(result.nextTasksPreview)).toBe(true);\r\n        });\r\n    });\r\n\r\n    describe('Status Filtering', () => {\r\n        it('should exclude done and blocked tasks by default', async () => {\r\n            // Add done and blocked tasks\r\n            taskQueue.addTask({\r\n                taskId: 'DONE-001',\r\n                title: 'Done task',\r\n                description: '',\r\n                priority: 'critical',\r\n                status: 'done',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            taskQueue.addTask({\r\n                taskId: 'BLOCKED-001',\r\n                title: 'Blocked task',\r\n                description: '',\r\n                priority: 'critical',\r\n                status: 'blocked',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.taskId).not.toBe('DONE-001');\r\n            expect(result.task?.taskId).not.toBe('BLOCKED-001');\r\n        });\r\n\r\n        it('should filter for ready status only', async () => {\r\n            const params: GetNextTaskRequest = {\r\n                filter: 'ready',\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.status).toBe('ready');\r\n        });\r\n\r\n        it('should filter for blocked status', async () => {\r\n            // Add blocked task with critical priority\r\n            taskQueue.addTask({\r\n                taskId: 'BLOCKED-CRITICAL',\r\n                title: 'Blocked critical',\r\n                description: '',\r\n                priority: 'critical',\r\n                status: 'blocked',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {\r\n                filter: 'blocked',\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.status).toBe('blocked');\r\n        });\r\n\r\n        it('should include all tasks when filter is \"all\"', async () => {\r\n            // Add done task\r\n            taskQueue.addTask({\r\n                taskId: 'DONE-TEST',\r\n                title: 'Done task',\r\n                description: '',\r\n                priority: 'medium',\r\n                status: 'done',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {\r\n                filter: 'all',\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            // Should include done tasks when filter is 'all'\r\n            expect(result.queueLength).toBeGreaterThanOrEqual(4);\r\n        });\r\n    });\r\n\r\n    describe('Priority Filtering', () => {\r\n        it('should filter tasks by specific priority', async () => {\r\n            const params: GetNextTaskRequest = {\r\n                priority: 'high',\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.priority).toBe('high');\r\n        });\r\n\r\n        it('should return null if no tasks match priority filter', async () => {\r\n            const params: GetNextTaskRequest = {\r\n                priority: 'high',\r\n                filter: 'blocked', // No high priority blocked tasks\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task).toBeNull();\r\n        });\r\n\r\n        it('should combine status and priority filters', async () => {\r\n            const params: GetNextTaskRequest = {\r\n                filter: 'ready',\r\n                priority: 'low',\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.priority).toBe('low');\r\n            expect(result.task?.status).toBe('ready');\r\n        });\r\n    });\r\n\r\n    describe('Priority Sorting', () => {\r\n        it('should return critical tasks before high priority', async () => {\r\n            const params1: GetNextTaskRequest = {};\r\n            const result1 = await getNextTask(params1, taskQueue);\r\n\r\n            expect(result1.task?.priority).toBe('critical');\r\n        });\r\n\r\n        it('should maintain creation time as tie-breaker', async () => {\r\n            // Add two critical tasks with different creation times\r\n            const earlier = new Date('2026-01-01T10:00:00Z');\r\n\r\n            taskQueue.addTask({\r\n                taskId: 'CRITICAL-FIRST',\r\n                title: 'Earlier critical',\r\n                description: '',\r\n                priority: 'critical',\r\n                status: 'pending',\r\n                dependencies: [],\r\n                createdAt: earlier,\r\n                updatedAt: earlier,\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            // Should return one of the critical tasks\r\n            expect(result.task?.priority).toBe('critical');\r\n        });\r\n    });\r\n\r\n    describe('Super-Detailed Prompt Generation', () => {\r\n        it('should include super detailed prompt by default', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.superDetailedPrompt).toBeDefined();\r\n            expect(result.task?.superDetailedPrompt?.description).toBeDefined();\r\n            expect(result.task?.superDetailedPrompt?.requirements).toBeDefined();\r\n            expect(result.task?.superDetailedPrompt?.acceptanceCriteria).toBeDefined();\r\n        });\r\n\r\n        it('should exclude prompt when includeDetailedPrompt is false', async () => {\r\n            const params: GetNextTaskRequest = {\r\n                includeDetailedPrompt: false,\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.superDetailedPrompt).toBeUndefined();\r\n        });\r\n\r\n        it('should include plan reference by default', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.planReference).toBeDefined();\r\n            expect(result.task?.planReference?.planId).toBeDefined();\r\n        });\r\n\r\n        it('should exclude context when includeContext is false', async () => {\r\n            const params: GetNextTaskRequest = {\r\n                includeContext: false,\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.planReference).toBeUndefined();\r\n        });\r\n\r\n        it('should generate complete super-detailed prompt structure', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            const prompt = result.task?.superDetailedPrompt;\r\n            expect(prompt).toBeDefined();\r\n\r\n            if (prompt) {\r\n                // Verify all required fields exist\r\n                expect(prompt.description).toBeDefined();\r\n                expect(prompt.context).toBeDefined();\r\n                expect(prompt.requirements).toBeInstanceOf(Array);\r\n                expect(prompt.designReferences).toBeDefined();\r\n                expect(prompt.files).toBeDefined();\r\n                expect(prompt.acceptanceCriteria).toBeInstanceOf(Array);\r\n                expect(prompt.estimatedHours).toBeGreaterThan(0);\r\n                expect(['easy', 'medium', 'hard', 'expert']).toContain(prompt.complexityLevel);\r\n                expect(prompt.skillsRequired).toBeInstanceOf(Array);\r\n\r\n                // Verify files structure\r\n                expect(prompt.files?.readFrom).toBeInstanceOf(Array);\r\n                expect(prompt.files?.writeTo).toBeInstanceOf(Array);\r\n                expect(prompt.files?.referencedIn).toBeInstanceOf(Array);\r\n\r\n                // Verify design references\r\n                expect(prompt.designReferences?.fromPlan).toBeDefined();\r\n            }\r\n        });\r\n    });\r\n\r\n    describe('Next Tasks Preview', () => {\r\n        it('should return up to 3 next tasks preview', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.nextTasksPreview.length).toBeLessThanOrEqual(3);\r\n        });\r\n\r\n        it('should not include current task in preview', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            const currentTaskId = result.task?.taskId;\r\n            const previewIds = result.nextTasksPreview.map(t => t.id);\r\n\r\n            expect(previewIds).not.toContain(currentTaskId);\r\n        });\r\n\r\n        it('should preview tasks in priority order', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            // Verify preview contains high then medium then low\r\n            if (result.nextTasksPreview.length >= 2) {\r\n                const first = result.nextTasksPreview[0];\r\n                const second = result.nextTasksPreview[1];\r\n\r\n                // More specific check would need priority values in preview\r\n                expect(first).toBeDefined();\r\n                expect(second).toBeDefined();\r\n            }\r\n        });\r\n\r\n        it('should return exactly 3 previews when 4+ tasks available', async () => {\r\n            // We already have 4 tasks in setup, so preview should have exactly 3\r\n            const params: GetNextTaskRequest = {};\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            // Current task + 3 in preview = 4 total tasks minimum\r\n            expect(result.nextTasksPreview.length).toBe(3);\r\n        });\r\n\r\n        it('should return fewer previews when less than 4 tasks total', async () => {\r\n            const smallQueue = new TaskQueue();\r\n\r\n            // Add only 2 tasks\r\n            smallQueue.addTask({\r\n                taskId: 'TASK-1',\r\n                title: 'First',\r\n                description: '',\r\n                priority: 'high',\r\n                status: 'pending',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            smallQueue.addTask({\r\n                taskId: 'TASK-2',\r\n                title: 'Second',\r\n                description: '',\r\n                priority: 'medium',\r\n                status: 'pending',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {};\r\n            const result = await getNextTask(params, smallQueue);\r\n\r\n            // Should have 1 preview (2 total - 1 current)\r\n            expect(result.nextTasksPreview.length).toBe(1);\r\n        });\r\n    });\r\n\r\n    describe('Error Handling', () => {\r\n        it('should throw error for invalid filter value', async () => {\r\n            const params: any = {\r\n                filter: 'invalid-filter',\r\n            };\r\n\r\n            await expect(getNextTask(params, taskQueue)).rejects.toThrow(MCPProtocolError);\r\n        });\r\n\r\n        it('should throw error for invalid priority value', async () => {\r\n            const params: any = {\r\n                priority: 'highest', // Invalid, should be critical/high/medium/low\r\n            };\r\n\r\n            await expect(getNextTask(params, taskQueue)).rejects.toThrow(MCPProtocolError);\r\n        });\r\n\r\n        it('should throw error for invalid includeContext type', async () => {\r\n            const params: any = {\r\n                includeContext: 'yes', // Should be boolean\r\n            };\r\n\r\n            await expect(getNextTask(params, taskQueue)).rejects.toThrow(MCPProtocolError);\r\n        });\r\n\r\n        it('should throw error when getAllTasks returns non-array', async () => {\r\n            // Create mock queue that returns invalid data\r\n            const badQueue = {\r\n                getAllTasks: () => 'not an array',\r\n            } as any;\r\n\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            await expect(getNextTask(params, badQueue)).rejects.toThrow(MCPProtocolError);\r\n        });\r\n\r\n        it('should reject unknown parameters (strict schema)', async () => {\r\n            const params: any = {\r\n                unknownParam: 'should fail',\r\n                anotherBadParam: 123,\r\n            };\r\n\r\n            await expect(getNextTask(params, taskQueue)).rejects.toThrow(MCPProtocolError);\r\n        });\r\n\r\n        it('should re-throw non-Zod validation errors', async () => {\r\n            // Create a malformed params object that will cause a non-Zod error\r\n            const params: any = {\r\n                // Valid params but we'll mock the schema to throw a different error\r\n            };\r\n\r\n            // Mock console.error to suppress error output during test\r\n            const originalError = console.error;\r\n            console.error = jest.fn();\r\n\r\n            try {\r\n                // This tests the \"throw error\" line (#247) for non-ZodError cases\r\n                // We'll use a circular reference which causes JSON serialization issues\r\n                const circular: any = { params };\r\n                circular.self = circular;\r\n\r\n                // This should trigger the catch-all error handler\r\n                await expect(\r\n                    getNextTask(circular as any, taskQueue)\r\n                ).rejects.toThrow();\r\n            } finally {\r\n                console.error = originalError;\r\n            }\r\n        });\r\n    });\r\n\r\n    describe('Complexity Detection', () => {\r\n        it('should detect complex tasks and set complexity level to hard', async () => {\r\n            // Create a new queue to avoid priority conflicts\r\n            const complexQueue = new TaskQueue();\r\n\r\n            // Add complex task with high priority\r\n            complexQueue.addTask({\r\n                taskId: 'COMPLEX-001',\r\n                title: 'Complex algorithm',\r\n                description: 'Implement complex sorting algorithm',\r\n                priority: 'critical',\r\n                status: 'pending',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, complexQueue);\r\n\r\n            // Should detect \"complex\" in description and set to 'hard'\r\n            expect(result.task?.superDetailedPrompt?.complexityLevel).toBe('hard');\r\n        });\r\n\r\n        it('should detect simple tasks and set complexity level to easy', async () => {\r\n            // Create a new queue to avoid priority conflicts\r\n            const simpleQueue = new TaskQueue();\r\n\r\n            // Add simple task  \r\n            simpleQueue.addTask({\r\n                taskId: 'SIMPLE-001',\r\n                title: 'Simple fix',\r\n                description: 'This is a simple bug fix',\r\n                priority: 'critical',\r\n                status: 'pending',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, simpleQueue);\r\n\r\n            // Should detect \"simple\" in description and set to 'easy'\r\n            expect(result.task?.superDetailedPrompt?.complexityLevel).toBe('easy');\r\n        });\r\n\r\n        it('should default to medium complexity when neither complex nor simple', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            // Should default to 'medium' when no keywords\r\n            if (result.task?.description &&\r\n                !result.task.description.toLowerCase().includes('complex') &&\r\n                !result.task.description.toLowerCase().includes('simple')) {\r\n                expect(result.task?.superDetailedPrompt?.complexityLevel).toBe('medium');\r\n            }\r\n        });\r\n    });\r\n\r\n    describe('Edge Cases', () => {\r\n        it('should handle tasks with no dependencies', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.dependencies).toBeDefined();\r\n            expect(Array.isArray(result.task?.dependencies)).toBe(true);\r\n        });\r\n\r\n        it('should handle tasks with multiple dependencies', async () => {\r\n            // Add task with dependencies\r\n            taskQueue.addTask({\r\n                taskId: 'DEP-TASK',\r\n                title: 'Dependent task',\r\n                description: '',\r\n                priority: 'medium',\r\n                status: 'pending',\r\n                dependencies: ['TASK-001', 'TASK-002', 'TASK-003'],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            // Should handle successfully\r\n            expect(result.success).toBe(true);\r\n        });\r\n\r\n        it('should handle skills requirements generation', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.superDetailedPrompt?.skillsRequired).toBeDefined();\r\n            expect(Array.isArray(result.task?.superDetailedPrompt?.skillsRequired)).toBe(true);\r\n        });\r\n\r\n        it('should generate context string with dependencies info', async () => {\r\n            // Add task with dependencies\r\n            taskQueue.addTask({\r\n                taskId: 'DEPS-TEST',\r\n                title: 'Task with deps',\r\n                description: 'Test dependencies context',\r\n                priority: 'critical',\r\n                status: 'pending',\r\n                dependencies: ['OTHER-1', 'OTHER-2'],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {};\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            // Should include dependency count in context\r\n            if (result.task?.taskId === 'DEPS-TEST' && result.task?.superDetailedPrompt) {\r\n                expect(result.task.superDetailedPrompt.context).toContain('Depends on 2 task(s)');\r\n            }\r\n        });\r\n\r\n        it('should generate context string with no dependencies info', async () => {\r\n            const params: GetNextTaskRequest = {};\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            // Find a task with no dependencies\r\n            if (result.task?.dependencies.length === 0 && result.task?.superDetailedPrompt) {\r\n                expect(result.task.superDetailedPrompt.context).toContain('No dependencies');\r\n            }\r\n        });\r\n\r\n        it('should return empty preview when only 1 task exists', async () => {\r\n            const singleQueue = new TaskQueue();\r\n            singleQueue.addTask({\r\n                taskId: 'ONLY-ONE',\r\n                title: 'Only task',\r\n                description: '',\r\n                priority: 'high',\r\n                status: 'pending',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: GetNextTaskRequest = {};\r\n            const result = await getNextTask(params, singleQueue);\r\n\r\n            expect(result.nextTasksPreview).toHaveLength(0);\r\n        });\r\n\r\n        it('should explicitly include context when includeContext is true', async () => {\r\n            const params: GetNextTaskRequest = {\r\n                includeContext: true,\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.planReference).toBeDefined();\r\n            expect(result.task?.planReference?.planId).toBe('coe-project');\r\n        });\r\n\r\n        it('should explicitly include detailed prompt when includeDetailedPrompt is true', async () => {\r\n            const params: GetNextTaskRequest = {\r\n                includeDetailedPrompt: true,\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.superDetailedPrompt).toBeDefined();\r\n        });\r\n\r\n        it('should handle all optional flags set to false', async () => {\r\n            const params: GetNextTaskRequest = {\r\n                includeContext: false,\r\n                includeDetailedPrompt: false,\r\n                includeRelatedFiles: false,\r\n            };\r\n\r\n            const result = await getNextTask(params, taskQueue);\r\n\r\n            expect(result.task?.planReference).toBeUndefined();\r\n            expect(result.task?.superDetailedPrompt).toBeUndefined();\r\n        });\r\n    });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\__tests__\\reportTaskStatus.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Testing' is defined but never used.","line":7,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MCPErrorCode' is defined but never used.","line":9,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":376,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":376,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13726,13729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13726,13729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":556,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":556,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20333,20336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20333,20336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ≡ƒº¬ Comprehensive Tests for reportTaskStatus MCP Tool\r\n *\r\n * Tests all status transitions, verification logic, and observation processing\r\n */\r\n\r\nimport { reportTaskStatus, ReportTaskStatusRequest, Testing } from '../reportTaskStatus';\r\nimport { TaskQueue, Task } from '../../../tasks/queue';\r\nimport { MCPProtocolError, MCPErrorCode } from '../../protocol';\r\n\r\ndescribe('reportTaskStatus - Comprehensive Branch Coverage', () => {\r\n    let taskQueue: TaskQueue;\r\n    let mockTask: Task;\r\n\r\n    beforeEach(() => {\r\n        taskQueue = new TaskQueue();\r\n\r\n        // Add sample task\r\n        mockTask = {\r\n            taskId: 'TASK-001',\r\n            title: 'Implement feature X',\r\n            description: 'Test task',\r\n            priority: 'high',\r\n            status: 'in-progress',\r\n            dependencies: [],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date(),\r\n        };\r\n\r\n        taskQueue.addTask(mockTask);\r\n    });\r\n\r\n    describe('Status Transitions', () => {\r\n        it('should mark task as done with successful tests', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: {\r\n                    testsAdded: true,\r\n                    testsPassed: true,\r\n                    testsFailed: 0,\r\n                },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.status).toBe('done');\r\n            expect(result.verificationTaskCreated).toBeDefined();\r\n        });\r\n\r\n        it('should mark task as failed with test failures', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'failed',\r\n                testing: {\r\n                    testsAdded: true,\r\n                    testsPassed: false,\r\n                    testsFailed: 2,\r\n                },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.status).toBe('failed');\r\n            expect(result.verificationTaskCreated).toBeUndefined();\r\n        });\r\n\r\n        it('should mark task as blocked with reason', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'blocked',\r\n                statusDetails: {\r\n                    blockedReason: 'Waiting for dependency task-002',\r\n                },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.status).toBe('blocked');\r\n        });\r\n\r\n        it('should mark task as partial with progress details', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'partial',\r\n                statusDetails: {\r\n                    progressPercent: 75,\r\n                    partiallyDone: 'Implemented 3 of 4 features',\r\n                },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.status).toBe('partial');\r\n        });\r\n    });\r\n\r\n    describe('Verification Task Creation', () => {\r\n        it('should create verification task only for done status with passed tests', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: {\r\n                    testsAdded: true,\r\n                    testsPassed: true,\r\n                    testsFailed: 0,\r\n                    accessibilityTestsPassed: true,\r\n                },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.verificationTaskCreated).toBeDefined();\r\n            expect(result.verificationTaskCreated?.title).toContain('Verify:');\r\n        });\r\n\r\n        it('should not create verification task when tests failed', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: {\r\n                    testsAdded: true,\r\n                    testsPassed: false,\r\n                    testsFailed: 3,\r\n                },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.verificationTaskCreated).toBeUndefined();\r\n        });\r\n\r\n        it('should not create verification task for failed status', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'failed',\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.verificationTaskCreated).toBeUndefined();\r\n        });\r\n\r\n        it('should set automation level based on priority', async () => {\r\n            // Critical task -> manual verification\r\n            mockTask.priority = 'critical';\r\n            taskQueue.updateTask(mockTask);\r\n\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.verificationTaskCreated?.automationLevel).toBe('manual');\r\n        });\r\n\r\n        it('should set semi-automated level for high priority', async () => {\r\n            mockTask.priority = 'high';\r\n            taskQueue.updateTask(mockTask);\r\n\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.verificationTaskCreated?.automationLevel).toBe('semi-automated');\r\n        });\r\n\r\n        it('should set automated level for medium/low priority', async () => {\r\n            mockTask.priority = 'medium';\r\n            taskQueue.updateTask(mockTask);\r\n\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.verificationTaskCreated?.automationLevel).toBe('automated');\r\n        });\r\n    });\r\n\r\n    describe('Observation Processing', () => {\r\n        it('should mark observations with critical issues as action-required', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: [\r\n                    'Found a bug in the validation logic',\r\n                    'This is an issue with error handling',\r\n                ],\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.observationsProcessed).toBeDefined();\r\n            expect(result.observationsProcessed?.length).toBe(2);\r\n            expect(result.observationsProcessed?.[0].status).toBe('action-required');\r\n        });\r\n\r\n        it('should mark observations with follow-up keywords as follow-up-created', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: [\r\n                    'Need to refactor the database layer',\r\n                    'Should add more unit tests',\r\n                    'TODO: Optimize performance',\r\n                ],\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.observationsProcessed?.length).toBe(3);\r\n            result.observationsProcessed?.forEach(obs => {\r\n                expect(obs.status).toBe('follow-up-created');\r\n            });\r\n        });\r\n\r\n        it('should mark regular observations as noted', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: ['Implementation completed on schedule'],\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.observationsProcessed?.[0].status).toBe('noted');\r\n        });\r\n\r\n        it('should prioritize follow-up over critical issues', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: [\r\n                    'There is a bug but we should refactor this',\r\n                ],\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            // Follow-up keywords take priority\r\n            expect(result.observationsProcessed?.[0].status).toBe('follow-up-created');\r\n        });\r\n    });\r\n\r\n    describe('Follow-Up Task Creation', () => {\r\n        it('should create follow-up tasks with correct dependencies', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                followUpTasks: [\r\n                    {\r\n                        title: 'Add performance tests',\r\n                        why: 'Ensure response time < 100ms',\r\n                        estimatedHours: 2,\r\n                    },\r\n                    {\r\n                        title: 'Update documentation',\r\n                        why: 'Document new API endpoints',\r\n                        estimatedHours: 1,\r\n                    },\r\n                ],\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            const allTasks = taskQueue.getAllTasks();\r\n            const followUpTasks = allTasks.filter(t => t.taskId.includes('FOLLOWUP'));\r\n            expect(followUpTasks.length).toBe(2);\r\n        });\r\n\r\n        it('should inherit priority from original task', async () => {\r\n            mockTask.priority = 'critical';\r\n            taskQueue.updateTask(mockTask);\r\n\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                followUpTasks: [\r\n                    {\r\n                        title: 'Test follow-up',\r\n                        why: 'Testing',\r\n                    },\r\n                ],\r\n            };\r\n\r\n            await reportTaskStatus(params, taskQueue);\r\n\r\n            const allTasks = taskQueue.getAllTasks();\r\n            const followUpTask = allTasks.find(t => t.taskId.includes('FOLLOWUP'));\r\n            expect(followUpTask?.priority).toBe('high'); // Critical -> high for follow-ups\r\n        });\r\n    });\r\n\r\n    describe('Dashboard Statistics', () => {\r\n        it('should calculate correct completion percentages', async () => {\r\n            // Add more tasks\r\n            taskQueue.addTask({\r\n                taskId: 'TASK-002',\r\n                title: 'Task 2',\r\n                description: '',\r\n                priority: 'medium',\r\n                status: 'done',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.dashboardUpdate?.completedCount).toBeGreaterThan(0);\r\n            expect(result.dashboardUpdate?.totalCount).toBeGreaterThan(0);\r\n            expect(result.dashboardUpdate?.percentComplete).toBeGreaterThan(0);\r\n        });\r\n\r\n        it('should count blocked tasks correctly', async () => {\r\n            const blockedTask: Task = {\r\n                taskId: 'TASK-BLOCKED',\r\n                title: 'Blocked task',\r\n                description: '',\r\n                priority: 'medium',\r\n                status: 'blocked',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            };\r\n\r\n            taskQueue.addTask(blockedTask);\r\n\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.dashboardUpdate?.blockedCount).toBe(1);\r\n        });\r\n\r\n        it('should identify verification pending tasks', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            // Should have at least 1 verification pending task created\r\n            expect(result.dashboardUpdate?.verificationPendingCount).toBeGreaterThanOrEqual(1);\r\n        });\r\n    });\r\n\r\n    describe('Error Handling', () => {\r\n        it('should return error for invalid parameters', async () => {\r\n            const params: any = {\r\n                taskId: 'TASK-001',\r\n                status: 'invalid-status', // Invalid status\r\n            };\r\n\r\n            await expect(reportTaskStatus(params, taskQueue)).rejects.toThrow(MCPProtocolError);\r\n        });\r\n\r\n        it('should return error for task not found', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-NONEXISTENT',\r\n                status: 'done',\r\n            };\r\n\r\n            await expect(reportTaskStatus(params, taskQueue)).rejects.toThrow(MCPProtocolError);\r\n        });\r\n\r\n        it('should handle empty observations array', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: [],\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.observationsProcessed).toBeUndefined();\r\n            expect(result.success).toBe(true);\r\n        });\r\n\r\n        it('should handle empty follow-up tasks array', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                followUpTasks: [],\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n        });\r\n    });\r\n\r\n    describe('Idempotent Operations', () => {\r\n        it('should handle repeated done status updates', async () => {\r\n            // Mark as done first\r\n            await reportTaskStatus(\r\n                {\r\n                    taskId: 'TASK-001',\r\n                    status: 'done',\r\n                    testing: { testsAdded: true, testsPassed: true, testsFailed: 0 },\r\n                },\r\n                taskQueue\r\n            );\r\n\r\n            // Mark as done again - should not throw error\r\n            const result = await reportTaskStatus(\r\n                {\r\n                    taskId: 'TASK-001',\r\n                    status: 'done',\r\n                    testing: { testsAdded: true, testsPassed: true, testsFailed: 0 },\r\n                },\r\n                taskQueue\r\n            );\r\n\r\n            expect(result.success).toBe(true);\r\n        });\r\n    });\r\n\r\n    describe('Complex Scenarios', () => {\r\n        it('should handle complete task completion flow', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                implementationNotes: 'Successfully implemented feature X',\r\n                filesModified: ['src/app.ts', 'tests/app.test.ts'],\r\n                testing: {\r\n                    testsAdded: true,\r\n                    testFileCreated: 'tests/app.test.ts',\r\n                    testsPassed: true,\r\n                    testsFailed: 0,\r\n                    testCoveragePercent: 92,\r\n                    accessibilityTestsPassed: true,\r\n                },\r\n                acceptanceCriteriaVerification: {\r\n                    '0': { text: 'Feature works as specified', status: 'passed' },\r\n                    '1': { text: 'No regression issues', status: 'passed' },\r\n                },\r\n                observations: [\r\n                    'Found opportunity to refactor validation',\r\n                    'Performance could be optimized',\r\n                ],\r\n                followUpTasks: [\r\n                    {\r\n                        title: 'Refactor validation logic',\r\n                        why: 'Improve code maintainability',\r\n                        estimatedHours: 3,\r\n                    },\r\n                ],\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.verificationTaskCreated).toBeDefined();\r\n            expect(result.observationsProcessed?.length).toBeGreaterThan(0);\r\n            expect(result.dashboardUpdate).toBeDefined();\r\n            expect(result.nextTaskId).toBeDefined();\r\n        });\r\n\r\n        it('should find next available task excluding current', async () => {\r\n            // Add a ready task\r\n            taskQueue.addTask({\r\n                taskId: 'TASK-NEXT',\r\n                title: 'Next task',\r\n                description: '',\r\n                priority: 'medium',\r\n                status: 'ready',\r\n                dependencies: [],\r\n                createdAt: new Date(),\r\n                updatedAt: new Date(),\r\n            });\r\n\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            // Should suggest the next ready task\r\n            expect(result.nextTaskPreview).toBeDefined();\r\n            expect(result.nextTaskPreview?.title).toBeDefined();\r\n        });\r\n    });\r\n\r\n    describe('Testing Details Coverage', () => {\r\n        it('should include test coverage percentage when provided', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: {\r\n                    testsAdded: true,\r\n                    testsPassed: true,\r\n                    testsFailed: 0,\r\n                    testCoveragePercent: 95,\r\n                    failedTestNames: [],\r\n                },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.message).toContain('marked done');\r\n        });\r\n\r\n        it('should handle failed test names', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'failed',\r\n                testing: {\r\n                    testsAdded: true,\r\n                    testsPassed: false,\r\n                    testsFailed: 2,\r\n                    failedTestNames: [\r\n                        'should validate email format',\r\n                        'should reject empty strings',\r\n                    ],\r\n                },\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.status).toBe('failed');\r\n        });\r\n    });\r\n\r\n    describe('Branch Coverage: Error Handling & Edge Cases', () => {\r\n        it('should throw MCPProtocolError for invalid taskId format', async () => {\r\n            const params: any = {\r\n                taskId: '', // Empty taskId\r\n                status: 'done'\r\n            };\r\n\r\n            await expect(reportTaskStatus(params, taskQueue)).rejects.toThrow();\r\n        });\r\n\r\n        it('should throw error when task is not found', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'NON-EXISTENT-ID',\r\n                status: 'done'\r\n            };\r\n\r\n            await expect(reportTaskStatus(params, taskQueue)).rejects.toThrow('Task NON-EXISTENT-ID not found');\r\n        });\r\n\r\n        it('should not create verification task when status is not done', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'blocked',\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.verificationTaskCreated).toBeUndefined();\r\n        });\r\n\r\n        it('should not create verification task when tests failed even if status is done', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: { testsAdded: true, testsPassed: false, testsFailed: 5 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.verificationTaskCreated).toBeUndefined();\r\n        });\r\n\r\n        it('should handle observations with no follow-up needed', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: ['Simple observation without keywords'],\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.observationsProcessed).toBeDefined();\r\n            expect(result.observationsProcessed![0].status).toBe('noted');\r\n        });\r\n\r\n        it('should detect critical issues in observations', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: ['Found a critical error in the code'],\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.observationsProcessed![0].status).toBe('action-required');\r\n        });\r\n\r\n        it('should detect error mentions in observations', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: ['Encountered an error during runtime'],\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.observationsProcessed![0].status).toBe('action-required');\r\n        });\r\n\r\n        it('should process multiple observations correctly', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: [\r\n                    'Normal observation',\r\n                    'Critical issue found',\r\n                    'Another normal note'\r\n                ],\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.observationsProcessed).toHaveLength(3);\r\n            expect(result.observationsProcessed![0].status).toBe('noted');\r\n            expect(result.observationsProcessed![1].status).toBe('action-required');\r\n            expect(result.observationsProcessed![2].status).toBe('noted');\r\n        });\r\n\r\n        it('should handle empty observations array', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                observations: [],\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            // Empty observations array should result in undefined observationsProcessed\r\n            expect(result.observationsProcessed).toBeUndefined();\r\n        });\r\n\r\n        it('should create follow-up tasks when provided', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                followUpTasks: [\r\n                    { title: 'Follow-up 1', why: 'Reason 1', estimatedHours: 2 },\r\n                    { title: 'Follow-up 2', why: 'Reason 2', estimatedHours: 3 }\r\n                ],\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n        });\r\n\r\n        it('should handle empty follow-up tasks array', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                followUpTasks: [],\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n        });\r\n\r\n        it('should handle blocked status with blocking reason', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'blocked',\r\n                statusDetails: {\r\n                    blockedReason: 'Waiting for dependency TASK-002'\r\n                }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.status).toBe('blocked');\r\n            expect(result.success).toBe(true);\r\n        });\r\n\r\n        it('should handle partial status with progress percentage', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'partial',\r\n                statusDetails: {\r\n                    progressPercent: 60,\r\n                    partiallyDone: '3 out of 5 features completed'\r\n                }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.status).toBe('partial');\r\n            expect(result.success).toBe(true);\r\n        });\r\n\r\n        it('should update dashboard metrics', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.dashboardUpdate).toBeDefined();\r\n            expect(result.dashboardUpdate?.completedCount).toBeGreaterThan(0);\r\n        });\r\n\r\n        it('should handle task with no testing information', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done'\r\n                // No testing field\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n            expect(result.verificationTaskCreated).toBeDefined(); // Should still create verification\r\n        });\r\n\r\n        it('should handle implementation notes in status details', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                implementationNotes: 'Used React hooks instead of class components',\r\n                filesModified: ['src/App.tsx', 'src/components/Button.tsx'],\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n        });\r\n\r\n        it('should handle acceptance criteria verification', async () => {\r\n            const params: ReportTaskStatusRequest = {\r\n                taskId: 'TASK-001',\r\n                status: 'done',\r\n                acceptanceCriteriaVerification: {\r\n                    0: { text: 'Feature implemented', status: 'passed' },\r\n                    1: { text: 'Tests added', status: 'passed' }\r\n                },\r\n                testing: { testsAdded: true, testsPassed: true, testsFailed: 0 }\r\n            };\r\n\r\n            const result = await reportTaskStatus(params, taskQueue);\r\n\r\n            expect(result.success).toBe(true);\r\n        });\r\n    });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\askQuestion.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used.","line":130,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":130,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'searchTerm' is defined but never used.","line":131,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":131,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MCP Tool: askQuestion\r\n * Routes questions to Answer Team for context-aware responses from plan and codebase\r\n * \r\n * Purpose:\r\n * - Provides answers from plan.json and documentation\r\n * - Returns confidence-scored responses with evidence\r\n * - Includes implementation guidance and examples\r\n * - Surfaces related design decisions\r\n * \r\n * References:\r\n * - Plans/COE-Master-Plan/05-MCP-API-Reference.md (Tool 3: askQuestion)\r\n */\r\n\r\nimport { z } from 'zod';\r\nimport { MCPErrorCode, MCPProtocolError } from '../protocol';\r\n\r\n// ============================================================================\r\n// Request/Response Schemas (Zod Validation)\r\n// ============================================================================\r\n\r\n/**\r\n * Request schema for askQuestion\r\n */\r\nexport const AskQuestionRequestSchema = z.object({\r\n    question: z.string().min(1, 'Question cannot be empty'),\r\n    context: z.string().optional(),\r\n    currentTaskId: z.string().optional(),\r\n    searchInPlan: z.string().optional(),\r\n    includeRelatedDecisions: z.boolean().optional(),\r\n});\r\n\r\nexport type AskQuestionRequest = z.infer<typeof AskQuestionRequestSchema>;\r\n\r\n/**\r\n * Evidence from plan or codebase\r\n */\r\nexport interface Evidence {\r\n    source: string;\r\n    planVersion: string;\r\n    section: string;\r\n    exactQuote?: string;\r\n    lineNumbers?: number[];\r\n}\r\n\r\n/**\r\n * Implementation guidance\r\n */\r\nexport interface Guidance {\r\n    implementation?: string;\r\n    animation?: string;\r\n    accessibility?: string;\r\n    examples?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Related decision structure\r\n */\r\nexport interface Decision {\r\n    id: string;\r\n    title: string;\r\n    decision: string;\r\n    rationale: string;\r\n}\r\n\r\n/**\r\n * Response schema for askQuestion\r\n */\r\nexport interface AskQuestionResponse {\r\n    success: boolean;\r\n    question: string;\r\n    answerFromPlan?: string;\r\n    confidence: number; // 0.0 - 1.0\r\n\r\n    evidence?: Evidence;\r\n    guidance?: Guidance;\r\n    relatedDesignChoices?: string[];\r\n    relatedDecisions?: Decision[];\r\n    uncertainty?: string; // Explanation if confidence < 0.7\r\n}\r\n\r\n// ============================================================================\r\n// Question Analysis\r\n// ============================================================================\r\n\r\n/**\r\n * Analyze question and extract key topics\r\n */\r\nfunction extractTopics(question: string): string[] {\r\n    const lowercaseQuestion = question.toLowerCase();\r\n    const topics: string[] = [];\r\n\r\n    // Common topics\r\n    const topicPatterns = {\r\n        'responsive': /responsive|mobile|tablet|desktop|breakpoint/i,\r\n        'accessibility': /accessibility|a11y|wcag|aria|screen reader/i,\r\n        'animation': /animation|transition|motion|animate/i,\r\n        'styling': /color|style|css|theme|font|typography/i,\r\n        'navigation': /navigation|nav|sidebar|menu|routing/i,\r\n        'state': /state|data|store|redux|context/i,\r\n        'testing': /test|testing|jest|spec|coverage/i,\r\n        'performance': /performance|optimize|speed|lazy|cache/i,\r\n    };\r\n\r\n    for (const [topic, pattern] of Object.entries(topicPatterns)) {\r\n        if (pattern.test(lowercaseQuestion)) {\r\n            topics.push(topic);\r\n        }\r\n    }\r\n\r\n    return topics;\r\n}\r\n\r\n// ============================================================================\r\n// Answer Generation (Mock Implementation)\r\n// ============================================================================\r\n\r\n/**\r\n * Generate answer from plan (simplified mock implementation)\r\n * \r\n * TODO: In production, this would:\r\n * 1. Parse plan.json from workspace\r\n * 2. Search design choices, decisions, and requirements\r\n * 3. Use vector search or fuzzy matching\r\n * 4. Extract relevant sections\r\n * 5. Build contextualized answer\r\n */\r\nfunction generateAnswerFromPlan(\r\n    question: string,\r\n    context?: string,\r\n    searchTerm?: string\r\n): {\r\n    answer?: string;\r\n    confidence: number;\r\n    evidence?: Evidence;\r\n    guidance?: Guidance;\r\n    relatedChoices?: string[];\r\n    uncertainty?: string;\r\n} {\r\n    const topics = extractTopics(question);\r\n\r\n    // Mock responses based on detected topics\r\n    // In production, this would search actual plan.json\r\n\r\n    if (topics.includes('responsive')) {\r\n        return {\r\n            answer: 'Based on the design system, use responsive breakpoints: Mobile (0-767px), Tablet (768-1023px), Desktop (1024px+). Components should collapse or stack on mobile.',\r\n            confidence: 0.95,\r\n            evidence: {\r\n                source: 'PRD.md / Design System',\r\n                planVersion: '1.0.0',\r\n                section: 'Design Choices > Responsive Behavior',\r\n                exactQuote: 'Use mobile-first approach with breakpoints at 768px and 1024px',\r\n            },\r\n            guidance: {\r\n                implementation: 'Use CSS media queries with mobile-first approach: @media (min-width: 768px) for tablet, @media (min-width: 1024px) for desktop',\r\n                examples: {\r\n                    'mediaQuery': '@media (max-width: 767px) { /* Mobile styles */ }',\r\n                },\r\n            },\r\n            relatedChoices: [\r\n                'Breakpoints: Mobile 0-767px, Tablet 768-1023px, Desktop 1024px+',\r\n                'Mobile-first design approach',\r\n            ],\r\n        };\r\n    }\r\n\r\n    if (topics.includes('accessibility')) {\r\n        return {\r\n            answer: 'All UI components must meet WCAG AA standards (minimum 4.5:1 contrast ratio). Include aria-labels, keyboard navigation, and screen reader support.',\r\n            confidence: 0.92,\r\n            evidence: {\r\n                source: 'PRD.md / Accessibility Requirements',\r\n                planVersion: '1.0.0',\r\n                section: 'Non-Functional Requirements > Accessibility',\r\n            },\r\n            guidance: {\r\n                accessibility: 'Use semantic HTML, add ARIA attributes where needed, ensure keyboard navigation works, test with screen readers',\r\n                examples: {\r\n                    'ariaLabel': '<button aria-label=\"Close menu\">X</button>',\r\n                    'keyboardNav': 'onKeyDown={(e) => e.key === \"Enter\" && handleClick()}',\r\n                },\r\n            },\r\n            relatedChoices: [\r\n                'WCAG AA compliance required',\r\n                'Keyboard navigation support',\r\n                'Screen reader compatibility',\r\n            ],\r\n        };\r\n    }\r\n\r\n    if (topics.includes('testing')) {\r\n        return {\r\n            answer: 'Maintain ΓëÑ80% test coverage for all new code (ΓëÑ90% for critical components). Use Jest for unit tests and integration tests.',\r\n            confidence: 0.88,\r\n            evidence: {\r\n                source: 'PRD.md / Testing Standards',\r\n                planVersion: '1.0.0',\r\n                section: 'Quality Standards > Testing',\r\n            },\r\n            guidance: {\r\n                implementation: 'Write tests before marking tasks complete. Cover happy path, edge cases, and error scenarios.',\r\n                examples: {\r\n                    'testStructure': 'describe(\"Component\", () => { it(\"should render\", () => {...}); });',\r\n                },\r\n            },\r\n            relatedChoices: [\r\n                'Test coverage: ΓëÑ80% (ΓëÑ90% for P1 tasks)',\r\n                'Jest for unit/integration tests',\r\n            ],\r\n        };\r\n    }\r\n\r\n    if (topics.includes('animation')) {\r\n        return {\r\n            answer: 'Use CSS transitions and animations for simple effects (200ms duration). For complex interactions, use animation libraries compatible with the design system. All animations should be smooth (60fps target) and respectful of motion preferences.',\r\n            confidence: 0.85,\r\n            evidence: {\r\n                source: 'PRD.md / Design System',\r\n                planVersion: '1.0.0',\r\n                section: 'Design Choices > Animation & Transitions',\r\n                exactQuote: 'Use CSS transitions for animations with 200ms timing function',\r\n            },\r\n            guidance: {\r\n                animation: 'Use CSS transition property for simple animations: transition: all 200ms ease-in-out; Consider prefers-reduced-motion for accessibility.',\r\n                examples: {\r\n                    'cssTransition': '.component { transition: all 200ms ease-in-out; } .component:hover { transform: scale(1.05); }',\r\n                    'accessibility': '@media (prefers-reduced-motion: reduce) { * { animation-duration: 0ms !important; } }',\r\n                },\r\n            },\r\n            relatedChoices: [\r\n                'Animation timing: 200ms standard duration',\r\n                'Must respect prefers-reduced-motion',\r\n                'Target 60fps performance',\r\n            ],\r\n        };\r\n    }\r\n\r\n    // Default low-confidence response\r\n    return {\r\n        confidence: 0.35,\r\n        uncertainty: `The plan doesn't specifically address \"${question}\". This may need to be decided based on project requirements or team preferences. Consider checking existing codebase patterns or consulting with the team.`,\r\n        guidance: {\r\n            implementation: 'Review existing implementations in the codebase for similar patterns, or propose a solution based on best practices.',\r\n        },\r\n    };\r\n}\r\n\r\n/**\r\n * Find related decisions based on topics\r\n */\r\nfunction findRelatedDecisions(topics: string[]): Decision[] {\r\n    // Mock implementation\r\n    // In production, would search actual decisions from plan.json\r\n\r\n    const decisions: Decision[] = [];\r\n\r\n    if (topics.includes('styling') || topics.includes('animation')) {\r\n        decisions.push({\r\n            id: 'DEC-001',\r\n            title: 'Use CSS-in-JS vs Traditional CSS',\r\n            decision: 'Use CSS Modules for component styling',\r\n            rationale: 'Provides scoping without runtime overhead, compatible with existing tooling',\r\n        });\r\n    }\r\n\r\n    if (topics.includes('state')) {\r\n        decisions.push({\r\n            id: 'DEC-002',\r\n            title: 'State Management Approach',\r\n            decision: 'Use React Context for global state, local state for components',\r\n            rationale: 'Simpler than Redux for current requirements, can migrate later if needed',\r\n        });\r\n    }\r\n\r\n    return decisions;\r\n}\r\n\r\n// ============================================================================\r\n// Main Tool Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * askQuestion MCP Tool\r\n * \r\n * Routes questions to Answer Team and returns context-aware responses.\r\n * \r\n * @param params - Request parameters (question, context, etc.)\r\n * @returns AskQuestionResponse with answer and confidence level\r\n */\r\nexport async function askQuestion(\r\n    params: Record<string, unknown>\r\n): Promise<AskQuestionResponse> {\r\n    // Validate request parameters\r\n    let validatedParams: AskQuestionRequest;\r\n    try {\r\n        validatedParams = AskQuestionRequestSchema.parse(params);\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            throw new MCPProtocolError(\r\n                MCPErrorCode.INVALID_PARAMS,\r\n                `Invalid parameters: ${error.errors.map(e => e.message).join(', ')}`,\r\n                { zodErrors: error.errors }\r\n            );\r\n        }\r\n        throw error;\r\n    }\r\n\r\n    // Extract topics from question\r\n    const topics = extractTopics(validatedParams.question);\r\n\r\n    // Generate answer from plan\r\n    const answerData = generateAnswerFromPlan(\r\n        validatedParams.question,\r\n        validatedParams.context,\r\n        validatedParams.searchInPlan\r\n    );\r\n\r\n    // Find related decisions if requested\r\n    let relatedDecisions: Decision[] | undefined;\r\n    if (validatedParams.includeRelatedDecisions !== false) {\r\n        relatedDecisions = findRelatedDecisions(topics);\r\n        if (relatedDecisions.length === 0) {\r\n            relatedDecisions = undefined; // Don't include empty array\r\n        }\r\n    }\r\n\r\n    // Build response\r\n    const response: AskQuestionResponse = {\r\n        success: true,\r\n        question: validatedParams.question,\r\n        confidence: answerData.confidence,\r\n    };\r\n\r\n    // Add answer if confidence is reasonable\r\n    if (answerData.answer) {\r\n        response.answerFromPlan = answerData.answer;\r\n    }\r\n\r\n    // Add evidence if available\r\n    if (answerData.evidence) {\r\n        response.evidence = answerData.evidence;\r\n    }\r\n\r\n    // Add guidance\r\n    if (answerData.guidance) {\r\n        response.guidance = answerData.guidance;\r\n    }\r\n\r\n    // Add related design choices\r\n    if (answerData.relatedChoices && answerData.relatedChoices.length > 0) {\r\n        response.relatedDesignChoices = answerData.relatedChoices;\r\n    }\r\n\r\n    // Add related decisions\r\n    if (relatedDecisions) {\r\n        response.relatedDecisions = relatedDecisions;\r\n    }\r\n\r\n    // Add uncertainty explanation for low confidence\r\n    if (answerData.confidence < 0.7) {\r\n        response.uncertainty = answerData.uncertainty ||\r\n            'The answer has low confidence. Additional context or clarification may be needed.';\r\n    }\r\n\r\n    return response;\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\getErrors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\getNextTask.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\index.web.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\reportObservation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\reportTaskStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\reportTestFailure.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\mcpServer\\tools\\reportVerificationResult.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\orchestrator\\logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[244,247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[244,247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[290,293],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[290,293],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[336,339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[336,339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[392,395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[392,395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is defined but never used.","line":19,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is defined but never used.","line":19,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":38},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[551,554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[551,554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[607,610],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[607,610],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is defined but never used.","line":26,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is defined but never used.","line":26,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[719,722],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[719,722],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is defined but never used.","line":29,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":29,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":47},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[785,788],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[785,788],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Logger Interface for Programming Orchestrator\r\n * \r\n * Provides structured logging for the orchestration system\r\n * References: Plans/MODULAR-EXECUTION-PHILOSOPHY.md\r\n */\r\n\r\nexport interface ILogger {\r\n    debug(message: string, data?: any): void;\r\n    info(message: string, data?: any): void;\r\n    warn(message: string, data?: any): void;\r\n    error(message: string, error?: Error | any): void;\r\n}\r\n\r\n/**\r\n * Default logger implementation using console\r\n */\r\nexport class ConsoleLogger implements ILogger {\r\n    debug(message: string, data?: any): void {\r\n    }\r\n\r\n    info(message: string, data?: any): void {\r\n        console.info(`[INFO] ${message}`, data || '');\r\n    }\r\n\r\n    warn(message: string, data?: any): void {\r\n    }\r\n\r\n    error(message: string, error?: Error | any): void {\r\n    }\r\n}\r\n\r\n/**\r\n * No-op logger for testing/mocking\r\n */\r\nexport class NullLogger implements ILogger {\r\n    debug(): void { }\r\n    info(): void { }\r\n    warn(): void { }\r\n    error(): void { }\r\n}\r\n\r\n// Default instance\r\nexport const defaultLogger = new ConsoleLogger();\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\orchestrator\\programmingOrchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'planId' is defined but never used.","line":200,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":200,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filter' is defined but never used.","line":200,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":200,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'output' is defined but never used.","line":204,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":204,"endColumn":79},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":257,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10266,10269],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10266,10269],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":258,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10366,10369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10366,10369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":295,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":295,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11871,11874],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11871,11874],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":306,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12207,12210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12207,12210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":349,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":349,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13491,13494],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13491,13494],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'t' is defined but never used.","line":445,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":445,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is assigned a value but never used.","line":566,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":566,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is defined but never used.","line":1420,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1420,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'args' is defined but never used.","line":1420,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":1420,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is defined but never used.","line":1423,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1423,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'args' is defined but never used.","line":1423,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":1423,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'safeArgs' is assigned a value but never used.","line":1428,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":1428,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'message' is defined but never used.","line":1436,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":1436,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'args' is defined but never used.","line":1436,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":1436,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Programming Orchestrator - Dedicated Coding Director\r\n * \r\n * This is the **sole job** of orchestrating and directing the Coding AI (GitHub Copilot)\r\n * based on Planning Team outputs. It has **strict separation** from Planning, Answering, \r\n * and Verification teams.\r\n * \r\n * Architecture Principles:\r\n * - Pulls pre-decomposed tasks from Planning Team queue\r\n * - Routes tasks to Coding AI with super-detailed prompts (under 3000 tokens)\r\n * - Monitors progress via MCP tools\r\n * - Routes clarifications to Answer Team\r\n * - Reports completion back to orchestration queue\r\n * - Enforces \"one thing at a time\" modular execution\r\n * \r\n * References:\r\n * - Plans/COE-Master-Plan/02-Agent-Role-Definitions.md (Agent 1: Programming Orchestrator)\r\n * - Plans/MODULAR-EXECUTION-PHILOSOPHY.md (One-thing-at-a-time enforcement)\r\n * - Plans/COE-Master-Plan/05-MCP-API-Reference.md (MCP tool specifications)\r\n * - Plans/COE-Master-Plan/10-MCP-Error-Codes-Registry.md (Error codes)\r\n * \r\n * @version 1.0.0\r\n * @author Copilot Orchestration Extension Team\r\n */\r\n\r\nimport { z } from 'zod';\r\nimport * as vscode from 'vscode';\r\nimport { TicketDatabase } from '../db/ticketsDb';\r\n\r\n// ============================================================================\r\n// Logger Interface\r\n// ============================================================================\r\n\r\n/**\r\n * ≡ƒô¥ Logger Interface\r\n * Provides logging capabilities for the orchestrator\r\n */\r\ninterface ILogger {\r\n    info(message: string, ...args: unknown[]): void;\r\n    warn(message: string, ...args: unknown[]): void;\r\n    error(message: string, ...args: unknown[]): void;\r\n    debug(message: string, ...args: unknown[]): void;\r\n}\r\n\r\n// ============================================================================\r\n// Type Definitions & Validation\r\n// ============================================================================\r\n\r\n/**\r\n * ≡ƒÄ» Task Priority Enumeration\r\n * Strictly adheres to Copilot Orchestration Extension priority scheme\r\n */\r\nexport enum TaskPriority {\r\n    P1 = 'P1',  // Critical launch blockers (HIGHEST)\r\n    P2 = 'P2',  // High priority, important features\r\n    P3 = 'P3',  // Medium priority, nice-to-have\r\n}\r\n\r\n/**\r\n * ≡ƒöä Task Status Enumeration\r\n * Tracks task progression through execution lifecycle\r\n */\r\nexport enum TaskStatus {\r\n    PENDING = 'pending',           // Waiting in queue\r\n    READY = 'ready',               // All dependencies met\r\n    IN_PROGRESS = 'in-progress',   // Currently being executed by Copilot\r\n    COMPLETED = 'completed',       // Done, awaiting verification\r\n    BLOCKED = 'blocked',           // Dependency failure or Copilot blocked\r\n    FAILED = 'failed',             // Execution failed\r\n}\r\n\r\n/**\r\n * ≡ƒÄü Task Data Model (from Planning Team)\r\n * Represents a pre-decomposed, atomic task from the Planning Team\r\n */\r\nexport const TaskSchema = z.object({\r\n    taskId: z.string().min(1, 'Task ID is required'),\r\n    title: z.string().min(1, 'Title is required').max(200, 'Title must be under 200 chars'),\r\n    description: z.string().min(10, 'Description must be at least 10 chars'),\r\n    priority: z.nativeEnum(TaskPriority),\r\n    status: z.nativeEnum(TaskStatus),\r\n    dependencies: z.array(z.string()).default([]),\r\n    blockedBy: z.array(z.string()).default([]),\r\n    estimatedHours: z.number().positive().default(1),\r\n    acceptanceCriteria: z.array(z.string()).min(1, 'Must have acceptance criteria'),\r\n    relatedFiles: z.array(z.string()).optional(),\r\n    designReferences: z.record(z.unknown()).optional(),\r\n    contextBundle: z.string().optional(), // Pre-computed context (under 3000 tokens)\r\n    fromPlanningTeam: z.boolean().default(true), // CRITICAL: Must come from Planning Team\r\n    createdAt: z.date().optional(),\r\n    assignedTo: z.string().optional(),\r\n    metadata: z.object({\r\n        ticketId: z.string().optional(),\r\n        routedTeam: z.string().optional(),\r\n        routingReason: z.string().optional(),\r\n        routingConfidence: z.number().optional(),\r\n        isEscalated: z.boolean().optional()\r\n    }).optional() // Optional metadata for ticket-routed tasks\r\n});\r\n\r\nexport type Task = z.infer<typeof TaskSchema>;\r\n\r\n/**\r\n * ∩┐╜ Persisted Task Format\r\n * Minimal task data for storage (excludes large fields like contextBundle)\r\n */\r\nexport interface PersistedTask {\r\n    taskId: string;\r\n    title: string;\r\n    description: string;\r\n    priority: TaskPriority;\r\n    status: TaskStatus;\r\n    dependencies: string[];\r\n    blockedBy: string[];\r\n    estimatedHours: number;\r\n    acceptanceCriteria: string[];\r\n    relatedFiles?: string[];\r\n    assignedTo?: string;\r\n    metadata?: {\r\n        ticketId?: string;\r\n        routedTeam?: string;\r\n        routingReason?: string;\r\n        routingConfidence?: number;\r\n        isEscalated?: boolean;\r\n    };\r\n    createdAt: string;\r\n}\r\n\r\n/**\r\n * ∩┐╜≡ƒôï Routing Directive (sent to Coding AI/Copilot)\r\n * Super-detailed prompt for Copilot with task context bundled together\r\n */\r\nexport const RoutingDirectiveSchema = z.object({\r\n    taskId: z.string(),\r\n    title: z.string(),\r\n    description: z.string(),\r\n    acceptanceCriteria: z.array(z.string()),\r\n    contextBundle: z.string(), // Pre-computed, token-limited context\r\n    relatedFiles: z.array(z.string()),\r\n    designReferences: z.record(z.unknown()).optional(),\r\n    estimatedHours: z.number(),\r\n    priority: z.nativeEnum(TaskPriority),\r\n    promptVersion: z.literal('1.0').default('1.0'),\r\n});\r\n\r\nexport type RoutingDirective = z.infer<typeof RoutingDirectiveSchema>;\r\n\r\n/**\r\n * MCP Tool Response Schema\r\n * Standard response format for all MCP tool calls\r\n */\r\nexport const MCPToolResponseSchema = z.object({\r\n    success: z.boolean(),\r\n    data: z.unknown().optional(),\r\n    error: z.object({\r\n        code: z.string(),\r\n        message: z.string(),\r\n        severity: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']),\r\n        retryable: z.boolean().default(false),\r\n    }).optional(),\r\n});\r\n\r\nexport type MCPToolResponse = z.infer<typeof MCPToolResponseSchema>;\r\n\r\n/**\r\n * ≡ƒöÉ MCP Error Codes (from Plan/COE-Master-Plan/10-MCP-Error-Codes-Registry.md)\r\n * Standardized error codes for orchestrator failures\r\n */\r\nexport enum MCPErrorCode {\r\n    INVALID_STATE = 'INVALID_STATE',                    // No tasks ready\r\n    INVALID_PARAM = 'INVALID_PARAM',                    // Bad input validation\r\n    TOKEN_LIMIT_EXCEEDED = 'TOKEN_LIMIT_EXCEEDED',      // Context too large\r\n    TIMEOUT = 'TIMEOUT',                                // Copilot unresponsive\r\n    RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND',          // Task not found\r\n    DELEGATION_FAILED = 'DELEGATION_FAILED',            // Copilot handoff failed\r\n    LOOP_DETECTED = 'LOOP_DETECTED',                    // Infinite blocking loop\r\n    INTERNAL_ERROR = 'INTERNAL_ERROR',                  // Orchestrator internal error\r\n}\r\n\r\n// ============================================================================\r\n// MCP Interface\r\n// ============================================================================\r\n\r\n/**\r\n * ≡ƒÄ» MCP Tool Callable Interface\r\n * Defines contract for MCP tool invocation\r\n */\r\nexport interface MCPToolInterface {\r\n    getNextTask(planId: string, filter?: string): Promise<MCPToolResponse>;\r\n    reportTaskStatus(taskId: string, status: TaskStatus, output?: string): Promise<MCPToolResponse>;\r\n    askQuestion(question: string, context: Record<string, unknown>): Promise<MCPToolResponse>;\r\n    reportObservation(taskId: string, observation: string): Promise<MCPToolResponse>;\r\n    reportVerificationResult(taskId: string, passed: boolean, details?: string): Promise<MCPToolResponse>;\r\n}\r\n\r\n/**\r\n * ≡ƒÅù∩╕Å Mock MCP Tool Interface (for testing without real MCP server)\r\n */\r\nexport class MockMCPTools implements MCPToolInterface {\r\n    async getNextTask(planId: string, filter?: string): Promise<MCPToolResponse> {\r\n        return { success: true, data: null };\r\n    }\r\n\r\n    async reportTaskStatus(taskId: string, status: TaskStatus, output?: string): Promise<MCPToolResponse> {\r\n        return { success: true, data: { taskId, status } };\r\n    }\r\n\r\n    async askQuestion(question: string, context: Record<string, unknown>): Promise<MCPToolResponse> {\r\n        return { success: true, data: { answer: 'Mock response', context } };\r\n    }\r\n\r\n    async reportObservation(taskId: string, observation: string): Promise<MCPToolResponse> {\r\n        return { success: true, data: { taskId, observation } };\r\n    }\r\n\r\n    async reportVerificationResult(taskId: string, passed: boolean, details?: string): Promise<MCPToolResponse> {\r\n        return { success: true, data: { taskId, passed, details } };\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Programming Orchestrator Class\r\n// ============================================================================\r\n\r\n/**\r\n * ≡ƒÄ¡ Programming Orchestrator\r\n * \r\n * **Sole Responsibility**: Orchestrate and direct the Coding AI (GitHub Copilot)\r\n * based on Planning Team outputs.\r\n * \r\n * **What it does**:\r\n * - Pulls pre-decomposed tasks from Planning Team queue\r\n * - Prepares super-detailed prompts for Copilot (under 3000 tokens)\r\n * - Routes tasks to Coding AI with full context\r\n * - Monitors progress and detects blocks\r\n * - Routes clarifications to Answer Team via MCP\r\n * - Reports completion status back to orchestration queue\r\n * - Enforces strict \"one thing at a time\" execution\r\n * \r\n * **What it does NOT do** (strict separation):\r\n * - Γ¥î Never generates plans (Planning Team's job)\r\n * - Γ¥î Never answers questions directly (Answer Team's job)\r\n * - Γ¥î Never verifies code quality (Verification Team's job)\r\n * - Γ¥î Never executes code itself\r\n */\r\nexport class ProgrammingOrchestrator {\r\n    private taskQueue: Task[] = [];\r\n    private currentTask: Task | null = null;\r\n    private activeSessions: Map<string, boolean> = new Map(); // Track active Copilot sessions\r\n    private mcpTools: MCPToolInterface;\r\n    private logger: ILogger;\r\n    private maxConcurrentSessions: number = 3;\r\n    private isInitialized: boolean = false;\r\n    private tokenLimitPerPrompt: number = 3000;\r\n    private healthCheckInterval: number = 10000; // 10 seconds\r\n    private escalationTimeout: number = 30000; // 30 seconds\r\n    private treeDataProvider: any = null; // Reference to TreeView provider for auto-refresh\r\n    private completedTasksProvider: any = null; // Reference to CompletedTasksTreeProvider\r\n    private ticketDb: TicketDatabase; // TicketDatabase instance for orphan detection\r\n    private workspaceState?: vscode.Memento; // VS Code workspace state for persistence\r\n    private saveDebounceTimer?: NodeJS.Timeout; // Debounce timer for saving\r\n    private readonly STORAGE_KEY = 'coe.taskQueue';\r\n    private readonly SAVE_DEBOUNCE_MS = 200;\r\n    private readonly MAX_TASKS = 50;\r\n\r\n    /**\r\n     * ≡ƒÅù∩╕Å Constructor\r\n     * \r\n     * Initializes the Programming Orchestrator with MCP tools and logger\r\n     * \r\n     * @param mcpTools - Interface to MCP tools for communication\r\n     * @param logger - Logger instance for tracking operations\r\n     */\r\n    constructor(\r\n        mcpTools: MCPToolInterface = new MockMCPTools(),\r\n        logger?: ILogger,\r\n    ) {\r\n        this.mcpTools = mcpTools;\r\n        this.logger = logger || new SimpleLogger('ProgrammingOrchestrator');\r\n        this.ticketDb = TicketDatabase.getInstance();\r\n    }\r\n\r\n    // ========================================================================\r\n    // Lifecycle Management\r\n    // ========================================================================\r\n\r\n    /**\r\n     * ≡ƒî▓ Set TreeView data provider for auto-refresh\r\n     * \r\n     * Links the TreeView provider to the orchestrator so it can be refreshed\r\n     * automatically when the queue changes.\r\n     * \r\n     * @param provider - TreeView data provider instance\r\n     */\r\n    setTreeDataProvider(provider: any): void {\r\n        this.treeDataProvider = provider;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒöù Set CompletedTasksTreeProvider reference\r\n     * \r\n     * Allows orchestrator to trigger refresh of completed tasks history view.\r\n     * \r\n     * @param provider - CompletedTasksTreeProvider instance\r\n     */\r\n    setCompletedTasksProvider(provider: any): void {\r\n        this.completedTasksProvider = provider;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒöö Notify TreeView to refresh (internal helper)\r\n     * \r\n     * Called after any queue modification to keep UI in sync.\r\n     */\r\n    private notifyTreeViewUpdate(): void {\r\n        if (this.treeDataProvider?.refresh) {\r\n            this.treeDataProvider.refresh();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÆ╛ Initialize persistence with workspace state\r\n     * \r\n     * Loads persisted tasks from previous session. Call this during\r\n     * extension activation to restore task queue.\r\n     * \r\n     * @param workspaceState - VS Code workspace state for persistence\r\n     */\r\n    async initializeWithPersistence(workspaceState: vscode.Memento): Promise<void> {\r\n        if (!workspaceState) {\r\n            return;\r\n        }\r\n        this.workspaceState = workspaceState;\r\n        await this.loadPersistedTasks();\r\n        await this.reconcileTasks(); // Remove orphaned tasks after loading\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôª Load persisted tasks from workspace state\r\n     * \r\n     * @private\r\n     */\r\n    private async loadPersistedTasks(): Promise<void> {\r\n        if (!this.workspaceState) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const persistedData = this.workspaceState.get<any[]>(this.STORAGE_KEY);\r\n\r\n            if (!persistedData || !Array.isArray(persistedData)) {\r\n                return;\r\n            }\r\n\r\n            // Filter to only load active tasks (ready/inProgress/blocked)\r\n            const activeTasks = persistedData.filter(t =>\r\n                [TaskStatus.READY, TaskStatus.IN_PROGRESS, TaskStatus.BLOCKED].includes(t.status)\r\n            );\r\n\r\n            // Restore tasks to queue with proper Date conversion\r\n            this.taskQueue = activeTasks.map(t => {\r\n                // Convert string dates back to Date objects\r\n                let createdAt: Date;\r\n\r\n                if (t.createdAt) {\r\n                    const parsed = new Date(t.createdAt);\r\n                    if (isNaN(parsed.getTime())) {\r\n                        createdAt = new Date();\r\n                    } else {\r\n                        createdAt = parsed;\r\n                    }\r\n                } else {\r\n                    createdAt = new Date();\r\n                }\r\n\r\n                return {\r\n                    ...t,\r\n                    taskId: t.taskId || t.id, // Handle both formats\r\n                    fromPlanningTeam: true, // Mark as valid\r\n                    createdAt // Ensure Date object, not string\r\n                };\r\n            }) as Task[];\r\n\r\n\r\n            // Log loaded tasks with validation\r\n            activeTasks.forEach((task, idx) => {\r\n                const loadedTask = this.taskQueue[idx];\r\n\r\n                // Verify Date conversion\r\n                if (!(loadedTask.createdAt instanceof Date) || isNaN(loadedTask.createdAt.getTime())) {\r\n                    // Date validation - log if invalid\r\n                    void 0;\r\n                }\r\n            });\r\n\r\n            // Trigger UI refresh\r\n            this.notifyTreeViewUpdate();\r\n        } catch (error) {\r\n            this.taskQueue = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒöä Reconcile tasks with TicketDb (orphan detection)\r\n     * \r\n     * Removes tasks whose metadata.ticketId has no matching ticket in database.\r\n     * Called after loadPersistedTasks() to clean up stale references.\r\n     * \r\n     * @private\r\n     */\r\n    private async reconcileTasks(): Promise<void> {\r\n        if (this.taskQueue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const orphanedTasks: Task[] = [];\r\n        const validTasks: Task[] = [];\r\n\r\n        for (const task of this.taskQueue) {\r\n            const ticketId = task.metadata?.ticketId;\r\n\r\n            if (!ticketId) {\r\n                // Task has no ticket reference - keep it (might be from plan file)\r\n                validTasks.push(task);\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                const exists = await this.ticketDb.doesTicketExist(ticketId);\r\n                if (exists) {\r\n                    validTasks.push(task);\r\n                } else {\r\n                    orphanedTasks.push(task);\r\n                }\r\n            } catch (error) {\r\n                // On error, keep task to avoid accidental deletion\r\n                validTasks.push(task);\r\n            }\r\n        }\r\n\r\n        if (orphanedTasks.length > 0) {\r\n            this.taskQueue = validTasks;\r\n            await this.saveTaskQueue(); // Save cleaned queue\r\n\r\n            orphanedTasks.forEach(t => {\r\n            });\r\n\r\n            // Trigger UI refresh\r\n            this.notifyTreeViewUpdate();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save current task queue to workspace state (debounced)\r\n     * \r\n     * Persists tasks so they survive extension reloads.\r\n     * Only saves essential data (excludes large contextBundles).\r\n     * Debounced to avoid excessive writes.\r\n     * \r\n     * @private\r\n     */\r\n    private async saveTaskQueue(): Promise<void> {\r\n        // Clear existing debounce timer\r\n        if (this.saveDebounceTimer) {\r\n            clearTimeout(this.saveDebounceTimer);\r\n        }\r\n\r\n        // Debounce save operation\r\n        this.saveDebounceTimer = setTimeout(async () => {\r\n            if (!this.workspaceState) {\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Convert tasks to minimal persisted format\r\n                const persistedTasks: PersistedTask[] = this.taskQueue.map((task: Task) => ({\r\n                    taskId: task.taskId,\r\n                    title: task.title,\r\n                    description: task.description,\r\n                    priority: task.priority,\r\n                    status: task.status,\r\n                    dependencies: task.dependencies || [],\r\n                    blockedBy: task.blockedBy || [],\r\n                    estimatedHours: task.estimatedHours,\r\n                    acceptanceCriteria: task.acceptanceCriteria,\r\n                    relatedFiles: task.relatedFiles,\r\n                    assignedTo: task.assignedTo,\r\n                    createdAt: task.createdAt?.toISOString() || new Date().toISOString(),\r\n                    // Include metadata if present (for ticket-routed tasks)\r\n                    metadata: task.metadata ? {\r\n                        ticketId: task.metadata.ticketId,\r\n                        routedTeam: task.metadata.routedTeam,\r\n                        routingReason: task.metadata.routingReason,\r\n                        routingConfidence: task.metadata.routingConfidence,\r\n                        isEscalated: task.metadata.isEscalated\r\n                    } : undefined\r\n                }));\r\n\r\n                // Enforce max task limit (keep most recent 50)\r\n                const tasksToSave = persistedTasks.slice(-this.MAX_TASKS);\r\n\r\n                if (persistedTasks.length > this.MAX_TASKS) {\r\n                    // Tasks already sliced above\r\n                }\r\n\r\n                await this.workspaceState.update(this.STORAGE_KEY, tasksToSave);\r\n\r\n            } catch (error) {\r\n\r\n                // If storage quota exceeded, trim completed tasks and retry\r\n                if (error instanceof Error && error.message.includes('quota')) {\r\n                    const activeTasks = this.taskQueue.filter((t: Task) => t.status !== 'completed');\r\n                    this.taskQueue = activeTasks;\r\n\r\n                    // Retry save with trimmed data\r\n                    setTimeout(() => this.saveTaskQueue(), 100);\r\n                }\r\n            }\r\n        }, this.SAVE_DEBOUNCE_MS);\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÜÇ Initialize the Orchestrator\r\n     * \r\n     * Sets up the orchestrator, validates configuration, and prepares for task execution.\r\n     * Must be called before any task routing.\r\n     * \r\n     * **Enforces**: One-thing-at-a-time principle by ensuring single current task\r\n     * \r\n     * @throws Error if initialization fails\r\n     */\r\n    async init(): Promise<void> {\r\n        try {\r\n            this.logger.info('Programming Orchestrator: Initializing...');\r\n\r\n            // Validate configuration\r\n            if (this.maxConcurrentSessions < 1) {\r\n                throw new Error('maxConcurrentSessions must be >= 1');\r\n            }\r\n\r\n            // Initialize empty task queue\r\n            this.taskQueue = [];\r\n            this.currentTask = null;\r\n            this.activeSessions.clear();\r\n\r\n            this.isInitialized = true;\r\n\r\n            this.logger.info('Γ£à Programming Orchestrator: Ready (one-thing-at-a-time enforced)');\r\n        } catch (error) {\r\n            this.logger.error('Γ¥î Failed to initialize Orchestrator:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒ¢æ Shutdown the Orchestrator\r\n     * \r\n     * Gracefully shuts down the orchestrator, cleaning up active sessions\r\n     * and saving state.\r\n     */\r\n    async shutdown(): Promise<void> {\r\n        try {\r\n            this.logger.info('Programming Orchestrator: Shutting down...');\r\n\r\n            // Cancel all active sessions\r\n            for (const [sessionId, _] of this.activeSessions) {\r\n                this.logger.info(`Cancelling session: ${sessionId}`);\r\n                this.activeSessions.delete(sessionId);\r\n            }\r\n\r\n            // Clear queue\r\n            this.taskQueue = [];\r\n            this.currentTask = null;\r\n            this.isInitialized = false;\r\n\r\n            this.logger.info('Γ£à Programming Orchestrator: Shutdown complete');\r\n        } catch (error) {\r\n            this.logger.error('Γ¥î Error during shutdown:', error);\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Task Queue Management\r\n    // ========================================================================\r\n\r\n    /**\r\n     * ≡ƒôï Add task to the queue\r\n     * \r\n     * Adds a pre-decomposed task from Planning Team to the orchestrator's queue.\r\n     * Tasks are validated and inserted in priority order (P1 > P2 > P3).\r\n     * \r\n     * **Duplicate Prevention (Option A - Reusable TicketIds)**:\r\n     * - Only prevents active duplicates (ready, in-progress, blocked)\r\n     * - Archived/completed tasks with same ticketId are IGNORED\r\n     * - Allows ticketId reuse across test runs and production cycles\r\n     * - Example: 'TEST_001' can be recreated after previous run's archive\r\n     * \r\n     * **Enforces**: Planning Team output only (verifies fromPlanningTeam flag)\r\n     * **Prevents**: Duplicate ACTIVE tasks by exact ticketId metadata match\r\n     * \r\n     * @param task - Task to add (must be from Planning Team)\r\n     * @throws Error if task is invalid or not from Planning Team\r\n     */\r\n    async addTask(task: Task): Promise<boolean> {\r\n        // Prevent duplicate ACTIVE tasks for tickets (exact match only)\r\n        // Note: Archived/completed tasks are ignored - allows reuse\r\n        if (task.metadata?.ticketId) {\r\n            const exists = await this.hasTaskForTicket(task.metadata.ticketId);\r\n            if (exists) {\r\n                this.logger.debug(`Duplicate ticketId detected, skipping task: ${task.metadata.ticketId}`);\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Enforce max task limit\r\n        if (this.taskQueue.length >= this.MAX_TASKS) {\r\n            const completedIndex = this.taskQueue.findIndex((t: Task) => t.status === 'completed');\r\n            if (completedIndex >= 0) {\r\n                this.taskQueue.splice(completedIndex, 1);\r\n            } else {\r\n                this.logger.warn('Task queue full; unable to add task with no completed tasks to remove');\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Add to queue\r\n        this.taskQueue.push(task);\r\n\r\n        if (task.metadata?.ticketId) {\r\n            // Ticket ID already set in metadata\r\n        }\r\n\r\n        // Save to storage and trigger UI refresh\r\n        await this.saveTaskQueue();\r\n        this.notifyTreeViewUpdate();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒöä Get next task from queue\r\n     * \r\n     * Pulls the highest priority task from the queue that is ready for execution.\r\n     * Returns null if no tasks are ready.\r\n     * \r\n     * **Priority Order**: P1 > P2 > P3 > (next ready task)\r\n     * \r\n     * @returns Next ready task or null if queue empty\r\n     * @throws Error with INVALID_STATE if queue is empty\r\n     */\r\n    getNextTask(): Task | null {\r\n        try {\r\n            // Filter ready tasks (no blockers, all dependencies met)\r\n            const readyTasks = this.getReadyTasks();\r\n\r\n            if (readyTasks.length === 0) {\r\n                this.logger.warn('ΓÜá∩╕Å No ready tasks in queue');\r\n                return null;\r\n            }\r\n\r\n            // Return highest priority task (P1 first)\r\n            const nextTask = readyTasks[0];\r\n            this.logger.info(`≡ƒÄ» Next task: ${nextTask.taskId} (${nextTask.priority})`);\r\n\r\n            return nextTask;\r\n        } catch (error) {\r\n            this.logger.error('Γ¥î Error getting next task:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôï Get all ready tasks sorted by priority\r\n     * @returns Ready tasks ordered by priority (P1 ΓåÆ P2 ΓåÆ P3)\r\n     */\r\n    getReadyTasks(): Task[] {\r\n\r\n        const readyTasks = this.taskQueue.filter((t) => {\r\n            const isReady = t.status === TaskStatus.READY;\r\n            const notBlocked = !t.blockedBy || t.blockedBy.length === 0;\r\n            const dependenciesMet = this.areDependenciesMet(t);\r\n\r\n            if (!isReady) {\r\n                // Task not ready\r\n            } else if (!notBlocked) {\r\n                // Task is blocked\r\n            } else if (!dependenciesMet) {\r\n                // Dependencies not met\r\n            } else {\r\n                // All conditions met\r\n            }\r\n\r\n            return isReady && notBlocked && dependenciesMet;\r\n        });\r\n\r\n        const priorityRank: Record<TaskPriority, number> = {\r\n            [TaskPriority.P1]: 1,\r\n            [TaskPriority.P2]: 2,\r\n            [TaskPriority.P3]: 3,\r\n        };\r\n\r\n        const sorted = readyTasks.sort((a, b) => priorityRank[a.priority] - priorityRank[b.priority]);\r\n\r\n\r\n        return sorted;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒùæ∩╕Å Clear all tasks from the queue\r\n     */\r\n    clearQueue(): void {\r\n        this.taskQueue = [];\r\n        this.currentTask = null;\r\n        // Save to storage\r\n        this.saveTaskQueue();\r\n        // Notify TreeView to refresh\r\n        this.notifyTreeViewUpdate();\r\n    }\r\n\r\n    /**\r\n     * ΓÖ╗∩╕Å Replace the entire queue with new tasks\r\n     * @param tasks New tasks to set\r\n     */\r\n    setTasks(tasks: Task[]): void {\r\n        this.clearQueue();\r\n        tasks.forEach((task) => this.addTask(task));\r\n        // notifyTreeViewUpdate already called by clearQueue and addTask\r\n    }\r\n\r\n    /**\r\n     * ≡ƒöÄ Find a task by id\r\n     * @param taskId Task identifier\r\n     * @returns Task if found, otherwise undefined\r\n     */\r\n    getTaskById(taskId: string): Task | undefined {\r\n        return this.taskQueue.find((t) => t.taskId === taskId);\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÄƒ∩╕Å Get queue status\r\n     * \r\n     * Returns current queue statistics for monitoring\r\n     * \r\n     * @returns Queue statistics\r\n     */\r\n    getQueueStatus(): {\r\n        totalTasks: number;\r\n        byPriority: Record<string, number>;\r\n        byStatus: Record<string, number>;\r\n        currentTask: Task | null;\r\n        activeSessions: number;\r\n    } {\r\n        const stats = {\r\n            totalTasks: this.taskQueue.length,\r\n            byPriority: {\r\n                P1: this.taskQueue.filter((t) => t.priority === TaskPriority.P1).length,\r\n                P2: this.taskQueue.filter((t) => t.priority === TaskPriority.P2).length,\r\n                P3: this.taskQueue.filter((t) => t.priority === TaskPriority.P3).length,\r\n            },\r\n            byStatus: {\r\n                pending: this.taskQueue.filter((t) => t.status === TaskStatus.PENDING).length,\r\n                ready: this.taskQueue.filter((t) => t.status === TaskStatus.READY).length,\r\n                inProgress: this.taskQueue.filter((t) => t.status === TaskStatus.IN_PROGRESS).length,\r\n                completed: this.taskQueue.filter((t) => t.status === TaskStatus.COMPLETED).length,\r\n                blocked: this.taskQueue.filter((t) => t.status === TaskStatus.BLOCKED).length,\r\n                failed: this.taskQueue.filter((t) => t.status === TaskStatus.FAILED).length,\r\n            },\r\n            currentTask: this.currentTask,\r\n            activeSessions: this.activeSessions.size,\r\n        };\r\n\r\n        return stats;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒöä Check if orchestrator is busy processing a task\r\n     * \r\n     * Returns true if a task is currently in progress or a current task is set and in-progress\r\n     * \r\n     * @returns boolean True if actively processing a task\r\n     */\r\n    isBusy(): boolean {\r\n        // Check if current task exists and is in progress\r\n        if (this.currentTask && this.currentTask.status === TaskStatus.IN_PROGRESS) {\r\n            return true;\r\n        }\r\n        // Also check if any task in queue is currently in progress\r\n        return this.taskQueue.some((t) => t.status === TaskStatus.IN_PROGRESS);\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÄ½ Check if task already exists for a given ticket ID\r\n     * \r\n     * Prevents duplicate tasks from being created for the same ticket.\r\n     * **CRITICAL**: Only checks ACTIVE queue, not historical/completed tasks.\r\n     * This enables Option A behavior: test ticketIds can be reused across runs.\r\n     * \r\n     * Uses exact match only for precise deduplication:\r\n     * - Checks metadata.ticketId for exact match\r\n     * - Verifies task has ACTIVE status only:\r\n     *   Γ£à ready, in-progress, blocked (CHECKED)\r\n     *   Γ¥î completed, failed, archived (IGNORED - in history)\r\n     * - NO fuzzy matching (removed title+priority fallback)\r\n     * \r\n     * **Option A (Reusable TicketIds)**:\r\n     * - Run 1: Create 'TEST_001' ΓåÆ completes ΓåÆ archives ΓåÆ removed from active queue\r\n     * - Run 2: hasTaskForTicket('TEST_001') ΓåÆ FALSE (archive is ignored)\r\n     *          ΓåÆ Can create 'TEST_001' again! Γ£à\r\n     * - Run 3: Same as Run 2 ΓåÆ 'TEST_001' fully reusable\r\n     * \r\n     * @param ticketId - Ticket ID to check (from task.metadata.ticketId)\r\n     * @returns Promise<boolean> True only if exact match found in ACTIVE queue\r\n     */\r\n    async hasTaskForTicket(ticketId: string): Promise<boolean> {\r\n        if (!this.taskQueue || !Array.isArray(this.taskQueue)) {\r\n            return false;\r\n        }\r\n\r\n        // Exact match only: metadata.ticketId MUST match AND task must be ACTIVE\r\n        const activeStatuses = [TaskStatus.READY, TaskStatus.IN_PROGRESS, TaskStatus.BLOCKED];\r\n        const existingTask = this.taskQueue.find((task: Task) =>\r\n            task.metadata?.ticketId === ticketId &&\r\n            activeStatuses.includes(task.status)\r\n        );\r\n\r\n        if (existingTask) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôè Get count of ready tasks\r\n     * \r\n     * Useful for monitoring queue status and UI updates\r\n     * \r\n     * @returns number Count of tasks with status READY\r\n     */\r\n    getReadyTasksCount(): number {\r\n        return this.taskQueue.filter((t) => t.status === TaskStatus.READY).length;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôè Get count of in-progress tasks\r\n     * \r\n     * @returns number Count of tasks with status IN_PROGRESS\r\n     */\r\n    getInProgressTasksCount(): number {\r\n        return this.taskQueue.filter((t) => t.status === TaskStatus.IN_PROGRESS).length;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôè Get all tasks\r\n     * \r\n     * @returns Task[] All tasks in queue\r\n     */\r\n    getAllTasks(): Task[] {\r\n        return this.taskQueue;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôè Get ready tasks count\r\n     * \r\n     * Returns count of tasks with READY status for status bar display.\r\n     * \r\n     * @returns number Count of ready tasks\r\n     */\r\n    getReadyCount(): number {\r\n        if (!this.taskQueue || !Array.isArray(this.taskQueue)) {\r\n            return 0;\r\n        }\r\n        return this.taskQueue.filter((t: Task) => t.status === TaskStatus.READY).length;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÆ╛ Save queue to workspace state\r\n     * \r\n     * Persists tasks across VS Code reloads.\r\n     * Only saves essential fields to stay under storage limits.\r\n     * \r\n     * @param workspaceState VS Code workspace state\r\n     * @returns Promise<void>\r\n     */\r\n    async saveToStorage(workspaceState: vscode.Memento): Promise<void> {\r\n        if (!this.taskQueue || !Array.isArray(this.taskQueue)) {\r\n            return;\r\n        }\r\n\r\n        // Only persist first 50 tasks with minimal data\r\n        const simplifiedTasks: PersistedTask[] = this.taskQueue.slice(0, this.MAX_TASKS).map((task: Task) => ({\r\n            taskId: task.taskId,\r\n            title: task.title,\r\n            description: task.description,\r\n            priority: task.priority,\r\n            status: task.status,\r\n            dependencies: task.dependencies || [],\r\n            blockedBy: task.blockedBy || [],\r\n            estimatedHours: task.estimatedHours,\r\n            acceptanceCriteria: task.acceptanceCriteria,\r\n            relatedFiles: task.relatedFiles,\r\n            assignedTo: task.assignedTo,\r\n            metadata: task.metadata,\r\n            createdAt: task.createdAt?.toISOString() || new Date().toISOString(),\r\n        }));\r\n\r\n        try {\r\n            await workspaceState.update(this.STORAGE_KEY, simplifiedTasks);\r\n            this.logger.info(`≡ƒÆ╛ Saved ${simplifiedTasks.length} tasks to storage`);\r\n        } catch (error) {\r\n            this.logger.error(`Failed to save task queue: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôé Load queue from workspace state\r\n     * \r\n     * Restores persisted tasks on extension activation.\r\n     * \r\n     * @param workspaceState VS Code workspace state\r\n     * @returns Promise<void>\r\n     */\r\n    async loadFromStorage(workspaceState: vscode.Memento): Promise<void> {\r\n        try {\r\n            const stored = workspaceState.get<PersistedTask[]>(this.STORAGE_KEY);\r\n\r\n            if (!stored || !Array.isArray(stored)) {\r\n                this.logger.info('≡ƒôé No persisted tasks found, starting fresh');\r\n                this.taskQueue = [];\r\n                return;\r\n            }\r\n\r\n            // Convert stored data back to Task objects with proper Date handling\r\n            this.taskQueue = stored.map((item: PersistedTask) => {\r\n                let createdAt: Date;\r\n\r\n                if (item.createdAt) {\r\n                    const parsed = new Date(item.createdAt);\r\n                    if (isNaN(parsed.getTime())) {\r\n                        this.logger.warn(`Invalid date for task \"${item.title}\", using current time`);\r\n                        createdAt = new Date();\r\n                    } else {\r\n                        createdAt = parsed;\r\n                    }\r\n                } else {\r\n                    createdAt = new Date();\r\n                }\r\n\r\n                return {\r\n                    ...item,\r\n                    createdAt,\r\n                    fromPlanningTeam: true,\r\n                } as Task;\r\n            });\r\n\r\n            this.logger.info(`≡ƒôé Loaded and converted ${this.taskQueue.length} tasks from storage with Date objects`);\r\n            this.notifyTreeViewUpdate();\r\n        } catch (error) {\r\n            this.logger.error(`Failed to load task queue: ${error}`);\r\n            this.taskQueue = [];\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Task Routing (Handoff to Coding AI)\r\n    // ========================================================================\r\n\r\n    /**\r\n     * ≡ƒÜÇ Route task to Coding AI (Copilot)\r\n     * \r\n     * Prepares a super-detailed prompt for the given task and hands it off\r\n     * to GitHub Copilot. Enforces \"one thing at a time\" by allowing only\r\n     * one concurrent task at a time.\r\n     * \r\n     * **Process**:\r\n     * 1. Validates task is atomic and from Planning Team\r\n     * 2. Generates super-detailed prompt (under 3000 tokens)\r\n     * 3. Reports task status as IN_PROGRESS via MCP\r\n     * 4. Returns routing directive for Copilot\r\n     * \r\n     * **Enforces**:\r\n     * - One task at a time (no parallel execution in Orchestrator)\r\n     * - Task comes from Planning Team\r\n     * - Prompt under 3000 tokens\r\n     * - All dependencies met\r\n     * \r\n     * @param task - Task to route to Copilot\r\n     * @returns Routing directive with super-detailed prompt\r\n     * @throws Error if validation fails or task invalid\r\n     */\r\n    async routeTask(task: Task): Promise<RoutingDirective> {\r\n        try {\r\n            // Validate task\r\n            const validatedTask = TaskSchema.parse(task);\r\n\r\n            // CRITICAL: Verify task from Planning Team\r\n            if (!validatedTask.fromPlanningTeam) {\r\n                throw new Error('Task must be from Planning Team');\r\n            }\r\n\r\n            // CRITICAL: Enforce one-thing-at-a-time\r\n            if (this.currentTask !== null && this.currentTask.taskId !== validatedTask.taskId) {\r\n                throw new Error(\r\n                    `Cannot route new task while already executing: ${this.currentTask.taskId}. ` +\r\n                    'One thing at a time!',\r\n                );\r\n            }\r\n\r\n            // Check concurrent session limit\r\n            if (this.activeSessions.size >= this.maxConcurrentSessions) {\r\n                throw new Error(\r\n                    `Max concurrent sessions (${this.maxConcurrentSessions}) reached`,\r\n                );\r\n            }\r\n\r\n            // Find task in queue\r\n            const queuedTask = this.taskQueue.find((t) => t.taskId === validatedTask.taskId);\r\n            if (!queuedTask) {\r\n                throw new Error(\r\n                    `Task not found in queue: ${validatedTask.taskId}. ` +\r\n                    'Task must be added to queue before routing.',\r\n                );\r\n            }\r\n\r\n            // Check all dependencies are met\r\n            if (!this.areDependenciesMet(queuedTask)) {\r\n                throw new Error(\r\n                    `Cannot route task: unmet dependencies: ${queuedTask.dependencies.join(', ')} `,\r\n                );\r\n            }\r\n\r\n            // Generate super-detailed prompt (under 3000 tokens)\r\n            const prompt = this.generateSuperDetailedPrompt(queuedTask);\r\n\r\n            // Validate prompt token count (rough estimate)\r\n            const promptTokens = this.estimateTokens(prompt);\r\n            if (promptTokens > this.tokenLimitPerPrompt) {\r\n                this.logger.warn(\r\n                    `ΓÜá∩╕Å Prompt exceeds token limit: ${promptTokens} > ${this.tokenLimitPerPrompt}. ` +\r\n                    'Breaking down further.',\r\n                );\r\n            }\r\n\r\n            // Create routing directive\r\n            const directive: RoutingDirective = {\r\n                taskId: queuedTask.taskId,\r\n                title: queuedTask.title,\r\n                description: queuedTask.description,\r\n                acceptanceCriteria: queuedTask.acceptanceCriteria,\r\n                contextBundle: prompt,\r\n                relatedFiles: queuedTask.relatedFiles || [],\r\n                designReferences: queuedTask.designReferences,\r\n                estimatedHours: queuedTask.estimatedHours,\r\n                priority: queuedTask.priority,\r\n                promptVersion: '1.0',\r\n            };\r\n\r\n            // Validate directive\r\n            const validatedDirective = RoutingDirectiveSchema.parse(directive);\r\n\r\n            // Update task status in queue to IN_PROGRESS\r\n            queuedTask.status = TaskStatus.IN_PROGRESS;\r\n\r\n            // Report task status as IN_PROGRESS via MCP\r\n            const sessionId = this.generateSessionId(queuedTask.taskId);\r\n            await this.mcpTools.reportTaskStatus(\r\n                queuedTask.taskId,\r\n                TaskStatus.IN_PROGRESS,\r\n            );\r\n\r\n            // Track active session\r\n            this.activeSessions.set(sessionId, true);\r\n            this.currentTask = queuedTask;\r\n\r\n            this.logger.info(\r\n                `Γ£à Task routed to Copilot (${sessionId}): ` +\r\n                `${queuedTask.title} [${promptTokens} tokens]`,\r\n            );\r\n\r\n            return validatedDirective;\r\n        } catch (error) {\r\n            this.logger.error('Γ¥î Failed to route task:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Γ£à Handle task completion\r\n     * \r\n     * Called when Coding AI reports that a task is complete. Updates task status,\r\n     * closes the session, and reports back to the orchestration queue.\r\n     * \r\n     * **Process**:\r\n     * 1. Validates task completion\r\n     * 2. Updates task status to COMPLETED\r\n     * 3. Reports completion via MCP\r\n     * 4. Closes Copilot session\r\n     * 5. Frees up for next task\r\n     * \r\n     * @param taskId - ID of completed task\r\n     * @param output - Optional output/summary from Copilot\r\n     * @throws Error if task not found or already complete\r\n     */\r\n    async onTaskComplete(taskId: string, output?: string): Promise<void> {\r\n        try {\r\n            // Find task\r\n            const task = this.taskQueue.find((t) => t.taskId === taskId);\r\n            if (!task) {\r\n                throw new Error(`Task not found: ${taskId}`);\r\n            }\r\n\r\n            // Verify task is in progress\r\n            if (task.status !== TaskStatus.IN_PROGRESS) {\r\n                throw new Error(\r\n                    `Cannot complete task not in progress. Current status: ${task.status}`,\r\n                );\r\n            }\r\n\r\n            // Update task status\r\n            task.status = TaskStatus.COMPLETED;\r\n\r\n            // Report completion via MCP\r\n            await this.mcpTools.reportTaskStatus(\r\n                taskId,\r\n                TaskStatus.COMPLETED,\r\n                output,\r\n            );\r\n\r\n            // Close session\r\n            const sessionId = this.generateSessionId(taskId);\r\n            this.activeSessions.delete(sessionId);\r\n\r\n            // Clear current task if it's this one\r\n            if (this.currentTask?.taskId === taskId) {\r\n                this.currentTask = null;\r\n            }\r\n\r\n            this.logger.info(`Γ£à Task completed: ${taskId}`);\r\n        } catch (error) {\r\n            this.logger.error('Γ¥î Error handling task completion:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÜ½ Handle task failure\r\n     * \r\n     * Called when Coding AI reports a task failure. Updates task status,\r\n     * logs failure details, and opens for retry.\r\n     * \r\n     * @param taskId - ID of failed task\r\n     * @param reason - Reason for failure\r\n     * @throws Error if task not found\r\n     */\r\n    async onTaskFailed(taskId: string, reason: string): Promise<void> {\r\n        try {\r\n            // Find task\r\n            const task = this.taskQueue.find((t) => t.taskId === taskId);\r\n            if (!task) {\r\n                throw new Error(`Task not found: ${taskId}`);\r\n            }\r\n\r\n            // Update task status\r\n            task.status = TaskStatus.FAILED;\r\n\r\n            // Report failure via MCP\r\n            await this.mcpTools.reportObservation(taskId, `Task failed: ${reason}`);\r\n\r\n            // Close session\r\n            const sessionId = this.generateSessionId(taskId);\r\n            this.activeSessions.delete(sessionId);\r\n\r\n            // Clear current task if it's this one\r\n            if (this.currentTask?.taskId === taskId) {\r\n                this.currentTask = null;\r\n            }\r\n\r\n            this.logger.error(`Γ¥î Task failed: ${taskId}: ${reason}`);\r\n        } catch (error) {\r\n            this.logger.error('Γ¥î Error handling task failure:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒñö Handle task block\r\n     * \r\n     * Called when Coding AI is blocked and needs clarification. Routes\r\n     * the question to Answer Team via MCP.\r\n     * \r\n     * @param taskId - ID of blocked task\r\n     * @param blockReason - Reason for block / question to Answer Team\r\n     * @throws Error if task not found or not in progress\r\n     */\r\n    async onTaskBlocked(taskId: string, blockReason: string): Promise<string> {\r\n        try {\r\n            // Find task\r\n            const task = this.taskQueue.find((t) => t.taskId === taskId);\r\n            if (!task) {\r\n                throw new Error(`Task not found: ${taskId}`);\r\n            }\r\n\r\n            // Update status to BLOCKED\r\n            task.status = TaskStatus.BLOCKED;\r\n            task.blockedBy = [blockReason]; // Store block reason\r\n\r\n            this.logger.warn(`ΓÜá∩╕Å Task blocked: ${taskId}: ${blockReason}`);\r\n\r\n            // Route to Answer Team via MCP askQuestion\r\n            const response = await this.mcpTools.askQuestion(blockReason, {\r\n                taskId,\r\n                currentTask: task,\r\n                blockReason,\r\n            });\r\n\r\n            if (!response.success) {\r\n                throw new Error(`Answer Team failed to respond: ${response.error?.message}`);\r\n            }\r\n\r\n            const answer = (response.data as Record<string, unknown>)?.answer as string || 'No answer';\r\n\r\n            this.logger.info(`Γ£à Answer Team response received: ${answer}`);\r\n\r\n            // Report observation\r\n            await this.mcpTools.reportObservation(\r\n                taskId,\r\n                `Blocked: ${blockReason}. Answer Team response: ${answer}`,\r\n            );\r\n\r\n            return answer;\r\n        } catch (error) {\r\n            this.logger.error('Γ¥î Error handling task block:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Helper Methods\r\n    // ========================================================================\r\n\r\n    /**\r\n     * ≡ƒº« Estimate token count for a prompt\r\n     * \r\n     * Simple token estimation: roughly 1 token per 4 characters\r\n     * This is a rough estimate; for production use tiktoken or similar.\r\n     * \r\n     * @param text - Text to estimate\r\n     * @returns Estimated token count\r\n     */\r\n    private estimateTokens(text: string): number {\r\n        // Rough estimate: ~1 token per 4 characters\r\n        return Math.ceil(text.length / 4);\r\n    }\r\n\r\n    /**\r\n     * ≡ƒô¥ Generate super-detailed prompt for Copilot\r\n     * \r\n     * Creates a comprehensive, context-rich prompt under 3000 tokens\r\n     * that gives Copilot everything it needs to complete the task.\r\n     * \r\n     * **Structure**:\r\n     * - Task description and context\r\n     * - Acceptance criteria (clear success conditions)\r\n     * - Related files and code context\r\n     * - Design system references (colors, typography, accessibility)\r\n     * - Estimated effort and complexity\r\n     * \r\n     * @param task - Task to generate prompt for\r\n     * @returns Super-detailed prompt string (under 3000 tokens)\r\n     */\r\n    private generateSuperDetailedPrompt(task: Task): string {\r\n        const lines: string[] = [];\r\n\r\n        lines.push('='.repeat(70));\r\n        lines.push(`≡ƒÄ» TASK: ${task.title}`);\r\n        lines.push('='.repeat(70));\r\n        lines.push('');\r\n\r\n        // 1. Task Description\r\n        lines.push('≡ƒô¥ DESCRIPTION:');\r\n        lines.push(task.description);\r\n        lines.push('');\r\n\r\n        // 2. Acceptance Criteria\r\n        lines.push('Γ£à ACCEPTANCE CRITERIA:');\r\n        task.acceptanceCriteria.forEach((criterion, i) => {\r\n            lines.push(`  ${i + 1}. ${criterion}`);\r\n        });\r\n        lines.push('');\r\n\r\n        // 3. Related Files\r\n        if (task.relatedFiles && task.relatedFiles.length > 0) {\r\n            lines.push('≡ƒôä RELATED FILES:');\r\n            task.relatedFiles.forEach((file) => {\r\n                lines.push(`  - ${file}`);\r\n            });\r\n            lines.push('');\r\n        }\r\n\r\n        // 4. Design References\r\n        if (task.designReferences && Object.keys(task.designReferences).length > 0) {\r\n            lines.push('≡ƒÄ¿ DESIGN REFERENCES:');\r\n            for (const [key, value] of Object.entries(task.designReferences)) {\r\n                lines.push(`  ${key}: ${JSON.stringify(value, null, 2)}`);\r\n            }\r\n            lines.push('');\r\n        }\r\n\r\n        // 5. Priority and Estimation\r\n        lines.push('ΓÅ▒∩╕Å EFFORT & PRIORITY:');\r\n        lines.push(`  Priority: ${task.priority}`);\r\n        lines.push(`  Estimated Hours: ${task.estimatedHours}`);\r\n        lines.push('');\r\n\r\n        // 6. Dependencies\r\n        if (task.dependencies && task.dependencies.length > 0) {\r\n            lines.push('≡ƒöù DEPENDENCIES:');\r\n            task.dependencies.forEach((dep) => {\r\n                lines.push(`  - ${dep}`);\r\n            });\r\n            lines.push('');\r\n        }\r\n\r\n        // 7. Context Bundle (if provided)\r\n        if (task.contextBundle) {\r\n            lines.push('≡ƒÆí CONTEXT:');\r\n            lines.push(task.contextBundle);\r\n            lines.push('');\r\n        }\r\n\r\n        // 8. Instructions\r\n        lines.push('≡ƒÜÇ INSTRUCTIONS:');\r\n        lines.push('  1. Read this entire prompt');\r\n        lines.push('  2. Ensure all acceptance criteria are clear');\r\n        lines.push('  3. Ask questions via askQuestion MCP tool if anything is unclear');\r\n        lines.push('  4. Implement the task following acceptance criteria strictly');\r\n        lines.push('  5. Report status via reportTaskStatus when complete');\r\n        lines.push('');\r\n\r\n        lines.push('='.repeat(70));\r\n\r\n        const prompt = lines.join('\\n');\r\n\r\n        // Warn if exceeds limit\r\n        const tokens = this.estimateTokens(prompt);\r\n        if (tokens > this.tokenLimitPerPrompt) {\r\n            this.logger.warn(\r\n                `ΓÜá∩╕Å Prompt exceeds limit: ${tokens} > ${this.tokenLimitPerPrompt}. ` +\r\n                'Consider breaking task further.',\r\n            );\r\n        }\r\n\r\n        return prompt;\r\n    }\r\n\r\n    /**\r\n     * Γ£ö∩╕Å Check if all dependencies are met for a task\r\n     * \r\n     * @param task - Task to check\r\n     * @returns true if all dependencies are completed\r\n     */\r\n    private areDependenciesMet(task: Task): boolean {\r\n        if (!task.dependencies || task.dependencies.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        return task.dependencies.every((depId) => {\r\n            const depTask = this.taskQueue.find((t) => t.taskId === depId);\r\n            return depTask && depTask.status === TaskStatus.COMPLETED;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÄƒ∩╕Å Insert task by priority order (P1, P2, P3)\r\n     * \r\n     * @param task - Task to insert\r\n     */\r\n    private insertByPriority(task: Task): void {\r\n        const priorityOrder: Record<string, number> = {\r\n            [TaskPriority.P1]: 0,\r\n            [TaskPriority.P2]: 1,\r\n            [TaskPriority.P3]: 2,\r\n        };\r\n\r\n        let inserted = false;\r\n        for (let i = 0; i < this.taskQueue.length; i++) {\r\n            const queuePriority = priorityOrder[this.taskQueue[i].priority];\r\n            const taskPriority = priorityOrder[task.priority];\r\n\r\n            if (taskPriority < queuePriority) {\r\n                this.taskQueue.splice(i, 0, task);\r\n                inserted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!inserted) {\r\n            this.taskQueue.push(task);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒåö Generate a unique session ID for a task\r\n     * \r\n     * @param taskId - Task ID\r\n     * @returns Session ID\r\n     */\r\n    private generateSessionId(taskId: string): string {\r\n        return `session-${taskId}-${Date.now()}`;\r\n    }\r\n}\r\n\r\n/**\r\n * Default logger (simple console wrapper)\r\n * Can be replaced with Winston, Bunyan, or other logging library\r\n */\r\nexport class SimpleLogger implements ILogger {\r\n    constructor(private name: string) { }\r\n\r\n    info(message: string, ...args: unknown[]): void {\r\n    }\r\n\r\n    warn(message: string, ...args: unknown[]): void {\r\n    }\r\n\r\n    error(message: string, ...args: unknown[]): void {\r\n        // Safely serialize error objects to avoid circular reference issues\r\n        const safeArgs = args.map(arg => {\r\n            if (arg instanceof Error) {\r\n                return { name: arg.name, message: arg.message, stack: arg.stack };\r\n            }\r\n            return arg;\r\n        });\r\n    }\r\n\r\n    debug(message: string, ...args: unknown[]): void {\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Exports\r\n// ============================================================================\r\n\r\n// All types, classes, and enums are exported via their declarations above\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\plans\\fileWatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\plans\\planManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\plans\\planningStub.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorMessage' is assigned a value but never used.","line":67,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":67,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorMessage' is assigned a value but never used.","line":98,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":98,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ≡ƒÄ» Planning Team Stub - Simple Plan File Parser\r\n * \r\n * Loads tasks from a Markdown file in the workspace with simple syntax:\r\n * - [ ] Task title #P1\r\n * - [ ] Another task #P2\r\n * - [ ] Task without priority (defaults to P3)\r\n * \r\n * This is a minimal implementation for testing the orchestrator loop.\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport { Task, TaskPriority, TaskStatus } from '../orchestrator/programmingOrchestrator';\r\n\r\n/**\r\n * ≡ƒôû Load Tasks from Plan File\r\n * \r\n * Loads tasks from Docs/Plans/current-plan.md in the current workspace root.\r\n * Creates starter file if it doesn't exist.\r\n * Each line format: - [ ] Task title #P1 | #P2 | #P3\r\n * \r\n * @returns Promise<Task[]> Array of parsed tasks, empty if workspace not found\r\n */\r\nexport async function loadTasksFromPlanFile(): Promise<Task[]> {\r\n    try {\r\n        // Get workspace root folder\r\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\r\n        if (!workspaceFolder) {\r\n            return [];\r\n        }\r\n\r\n        // Construct path to plan file in workspace\r\n        const planFileUri = vscode.Uri.joinPath(\r\n            workspaceFolder.uri,\r\n            'Docs',\r\n            'Plans',\r\n            'current-plan.md'\r\n        );\r\n\r\n        // Check if file exists\r\n        let fileExists = false;\r\n        try {\r\n            await vscode.workspace.fs.stat(planFileUri);\r\n            fileExists = true;\r\n        } catch {\r\n            fileExists = false;\r\n        }\r\n\r\n        // If file doesn't exist, create it with starter content\r\n        if (!fileExists) {\r\n            await createStarterPlanFile(workspaceFolder.uri, planFileUri);\r\n            // Show user message\r\n            await vscode.window.showInformationMessage(\r\n                'Γ£à COE created a starter plan file in your project! Open Docs/Plans/current-plan.md to edit tasks.'\r\n            );\r\n        }\r\n\r\n        // Read file content\r\n        const fileContent = await vscode.workspace.fs.readFile(planFileUri);\r\n        const fileText = new TextDecoder().decode(fileContent);\r\n\r\n        // Parse tasks from markdown lines\r\n        const tasks = parseTasksFromMarkdown(fileText);\r\n\r\n        return tasks;\r\n    } catch (error) {\r\n        const errorMessage = error instanceof Error ? error.message : String(error);\r\n        return [];\r\n    }\r\n}\r\n\r\n/**\r\n * ≡ƒô¥ Create Starter Plan File\r\n * \r\n * Creates the Docs/Plans directory structure and writes a starter plan file.\r\n * \r\n * @param workspaceUri Workspace root URI\r\n * @param planFileUri URI where to create the plan file\r\n */\r\nasync function createStarterPlanFile(workspaceUri: vscode.Uri, planFileUri: vscode.Uri): Promise<void> {\r\n    const starterContent = `# COE Project Plan (auto-created)\r\n\r\n- [ ] Build user registration endpoint #P1\r\n- [ ] Add task list display component #P2\r\n- [ ] Write README with project overview\r\n`;\r\n\r\n    try {\r\n        // Create directory structure\r\n        const docsPlansUri = vscode.Uri.joinPath(workspaceUri, 'Docs', 'Plans');\r\n        await vscode.workspace.fs.createDirectory(docsPlansUri);\r\n\r\n        // Write file\r\n        const encoder = new TextEncoder();\r\n        const fileContent = encoder.encode(starterContent);\r\n        await vscode.workspace.fs.writeFile(planFileUri, fileContent);\r\n    } catch (error) {\r\n        const errorMessage = error instanceof Error ? error.message : String(error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ≡ƒöì Parse Tasks from Markdown Content\r\n * \r\n * Extracts task lines matching: [ ] Title #P1\r\n * Generates: taskId (PLAN-{lineNumber}-{timestamp}), priority, status\r\n * \r\n * @param markdownContent Raw markdown file content\r\n * @returns Task[] Array of parsed tasks (invalid lines skipped)\r\n */\r\nfunction parseTasksFromMarkdown(markdownContent: string): Task[] {\r\n    const tasks: Task[] = [];\r\n    const timestamp = Date.now();\r\n    const lines = markdownContent.split('\\n');\r\n\r\n    lines.forEach((line, index) => {\r\n        // Match [ ] pattern (supports both \"[ ]\" and \"- [ ]\" formats)\r\n        const match = line.match(/^\\s*(?:-\\s+)?\\[\\s*\\]\\s+(.+?)(?:\\s*#(P[123]))?$/);\r\n\r\n        if (!match) {\r\n            return; // Skip non-matching lines silently\r\n        }\r\n\r\n        const taskTitle = match[1].trim();\r\n        const priorityMatch = match[2];\r\n\r\n        // Determine priority\r\n        let priority = TaskPriority.P3;\r\n        if (priorityMatch === 'P1') {\r\n            priority = TaskPriority.P1;\r\n        } else if (priorityMatch === 'P2') {\r\n            priority = TaskPriority.P2;\r\n        }\r\n\r\n        // Create task object\r\n        const task: Task = {\r\n            taskId: `PLAN-${index + 1}-${timestamp}`,\r\n            title: taskTitle,\r\n            description: taskTitle, // Same as title for now\r\n            priority,\r\n            status: TaskStatus.READY,\r\n            acceptanceCriteria: ['Task parsed from plan file'],\r\n            dependencies: [],\r\n            blockedBy: [],\r\n            fromPlanningTeam: true,\r\n            createdAt: new Date(),\r\n            estimatedHours: 1, // Default 1 hour\r\n        };\r\n\r\n        tasks.push(task);\r\n    });\r\n\r\n    return tasks;\r\n}\r\n\r\n/**\r\n * ≡ƒº╣ Validate Parsed Task\r\n * \r\n * Ensures task meets minimum requirements before adding to orchestrator\r\n * \r\n * @param task Task to validate\r\n * @returns boolean True if valid\r\n */\r\nexport function isValidTask(task: Task): boolean {\r\n    // Check required string fields\r\n    if (!task.taskId || task.taskId.length === 0) {\r\n        return false;\r\n    }\r\n    if (!task.title || task.title.length === 0) {\r\n        return false;\r\n    }\r\n    if (!task.acceptanceCriteria || task.acceptanceCriteria.length === 0) {\r\n        return false;\r\n    }\r\n\r\n    // Check enum values are valid\r\n    const validPriorities = Object.values(TaskPriority);\r\n    const validStatuses = Object.values(TaskStatus);\r\n\r\n    return validPriorities.includes(task.priority) && validStatuses.includes(task.status);\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\plans\\schemas.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1280,1283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1280,1283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Plan Schemas\r\n * TypeScript interfaces for plan.json structure\r\n */\r\n\r\nexport interface PlanSchema {\r\n    version: string;\r\n    project: ProjectInfo;\r\n    phases: Phase[];\r\n    tasks: TaskDefinition[];\r\n    metadata: Metadata;\r\n}\r\n\r\nexport interface ProjectInfo {\r\n    name: string;\r\n    description: string;\r\n    repository?: string;\r\n    createdAt: string;\r\n    updatedAt: string;\r\n}\r\n\r\nexport interface Phase {\r\n    phaseId: string;\r\n    name: string;\r\n    description: string;\r\n    status: 'not-started' | 'in-progress' | 'completed';\r\n    tasks: string[]; // Task IDs\r\n}\r\n\r\nexport interface TaskDefinition {\r\n    taskId: string;\r\n    title: string;\r\n    description: string;\r\n    phase: string;\r\n    priority: 'critical' | 'high' | 'medium' | 'low';\r\n    status: 'pending' | 'ready' | 'in-progress' | 'done' | 'blocked';\r\n    dependencies: string[];\r\n    assignee?: string;\r\n    estimatedHours?: number;\r\n    actualHours?: number;\r\n    tags?: string[];\r\n    githubIssue?: number;\r\n    acceptanceCriteria?: string[];\r\n}\r\n\r\nexport interface Metadata {\r\n    totalTasks: number;\r\n    completedTasks: number;\r\n    progressPercentage: number;\r\n    lastModified: string;\r\n    authors: string[];\r\n}\r\n\r\n/**\r\n * Validate plan structure\r\n */\r\nexport function validatePlan(plan: any): plan is PlanSchema {\r\n    // TODO: Implement comprehensive validation\r\n    return Boolean(\r\n        plan &&\r\n        typeof plan.version === 'string' &&\r\n        typeof plan.project === 'object' &&\r\n        Array.isArray(plan.phases) &&\r\n        Array.isArray(plan.tasks)\r\n    );\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\prompts\\prdGenerationPrompt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\scripts\\update-prd.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":213,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":213,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { promises as fs } from 'fs';\r\nimport path from 'path';\r\nimport { Octokit } from '@octokit/rest';\r\nimport type { RestEndpointMethodTypes } from '@octokit/rest';\r\n\r\ntype IssueData = RestEndpointMethodTypes['issues']['listForRepo']['response']['data'][number];\r\ntype IssueCategory = 'testing' | 'plans';\r\n\r\ninterface IssueUpdate {\r\n    readonly number: number;\r\n    readonly title: string;\r\n    readonly htmlUrl: string;\r\n    readonly category: IssueCategory;\r\n}\r\n\r\nconst PRD_SECTION_HEADER = '## Updates from GitHub Issues';\r\nconst DEFAULT_OWNER = 'xXKillerNoobYT';\r\nconst DEFAULT_REPO = 'Plan-To-Code-AI-Helper-';\r\nconst PRD_FILENAME = 'PRD.md';\r\nconst STATUS_LOG_PATH = path.join('Status', 'status-log.md');\r\n\r\n/**\r\n * ≡ƒÜÇ Fetches open GitHub issues for the configured repository.\r\n *\r\n * @param octokit - Authenticated Octokit client\r\n * @param owner - Repository owner (defaults to configured env var or fallback)\r\n * @param repo - Repository name (defaults to configured env var or fallback)\r\n * @returns Open issues for the repository\r\n */\r\nexport async function fetchOpenIssues(\r\n    octokit: Octokit,\r\n    owner: string,\r\n    repo: string,\r\n): Promise<IssueData[]> {\r\n    const response = await octokit.issues.listForRepo({\r\n        owner,\r\n        repo,\r\n        state: 'open',\r\n        per_page: 100,\r\n    });\r\n\r\n    return response.data;\r\n}\r\n\r\n/**\r\n * ≡ƒöì Determines issue category based on labels.\r\n *\r\n * @param issue - GitHub issue payload\r\n * @returns Issue category or null if uncategorized\r\n */\r\nexport function categorizeIssue(issue: IssueData): IssueCategory | null {\r\n    const labels = (issue.labels ?? []).map((label) =>\r\n        typeof label === 'string' ? label.toLowerCase() : label.name?.toLowerCase() ?? '',\r\n    );\r\n\r\n    if (labels.some((label) => label.includes('bug'))) {\r\n        return 'testing';\r\n    }\r\n\r\n    if (labels.some((label) => label.includes('feature') || label.includes('enhancement'))) {\r\n        return 'plans';\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * ≡ƒº¡ Converts GitHub issues into structured updates for PRD/Status.\r\n *\r\n * @param issues - Open GitHub issues\r\n * @returns Structured updates (filtered to categorized issues)\r\n */\r\nexport function mapIssuesToUpdates(issues: IssueData[]): IssueUpdate[] {\r\n    return issues\r\n        .map((issue) => {\r\n            const category = categorizeIssue(issue);\r\n            if (!category) {\r\n                return null;\r\n            }\r\n\r\n            return {\r\n                number: issue.number,\r\n                title: issue.title.trim(),\r\n                htmlUrl: issue.html_url,\r\n                category,\r\n            } satisfies IssueUpdate;\r\n        })\r\n        .filter((issueUpdate): issueUpdate is IssueUpdate => issueUpdate !== null);\r\n}\r\n\r\n/**\r\n * ≡ƒº▒ Ensures the PRD has an issue update section and appends new entries.\r\n *\r\n * @param prdContent - Existing PRD.md content\r\n * @param updates - Issue updates to append\r\n * @returns Updated PRD content and the issues actually added (deduped)\r\n */\r\nexport function appendIssueUpdatesToPrd(prdContent: string, updates: IssueUpdate[]): {\r\n    readonly content: string;\r\n    readonly added: IssueUpdate[];\r\n} {\r\n    const existingIssueNumbers = new Set<number>();\r\n    const issueNumberPattern = /From issue #(\\d+):/g;\r\n    let match: RegExpExecArray | null;\r\n\r\n    while ((match = issueNumberPattern.exec(prdContent)) !== null) {\r\n        const issueNumber = Number.parseInt(match[1], 10);\r\n        if (!Number.isNaN(issueNumber)) {\r\n            existingIssueNumbers.add(issueNumber);\r\n        }\r\n    }\r\n\r\n    const deduped = updates.filter((update) => !existingIssueNumbers.has(update.number));\r\n\r\n    if (deduped.length === 0) {\r\n        return { content: prdContent, added: [] };\r\n    }\r\n\r\n    let nextContent = prdContent.includes(PRD_SECTION_HEADER)\r\n        ? prdContent.trimEnd()\r\n        : `${prdContent.trimEnd()}\\n\\n${PRD_SECTION_HEADER}`;\r\n\r\n    const updateLines = deduped.map((update) =>\r\n        `- From issue #${update.number}: ${update.title} (${update.htmlUrl}) [${update.category === 'testing' ? 'Testing' : 'Plans'}]`,\r\n    );\r\n\r\n    nextContent = `${nextContent}\\n\\n${updateLines.join('\\n')}\\n`;\r\n\r\n    return { content: nextContent, added: deduped };\r\n}\r\n\r\n/**\r\n * ≡ƒô¥ Appends a dated entry to Status/status-log.md for the provided updates.\r\n *\r\n * @param statusLogContent - Existing status-log content\r\n * @param updates - Issue updates that were written to the PRD\r\n * @param asOfDate - ISO date string (YYYY-MM-DD); defaults to today\r\n * @returns Updated status-log content\r\n */\r\nexport function appendStatusLog(\r\n    statusLogContent: string,\r\n    updates: IssueUpdate[],\r\n    asOfDate: string = new Date().toISOString().split('T')[0],\r\n): string {\r\n    if (updates.length === 0) {\r\n        return statusLogContent;\r\n    }\r\n\r\n    const heading = `## ${asOfDate}: GitHub Issue Sync`;\r\n    const lines = updates.map((update) =>\r\n        `- Issue #${update.number} (${update.category === 'testing' ? 'Testing' : 'Plans'}): ${update.title} (${update.htmlUrl})`,\r\n    );\r\n\r\n    return `${statusLogContent.trimEnd()}\\n\\n${heading}\\n\\n${lines.join('\\n')}\\n`;\r\n}\r\n\r\nasync function loadFile(filePath: string): Promise<string> {\r\n    return fs.readFile(filePath, 'utf8');\r\n}\r\n\r\nasync function saveFile(filePath: string, content: string): Promise<void> {\r\n    await fs.writeFile(filePath, content, 'utf8');\r\n}\r\n\r\nfunction resolveRepoPath(...segments: string[]): string {\r\n    return path.resolve(__dirname, '..', '..', ...segments);\r\n}\r\n\r\n/**\r\n * ≡ƒÄ» Main entry point: fetches issues, updates PRD.md, and appends Status/status-log.md.\r\n */\r\nexport async function run(): Promise<void> {\r\n    const owner = process.env.COE_GITHUB_OWNER ?? DEFAULT_OWNER;\r\n    const repo = process.env.COE_GITHUB_REPO ?? DEFAULT_REPO;\r\n    const token = process.env.GITHUB_TOKEN ?? process.env.GH_TOKEN;\r\n\r\n    if (!token) {\r\n        throw new Error('GITHUB_TOKEN (or GH_TOKEN) is required to fetch GitHub issues.');\r\n    }\r\n\r\n    const octokit = new Octokit({ auth: token });\r\n    const issues = await fetchOpenIssues(octokit, owner, repo);\r\n    const updates = mapIssuesToUpdates(issues);\r\n\r\n    if (updates.length === 0) {\r\n        return;\r\n    }\r\n\r\n    const prdPath = resolveRepoPath(PRD_FILENAME);\r\n    const statusLogPath = resolveRepoPath(STATUS_LOG_PATH);\r\n\r\n    const [prdContent, statusContent] = await Promise.all([\r\n        loadFile(prdPath),\r\n        loadFile(statusLogPath),\r\n    ]);\r\n\r\n    const { content: nextPrd, added } = appendIssueUpdatesToPrd(prdContent, updates);\r\n\r\n    if (added.length === 0) {\r\n        return;\r\n    }\r\n\r\n    const nextStatusLog = appendStatusLog(statusContent, added);\r\n\r\n    await Promise.all([\r\n        saveFile(prdPath, nextPrd),\r\n        saveFile(statusLogPath, nextStatusLog),\r\n    ]);\r\n\r\n}\r\n\r\nif (require.main === module) {\r\n    run().catch((error) => {\r\n        process.exitCode = 1;\r\n    });\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\__tests__\\bossRouter.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9560,9563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9560,9563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":268,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":268,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9752,9755],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9752,9755],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":272,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9956,9959],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9956,9959],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":278,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10219,10222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10219,10222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":284,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":284,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10490,10493],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10490,10493],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":403,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":403,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14727,14730],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14727,14730],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ≡ƒº¬ BossRouter Tests\r\n * \r\n * Comprehensive test suite for the Boss AI Router service\r\n */\r\n\r\nimport { BossRouter } from '../bossRouter';\r\nimport { AgentTeamType } from '../../types/agentTeam';\r\nimport { Ticket } from '../../types/ticket';\r\n\r\ndescribe('BossRouter', () => {\r\n    let router: BossRouter;\r\n\r\n    beforeEach(() => {\r\n        // Get singleton instance and reset rules\r\n        router = BossRouter.getInstance();\r\n        router.resetRules();\r\n    });\r\n\r\n    /**\r\n     * Helper function to create a mock ticket\r\n     */\r\n    function createMockTicket(overrides: Partial<Ticket> = {}): Ticket {\r\n        return {\r\n            ticket_id: 'TK-0001',\r\n            type: 'human_to_ai',\r\n            status: 'open',\r\n            priority: 2,\r\n            creator: 'user',\r\n            assignee: 'unassigned',\r\n            title: 'Sample ticket',\r\n            description: 'Sample details here',  // Changed from \"Test description\" to avoid \"test\" keyword\r\n            thread: [],\r\n            created_at: new Date(),\r\n            updated_at: new Date(),\r\n            ...overrides\r\n        };\r\n    }\r\n\r\n    describe('Singleton Pattern', () => {\r\n        it('should return the same instance on multiple calls', () => {\r\n            const instance1 = BossRouter.getInstance();\r\n            const instance2 = BossRouter.getInstance();\r\n            expect(instance1).toBe(instance2);\r\n        });\r\n    });\r\n\r\n    describe('AI to Human Routing (Rule 1)', () => {\r\n        it('should route ai_to_human tickets to Answer Team', () => {\r\n            const ticket = createMockTicket({\r\n                type: 'ai_to_human',\r\n                title: 'Need clarification on feature X',\r\n                priority: 2\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Answer);\r\n        });\r\n\r\n        it('should route ai_to_human with any priority to Answer Team', () => {\r\n            const p1Ticket = createMockTicket({ type: 'ai_to_human', priority: 1 });\r\n            const p3Ticket = createMockTicket({ type: 'ai_to_human', priority: 3 });\r\n\r\n            expect(router.routeTicket(p1Ticket)).toBe(AgentTeamType.Answer);\r\n            expect(router.routeTicket(p3Ticket)).toBe(AgentTeamType.Answer);\r\n        });\r\n    });\r\n\r\n    describe('P1 Planning Routing (Rule 2)', () => {\r\n        it('should route P1 tickets with \"plan\" keyword to Planning Team', () => {\r\n            const ticket = createMockTicket({\r\n                priority: 1,\r\n                title: 'Create a plan for new feature',\r\n                type: 'human_to_ai'\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Planning);\r\n        });\r\n\r\n        it('should route P1 tickets with \"define\" keyword to Planning Team', () => {\r\n            const ticket = createMockTicket({\r\n                priority: 1,\r\n                title: 'Define architecture for module X',\r\n                type: 'human_to_ai'\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Planning);\r\n        });\r\n\r\n        it('should route P1 tickets with planning keywords in description', () => {\r\n            const ticket = createMockTicket({\r\n                priority: 1,\r\n                title: 'Feature request',\r\n                description: 'Need to breakdown this into smaller tasks',\r\n                type: 'human_to_ai'\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Planning);\r\n        });\r\n\r\n        it('should NOT route P2/P3 planning keywords to Planning Team unless it matches another rule', () => {\r\n            const ticket = createMockTicket({\r\n                priority: 2,\r\n                title: 'Implement plan for something',  // Has both planning and implementation keywords\r\n                type: 'human_to_ai'\r\n            });\r\n\r\n            // Should match \"Implementation Request\" rule (priority 40) instead of P1 Planning (priority 90)\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Planning); // Still planning, but via Implementation rule\r\n        });\r\n    });\r\n\r\n    describe('Verification Routing (Rule 3)', () => {\r\n        it('should route tickets with \"verify\" keyword to Verification Team', () => {\r\n            const ticket = createMockTicket({\r\n                title: 'Verify test coverage',\r\n                priority: 2\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Verification);\r\n        });\r\n\r\n        it('should route tickets with \"test\" keyword to Verification Team', () => {\r\n            const ticket = createMockTicket({\r\n                title: 'Test the new feature',\r\n                priority: 2\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Verification);\r\n        });\r\n\r\n        it('should route tickets with \"check\" keyword to Verification Team', () => {\r\n            const ticket = createMockTicket({\r\n                description: 'Need to check code quality',\r\n                priority: 3\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Verification);\r\n        });\r\n    });\r\n\r\n    describe('Research Routing (Rule 4)', () => {\r\n        it('should route tickets with \"research\" keyword to Research Team', () => {\r\n            const ticket = createMockTicket({\r\n                title: 'Research best practices for X',\r\n                priority: 2\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Research);\r\n        });\r\n\r\n        it('should route tickets with \"investigate\" keyword to Research Team', () => {\r\n            const ticket = createMockTicket({\r\n                description: 'Investigate why feature is slow',\r\n                priority: 2\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Research);\r\n        });\r\n\r\n        it('should route tickets with \"explore\" keyword to Research Team', () => {\r\n            const ticket = createMockTicket({\r\n                title: 'Explore alternatives for database',\r\n                priority: 3\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Research);\r\n        });\r\n    });\r\n\r\n    describe('Question Routing (Rule 5)', () => {\r\n        it('should route human questions to Answer Team', () => {\r\n            const ticket = createMockTicket({\r\n                type: 'human_to_ai',\r\n                title: 'What is the best way to implement X?',\r\n                priority: 2\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Answer);\r\n        });\r\n\r\n        it('should route tickets with \"how\" keyword to Answer Team', () => {\r\n            const ticket = createMockTicket({\r\n                type: 'human_to_ai',\r\n                title: 'How does the routing work?',\r\n                priority: 3\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Answer);\r\n        });\r\n\r\n        it('should route tickets with \"?\" to Answer Team', () => {\r\n            const ticket = createMockTicket({\r\n                type: 'human_to_ai',\r\n                description: 'Is this the right approach?',\r\n                priority: 2\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Answer);\r\n        });\r\n    });\r\n\r\n    describe('P1 Default Routing (Rule 6)', () => {\r\n        it('should route P1 tickets without specific keywords to Planning Team', () => {\r\n            const ticket = createMockTicket({\r\n                priority: 1,\r\n                title: 'Urgent task',\r\n                description: 'This needs attention',\r\n                type: 'human_to_ai'\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Planning);\r\n        });\r\n    });\r\n\r\n    describe('Implementation Routing (Rule 7)', () => {\r\n        it('should route tickets with \"implement\" keyword to Planning Team', () => {\r\n            const ticket = createMockTicket({\r\n                title: 'Implement new router',\r\n                priority: 2\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Planning);\r\n        });\r\n\r\n        it('should route tickets with \"build\" keyword to Planning Team', () => {\r\n            const ticket = createMockTicket({\r\n                description: 'Build a new component',\r\n                priority: 3\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Planning);\r\n        });\r\n\r\n        it('should route tickets with \"fix\" keyword to Planning Team', () => {\r\n            const ticket = createMockTicket({\r\n                title: 'Fix bug in authentication',\r\n                priority: 2\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Planning);\r\n        });\r\n    });\r\n\r\n    describe('Edge Cases', () => {\r\n        it('should throw error for null ticket', () => {\r\n            expect(() => router.routeTicket(null as any)).toThrow('Cannot route null or undefined ticket');\r\n        });\r\n\r\n        it('should throw error for undefined ticket', () => {\r\n            expect(() => router.routeTicket(undefined as any)).toThrow('Cannot route null or undefined ticket');\r\n        });\r\n\r\n        it('should escalate ticket with missing ticket_id', () => {\r\n            const ticket = createMockTicket({ ticket_id: '' as any });\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Escalate);\r\n        });\r\n\r\n        it('should escalate ticket with missing type', () => {\r\n            const ticket = createMockTicket({ type: undefined as any });\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Escalate);\r\n        });\r\n\r\n        it('should escalate ticket with missing priority', () => {\r\n            const ticket = createMockTicket({ priority: undefined as any });\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Escalate);\r\n        });\r\n\r\n        it('should escalate ticket with no matching rules', () => {\r\n            const ticket = createMockTicket({\r\n                title: 'Random task',\r\n                description: 'No keywords here',\r\n                priority: 3,\r\n                type: 'human_to_ai'\r\n            });\r\n\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Escalate);\r\n        });\r\n    });\r\n\r\n    describe('Rule Priority', () => {\r\n        it('should prioritize ai_to_human over planning keywords', () => {\r\n            const ticket = createMockTicket({\r\n                type: 'ai_to_human',\r\n                priority: 1,\r\n                title: 'Plan this feature' // Has planning keyword\r\n            });\r\n\r\n            // ai_to_human has higher priority (100) than P1 Planning (90)\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Answer);\r\n        });\r\n\r\n        it('should prioritize verification over implementation', () => {\r\n            const ticket = createMockTicket({\r\n                title: 'Implement and verify feature',\r\n                priority: 2\r\n            });\r\n\r\n            // Verification (80) has higher priority than Implementation (40)\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Verification);\r\n        });\r\n    });\r\n\r\n    describe('Extensibility', () => {\r\n        it('should allow adding custom rules', () => {\r\n            router.addRule({\r\n                name: 'Custom Rule',\r\n                priority: 200, // Highest priority\r\n                condition: (ticket) => ticket.title.includes('custom'),\r\n                team: AgentTeamType.Research\r\n            });\r\n\r\n            const ticket = createMockTicket({\r\n                type: 'ai_to_human', // Would normally go to Answer\r\n                title: 'custom request'\r\n            });\r\n\r\n            // Custom rule should win due to higher priority\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Research);\r\n        });\r\n\r\n        it('should allow resetting rules to default', () => {\r\n            router.addRule({\r\n                name: 'Custom Rule',\r\n                priority: 200,\r\n                condition: (ticket) => ticket.title.includes('custom'),\r\n                team: AgentTeamType.Research\r\n            });\r\n\r\n            router.resetRules();\r\n\r\n            const ticket = createMockTicket({\r\n                type: 'ai_to_human',\r\n                title: 'custom request'\r\n            });\r\n\r\n            // After reset, should use default rules\r\n            const team = router.routeTicket(ticket);\r\n            expect(team).toBe(AgentTeamType.Answer);\r\n        });\r\n\r\n        it('should expose rules for inspection', () => {\r\n            const rules = router.getRules();\r\n            expect(rules).toBeDefined();\r\n            expect(rules.length).toBeGreaterThan(0);\r\n            expect(rules[0]).toHaveProperty('name');\r\n            expect(rules[0]).toHaveProperty('priority');\r\n            expect(rules[0]).toHaveProperty('condition');\r\n            expect(rules[0]).toHaveProperty('team');\r\n        });\r\n    });\r\n\r\n    describe('Logging', () => {\r\n        let consoleLogSpy: jest.SpyInstance;\r\n        let consoleWarnSpy: jest.SpyInstance;\r\n\r\n        beforeEach(() => {\r\n            consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();\r\n            consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();\r\n        });\r\n\r\n        afterEach(() => {\r\n            consoleLogSpy.mockRestore();\r\n            consoleWarnSpy.mockRestore();\r\n        });\r\n\r\n        it('should route ticket successfully', () => {\r\n            const ticket = createMockTicket({\r\n                type: 'ai_to_human',\r\n                ticket_id: 'TK-1234'\r\n            });\r\n\r\n            const result = router.routeTicket(ticket);\r\n\r\n            expect(result).toBeDefined();\r\n        });\r\n\r\n        it('should handle invalid ticket data', () => {\r\n            const ticket = createMockTicket({ priority: undefined as any });\r\n            const result = router.routeTicket(ticket);\r\n\r\n            expect(result).toBe(AgentTeamType.Escalate);\r\n        });\r\n\r\n        it('should handle when no rule matches', () => {\r\n            const ticket = createMockTicket({\r\n                title: 'No match',\r\n                description: 'No keywords',\r\n                priority: 3\r\n            });\r\n\r\n            const result = router.routeTicket(ticket);\r\n\r\n            expect(result).toBeDefined();\r\n        });\r\n    });\r\n});\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\__tests__\\contextBundler.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\__tests__\\hello-world.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\__tests__\\plansReader.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[597,600],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[597,600],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[947,950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[947,950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Plans Reader Service Tests\r\n */\r\n\r\nimport { PlansReader } from '../plansReader';\r\nimport * as vscode from 'vscode';\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\n\r\n// Mock vscode\r\njest.mock('vscode');\r\n\r\n// Mock fs/promises\r\njest.mock('fs/promises');\r\n\r\ndescribe('PlansReader', () => {\r\n    const mockWorkspacePath = '/mock/workspace';\r\n    const mockPlansPath = path.join(mockWorkspacePath, 'Plans');\r\n\r\n    beforeEach(() => {\r\n        // Reset all mocks\r\n        jest.clearAllMocks();\r\n\r\n        // Setup default vscode workspace mock\r\n        (vscode.workspace as any).workspaceFolders = [\r\n            {\r\n                uri: { fsPath: mockWorkspacePath },\r\n                name: 'test-workspace',\r\n                index: 0\r\n            }\r\n        ];\r\n    });\r\n\r\n    describe('readAllPlans', () => {\r\n        it('should throw error when no workspace folder found', async () => {\r\n            (vscode.workspace as any).workspaceFolders = undefined;\r\n\r\n            await expect(PlansReader.readAllPlans()).rejects.toThrow(\r\n                'No workspace folder found'\r\n            );\r\n        });\r\n\r\n        it('should throw error when Plans directory does not exist', async () => {\r\n            (fs.access as jest.Mock).mockRejectedValue(new Error('ENOENT'));\r\n\r\n            await expect(PlansReader.readAllPlans()).rejects.toThrow(\r\n                `Plans directory not found at ${mockPlansPath}`\r\n            );\r\n        });\r\n\r\n        it('should read all markdown files from Plans folder', async () => {\r\n            // Mock Plans directory exists\r\n            (fs.access as jest.Mock).mockResolvedValue(undefined);\r\n\r\n            // Mock directory structure\r\n            const mockEntries = [\r\n                {\r\n                    name: 'CONSOLIDATED-MASTER-PLAN.md',\r\n                    isDirectory: () => false\r\n                },\r\n                {\r\n                    name: 'README.md',\r\n                    isDirectory: () => false\r\n                },\r\n                {\r\n                    name: '02-Agent-Role-Definitions.md',\r\n                    isDirectory: () => false\r\n                }\r\n            ];\r\n\r\n            (fs.readdir as jest.Mock).mockResolvedValue(mockEntries);\r\n            (fs.readFile as jest.Mock).mockImplementation((filePath: string) => {\r\n                const fileName = path.basename(filePath);\r\n                return Promise.resolve(`# ${fileName}\\n\\nContent for ${fileName}`);\r\n            });\r\n            (fs.stat as jest.Mock).mockResolvedValue({ size: 1234 });\r\n\r\n            const files = await PlansReader.readAllPlans();\r\n\r\n            expect(files.length).toBe(3);\r\n            expect(files.every(f => f.name.endsWith('.md'))).toBe(true);\r\n            expect(files[0].content).toContain('CONSOLIDATED-MASTER-PLAN.md');\r\n        });\r\n\r\n        it('should filter out backup and temp files', async () => {\r\n            (fs.access as jest.Mock).mockResolvedValue(undefined);\r\n\r\n            const mockEntries = [\r\n                { name: 'CONSOLIDATED-MASTER-PLAN.md', isDirectory: () => false },\r\n                { name: 'old-plan.md', isDirectory: () => false },\r\n                { name: 'temp-notes.md', isDirectory: () => false },\r\n                { name: '.hidden.md', isDirectory: () => false },\r\n                { name: 'notebook.ipynb', isDirectory: () => false },\r\n                { name: 'backup.md.backup', isDirectory: () => false },\r\n                { name: 'README.md', isDirectory: () => false }\r\n            ];\r\n\r\n            (fs.readdir as jest.Mock).mockResolvedValue(mockEntries);\r\n            (fs.readFile as jest.Mock).mockResolvedValue('# Content');\r\n            (fs.stat as jest.Mock).mockResolvedValue({ size: 100 });\r\n\r\n            const files = await PlansReader.readAllPlans();\r\n\r\n            // Should only include CONSOLIDATED-MASTER-PLAN.md and README.md\r\n            expect(files.length).toBe(2);\r\n            expect(files.some(f => f.name.startsWith('old-'))).toBe(false);\r\n            expect(files.some(f => f.name.startsWith('temp-'))).toBe(false);\r\n            expect(files.some(f => f.name.startsWith('.'))).toBe(false);\r\n            expect(files.some(f => f.name.endsWith('.ipynb'))).toBe(false);\r\n            expect(files.some(f => f.name.endsWith('.backup'))).toBe(false);\r\n        });\r\n\r\n        it('should recursively read subdirectories', async () => {\r\n            (fs.access as jest.Mock).mockResolvedValue(undefined);\r\n\r\n            // First call to readdir (Plans/)\r\n            // Second call to readdir (Plans/COE-Master-Plan/)\r\n            (fs.readdir as jest.Mock)\r\n                .mockResolvedValueOnce([\r\n                    { name: 'README.md', isDirectory: () => false },\r\n                    { name: 'COE-Master-Plan', isDirectory: () => true }\r\n                ])\r\n                .mockResolvedValueOnce([\r\n                    { name: '01-Architecture-Document.md', isDirectory: () => false }\r\n                ]);\r\n\r\n            (fs.readFile as jest.Mock).mockResolvedValue('# Content');\r\n            (fs.stat as jest.Mock).mockResolvedValue({ size: 200 });\r\n\r\n            const files = await PlansReader.readAllPlans();\r\n\r\n            expect(files.length).toBe(2);\r\n            expect(files.some(f => f.name === 'README.md')).toBe(true);\r\n            expect(files.some(f => f.name === '01-Architecture-Document.md')).toBe(true);\r\n        });\r\n\r\n        it('should prioritize files correctly', async () => {\r\n            (fs.access as jest.Mock).mockResolvedValue(undefined);\r\n\r\n            const mockEntries = [\r\n                { name: 'random-file.md', isDirectory: () => false },\r\n                { name: 'CONSOLIDATED-MASTER-PLAN.md', isDirectory: () => false },\r\n                { name: 'README.md', isDirectory: () => false },\r\n                { name: '02-Agent-Role-Definitions.md', isDirectory: () => false }\r\n            ];\r\n\r\n            (fs.readdir as jest.Mock).mockResolvedValue(mockEntries);\r\n            (fs.readFile as jest.Mock).mockResolvedValue('# Content');\r\n            (fs.stat as jest.Mock).mockResolvedValue({ size: 300 });\r\n\r\n            const files = await PlansReader.readAllPlans();\r\n\r\n            // Should be sorted by priority\r\n            expect(files[0].name).toBe('CONSOLIDATED-MASTER-PLAN.md');\r\n            expect(files[0].priority).toBe(1);\r\n            expect(files[1].name).toBe('README.md');\r\n            expect(files[1].priority).toBe(2);\r\n            expect(files[2].name).toBe('02-Agent-Role-Definitions.md');\r\n            expect(files[2].priority).toBe(3);\r\n            expect(files[3].name).toBe('random-file.md');\r\n            expect(files[3].priority).toBe(999); // Default priority\r\n        });\r\n\r\n        it('should categorize files correctly', async () => {\r\n            (fs.access as jest.Mock).mockResolvedValue(undefined);\r\n\r\n            const mockEntries = [\r\n                { name: 'Agent-Role-Definitions.md', isDirectory: () => false },\r\n                { name: 'MCP-API-Reference.md', isDirectory: () => false },\r\n                { name: 'Workflow-Guide.md', isDirectory: () => false },\r\n                { name: 'Architecture-Document.md', isDirectory: () => false },\r\n                { name: 'random-notes.md', isDirectory: () => false }\r\n            ];\r\n\r\n            (fs.readdir as jest.Mock).mockResolvedValue(mockEntries);\r\n            (fs.readFile as jest.Mock).mockResolvedValue('# Content');\r\n            (fs.stat as jest.Mock).mockResolvedValue({ size: 400 });\r\n\r\n            const files = await PlansReader.readAllPlans();\r\n\r\n            const agentFile = files.find(f => f.name.includes('Agent'));\r\n            const mcpFile = files.find(f => f.name.includes('MCP'));\r\n            const workflowFile = files.find(f => f.name.includes('Workflow'));\r\n            const archFile = files.find(f => f.name.includes('Architecture'));\r\n            const randomFile = files.find(f => f.name === 'random-notes.md');\r\n\r\n            expect(agentFile?.category).toBe('agent-spec');\r\n            expect(mcpFile?.category).toBe('api-reference');\r\n            expect(workflowFile?.category).toBe('workflow');\r\n            expect(archFile?.category).toBe('architecture');\r\n            expect(randomFile?.category).toBe('general');\r\n        });\r\n\r\n        it('should handle file read errors gracefully', async () => {\r\n            (fs.access as jest.Mock).mockResolvedValue(undefined);\r\n\r\n            const mockEntries = [\r\n                { name: 'good-file.md', isDirectory: () => false },\r\n                { name: 'bad-file.md', isDirectory: () => false }\r\n            ];\r\n\r\n            (fs.readdir as jest.Mock).mockResolvedValue(mockEntries);\r\n            (fs.readFile as jest.Mock).mockImplementation((filePath: string) => {\r\n                if (filePath.includes('bad-file')) {\r\n                    return Promise.reject(new Error('Permission denied'));\r\n                }\r\n                return Promise.resolve('# Content');\r\n            });\r\n            (fs.stat as jest.Mock).mockResolvedValue({ size: 500 });\r\n\r\n            const files = await PlansReader.readAllPlans();\r\n\r\n            // Should only include the successfully read file\r\n            expect(files.length).toBe(1);\r\n            expect(files[0].name).toBe('good-file.md');\r\n        });\r\n\r\n        it('should include all expected fields in PlanFile objects', async () => {\r\n            (fs.access as jest.Mock).mockResolvedValue(undefined);\r\n\r\n            const mockEntries = [\r\n                { name: 'test-plan.md', isDirectory: () => false }\r\n            ];\r\n\r\n            (fs.readdir as jest.Mock).mockResolvedValue(mockEntries);\r\n            (fs.readFile as jest.Mock).mockResolvedValue('# Test Plan\\n\\nThis is test content.');\r\n            (fs.stat as jest.Mock).mockResolvedValue({ size: 42 });\r\n\r\n            const files = await PlansReader.readAllPlans();\r\n\r\n            expect(files.length).toBe(1);\r\n            const file = files[0];\r\n\r\n            expect(file.path).toBe(path.join(mockPlansPath, 'test-plan.md'));\r\n            expect(file.relativeDir).toBe('.'); // Root of Plans folder\r\n            expect(file.name).toBe('test-plan.md');\r\n            expect(file.size).toBe(42);\r\n            expect(file.content).toBe('# Test Plan\\n\\nThis is test content.');\r\n            expect(file.category).toBeDefined();\r\n            expect(file.priority).toBeDefined();\r\n        });\r\n    });\r\n\r\n    describe('estimateTokens', () => {\r\n        it('should estimate tokens for content', () => {\r\n            const content = 'This is a test content with exactly 40 characters.';\r\n            const tokens = PlansReader.estimateTokens(content);\r\n\r\n            // Should be roughly 1 token per 4 characters\r\n            expect(tokens).toBe(Math.ceil(50 / 4)); // 13 tokens\r\n        });\r\n\r\n        it('should return 0 for empty content', () => {\r\n            const tokens = PlansReader.estimateTokens('');\r\n            expect(tokens).toBe(0);\r\n        });\r\n\r\n        it('should handle large content', () => {\r\n            const largeContent = 'a'.repeat(10000);\r\n            const tokens = PlansReader.estimateTokens(largeContent);\r\n\r\n            expect(tokens).toBe(Math.ceil(10000 / 4)); // 2500 tokens\r\n        });\r\n\r\n        it('should round up partial tokens', () => {\r\n            const content = 'abc'; // 3 characters\r\n            const tokens = PlansReader.estimateTokens(content);\r\n\r\n            expect(tokens).toBe(1); // Should round up from 0.75\r\n        });\r\n\r\n        it('should estimate tokens for markdown content', () => {\r\n            const markdown = '# Heading\\n\\n**Bold text** and *italic text*\\n\\n- List item 1\\n- List item 2';\r\n            const tokens = PlansReader.estimateTokens(markdown);\r\n\r\n            expect(tokens).toBeGreaterThan(0);\r\n            expect(tokens).toBe(Math.ceil(markdown.length / 4));\r\n        });\r\n    });\r\n\r\n    describe('getCategoryLabel', () => {\r\n        it('should return correct labels for known categories', () => {\r\n            expect(PlansReader.getCategoryLabel('agent-spec')).toBe('Agent Specification');\r\n            expect(PlansReader.getCategoryLabel('api-reference')).toBe('API Reference');\r\n            expect(PlansReader.getCategoryLabel('workflow')).toBe('Workflow');\r\n            expect(PlansReader.getCategoryLabel('architecture')).toBe('Architecture');\r\n            expect(PlansReader.getCategoryLabel('general')).toBe('General');\r\n        });\r\n\r\n        it('should return Unknown for unrecognized category', () => {\r\n            expect(PlansReader.getCategoryLabel('unknown-category')).toBe('Unknown');\r\n            expect(PlansReader.getCategoryLabel('random')).toBe('Unknown');\r\n        });\r\n\r\n        it('should handle undefined category', () => {\r\n            expect(PlansReader.getCategoryLabel(undefined)).toBe('General');\r\n        });\r\n\r\n        it('should handle empty string category', () => {\r\n            expect(PlansReader.getCategoryLabel('')).toBe('General'); // Empty string uses default\r\n        });\r\n    });\r\n});\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\__tests__\\prdGenerator.e2e.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'msg' is assigned a value but never used.","line":115,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":115,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalFolders' is assigned a value but never used.","line":124,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":124,"endColumn":38},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4453,4456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4453,4456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4508,4511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4508,4511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Phase 0 End-to-End Integration Test\r\n * \r\n * Verify PRD generation works end-to-end:\r\n * - Reads Plans/ folder\r\n * - Bundles content\r\n * - Handles token limits\r\n * - Validates output\r\n * - Writes files\r\n */\r\n\r\nimport { PlansReader } from '../plansReader';\r\nimport { ContextBundler } from '../contextBundler';\r\nimport { PRDGenerationPrompt } from '../../prompts/prdGenerationPrompt';\r\nimport { PRDWriter } from '../prdWriter';\r\n\r\ndescribe('Phase 0: PRD Generation E2E', () => {\r\n    describe('PlansReader ΓåÆ ContextBundler ΓåÆ Validation ΓåÆ Writer', () => {\r\n        it('should read plans and bundle them correctly', async () => {\r\n            try {\r\n                // Step 1: Read plans\r\n                const planFiles = await PlansReader.readAllPlans();\r\n\r\n                if (planFiles.length === 0) {\r\n                    expect(true).toBe(true);  // Test passes with no files\r\n                    return;\r\n                }\r\n\r\n\r\n                // Step 2: Bundle with token limit\r\n                const bundle = ContextBundler.bundle(planFiles, 4000);\r\n\r\n                expect(bundle.prompt).toBeDefined();\r\n                expect(bundle.prompt.length).toBeGreaterThan(100);\r\n                expect(bundle.includedFiles.length).toBeGreaterThan(0);\r\n                expect(bundle.totalTokens).toBeLessThanOrEqual(4000 + 500); // Small buffer\r\n\r\n\r\n                // Step 3: Create prompts\r\n                const systemPrompt = PRDGenerationPrompt.getSystemPrompt();\r\n                const userPrompt = PRDGenerationPrompt.getUserPrompt(bundle.prompt);\r\n\r\n                expect(systemPrompt).toContain('technical documentation');\r\n                expect(userPrompt).toContain('Overview');\r\n                expect(userPrompt).toContain('Features');\r\n\r\n\r\n                // Step 4: Mock PRD generation\r\n                const mockPRD = `\r\n## Overview\r\nThis is a test project overview.\r\n\r\n## Features\r\n- Feature 1: Authentication\r\n- Feature 2: Authorization\r\n\r\n## Architecture\r\nThe system uses a microservices architecture.\r\n\r\n## Testing\r\nWe use Jest for testing.\r\n\r\n## Deployment\r\nDeploy via CI/CD pipeline.\r\n\r\n## Priorities\r\n- P1: Auth system\r\n- P2: Dashboard\r\n`;\r\n\r\n                const validation = PRDGenerationPrompt.validatePRDOutput(mockPRD);\r\n\r\n                expect(validation.isValid).toBe(true);\r\n                expect(validation.missingSection).toBeUndefined();\r\n\r\n\r\n                // Step 5: Test truncation handling\r\n                const largeFiles = [\r\n                    ...planFiles,\r\n                    {\r\n                        path: '/Plans/huge-file.md',\r\n                        relativeDir: 'Plans',\r\n                        name: 'huge-file.md',\r\n                        size: 1000000,\r\n                        content: 'a'.repeat(100000),\r\n                    },\r\n                ];\r\n\r\n                const limitedBundle = ContextBundler.bundle(largeFiles, 1000);\r\n\r\n                expect(limitedBundle.totalTokens).toBeLessThanOrEqual(1000 + 100);\r\n                if (limitedBundle.truncatedFiles.length > 0 || limitedBundle.excludedFiles.length > 0) {\r\n                    expect(limitedBundle.warning).toBeDefined();\r\n                }\r\n\r\n                // Step 6: Test metadata creation\r\n                const metadata = PRDWriter.createMetadata(\r\n                    bundle.includedFiles,\r\n                    bundle.totalTokens\r\n                );\r\n\r\n                expect(metadata.generatedAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T/);\r\n                expect(metadata.version).toBe('1.0.0');\r\n                expect(metadata.generatedFrom.length).toBeGreaterThan(0);\r\n                expect(metadata.tokenCount).toBe(bundle.totalTokens);\r\n\r\n\r\n            } catch (error) {\r\n                // In test environment without VS Code workspace, workspace errors are expected\r\n                if (error instanceof Error && error.message.includes('No workspace folder')) {\r\n                    expect(true).toBe(true);  // Test passes - this error is acceptable\r\n                    return;\r\n                }\r\n\r\n                const msg = error instanceof Error ? error.message : String(error);\r\n                throw error;\r\n            }\r\n        });\r\n\r\n        it('should handle missing Plans folder gracefully', async () => {\r\n            // This test verifies error handling\r\n            try {\r\n                // Temporarily mock workspace folders to empty\r\n                const originalFolders = (global as any).mockWorkspaceFolders;\r\n                (global as any).mockWorkspaceFolders = [];\r\n\r\n                try {\r\n                    await PlansReader.readAllPlans();\r\n                    fail('Should have thrown error');\r\n                } catch (error) {\r\n                    if (error instanceof Error) {\r\n                        expect(error.message).toContain('No workspace folder');\r\n                    }\r\n                }\r\n            } catch (error) {\r\n                // Expected in test environment\r\n            }\r\n        });\r\n\r\n        it('should validate bad PRD output', () => {\r\n            const badPRD = 'This is not a valid PRD format';\r\n\r\n            const validation = PRDGenerationPrompt.validatePRDOutput(badPRD);\r\n\r\n            expect(validation.isValid).toBe(false);\r\n            expect(validation.missingSection).toBeDefined();\r\n            expect(validation.warnings).toBeDefined();\r\n\r\n        });\r\n    });\r\n});\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\__tests__\\prdGenerator.integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'status' is defined but never used.","line":17,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'status' is defined but never used.","line":34,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PRD Generator Integration Tests\r\n * \r\n * These tests verify the full PRD generation workflow\r\n */\r\n\r\nimport { PRDGenerator } from '../prdGenerator';\r\n\r\ndescribe('PRDGenerator Integration', () => {\r\n    describe('generate', () => {\r\n        it('should handle missing Plans folder gracefully', async () => {\r\n            // This test expects the generate function to fail gracefully\r\n            // when no Plans folder exists (common in test environments)\r\n            try {\r\n                const result = await PRDGenerator.generate(\r\n                    { tokenLimit: 2000 },\r\n                    (status) => { /* process status */ }\r\n                );\r\n\r\n                // Should either succeed or fail gracefully\r\n                expect(result).toBeDefined();\r\n                expect(result.success).toBeDefined();\r\n                expect(result.message).toBeDefined();\r\n            } catch (error) {\r\n                // If it throws, that's also acceptable in test env\r\n                expect(error).toBeDefined();\r\n            }\r\n        });\r\n\r\n        it('should respect token limit setting', async () => {\r\n            try {\r\n                const result = await PRDGenerator.generate(\r\n                    { tokenLimit: 1000 },\r\n                    (status) => { /* process status */ }\r\n                );\r\n\r\n                if (result.success && result.tokenCount) {\r\n                    expect(result.tokenCount).toBeLessThanOrEqual(1000);\r\n                }\r\n            } catch {\r\n                // Expected in test environment\r\n            }\r\n        });\r\n\r\n        it('should call status callback during generation', async () => {\r\n            const statuses: string[] = [];\r\n\r\n            try {\r\n                await PRDGenerator.generate(\r\n                    { tokenLimit: 1000 },\r\n                    (status) => statuses.push(status)\r\n                );\r\n\r\n                // Either we got statuses or an error in test env\r\n                expect(Array.isArray(statuses)).toBe(true);\r\n            } catch {\r\n                // Expected in test environment\r\n            }\r\n        });\r\n    });\r\n\r\n    describe('LLM response parsing', () => {\r\n        it('should handle streaming response format', async () => {\r\n            // This is tested indirectly through the full generate flow\r\n            // The parseStreamingResponse method is private but tested via generate\r\n            try {\r\n                const result = await PRDGenerator.generate({ tokenLimit: 500 });\r\n                expect(result).toBeDefined();\r\n            } catch {\r\n                // Expected in test environment\r\n            }\r\n        });\r\n    });\r\n});\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\__tests__\\prdWriter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\__tests__\\ticketDb.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Ticket' is defined but never used.","line":1,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Reply' is defined but never used.","line":1,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fs' is defined but never used.","line":2,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":3,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'skipInBrowser' is assigned a value but never used.","line":8,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[776,779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[776,779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ticket' is assigned a value but never used.","line":653,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":653,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ticket' is assigned a value but never used.","line":665,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":665,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import TicketDb, { Ticket, Reply, TicketError } from '../ticketDb';\r\nimport * as fs from 'fs';\r\nimport path from 'path';\r\n\r\n/**\r\n * Skip these tests in browser environment (no native SQLite)\r\n */\r\nconst skipInBrowser = process.env.JEST_ENVIRONMENT === 'jsdom' ? describe.skip : describe;\r\n\r\n/**\r\n * Task Priority Levels\r\n */\r\nexport type TaskPriority = 'P1' | 'P2' | 'P3';\r\n\r\n/**\r\n * Task Status States\r\n */\r\nexport type TaskStatus = 'ready' | 'inProgress' | 'completed' | 'blocked' | 'failed';\r\n\r\n/**\r\n * Metadata for tasks routed from tickets\r\n */\r\nexport interface TaskMetadata {\r\n  ticketId?: string;\r\n  routedTeam?: 'ANSWER' | 'PLANNING' | 'VERIFICATION' | 'ESCALATE';\r\n  routingReason?: string;\r\n  routingConfidence?: number;\r\n  isEscalated?: boolean;\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Task in the programming orchestrator queue\r\n * \r\n * Represents a unit of work that can be executed by agents.\r\n * Tasks are created from plan items or routed from tickets.\r\n * \r\n * @interface Task\r\n */\r\nexport interface Task {\r\n  taskId: string;\r\n  title: string;\r\n  description: string;\r\n  priority: TaskPriority;\r\n  status: TaskStatus;\r\n  dependencies: string[];\r\n  blockedBy: string[];\r\n  estimatedHours: number;\r\n  actualHours?: number;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  startedAt?: Date;\r\n  completedAt?: Date;\r\n  assignedTo?: string;\r\n\r\n  // NEW: Metadata for tasks from tickets\r\n  metadata?: TaskMetadata;\r\n}\r\n\r\n/**\r\n * Persisted task format (excludes large contextBundles)\r\n */\r\nexport interface PersistedTask extends Omit<Task, 'createdAt' | 'updatedAt' | 'startedAt' | 'completedAt'> {\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  startedAt?: string;\r\n  completedAt?: string;\r\n}\r\n\r\n/**\r\n * Test suite for TicketDb service\r\n * Covers: initialization, CRUD operations, fallback mode, threading\r\n */\r\ndescribe('TicketDb', () => {\r\n  let ticketDb: TicketDb;\r\n\r\n  // Increase timeout to handle async operations\r\n  jest.setTimeout(15000);\r\n\r\n  beforeEach(async () => {\r\n    // Use in-memory database for tests (no file locking issues)\r\n    ticketDb = new TicketDb(':memory:');\r\n  });\r\n\r\n  afterEach(async () => {\r\n    // Close database\r\n    try {\r\n      await ticketDb.close();\r\n    } catch (err) {\r\n      // Ignore close errors for in-memory DB\r\n    }\r\n  });\r\n\r\n  // ============================================================================\r\n  // Initialization Tests\r\n  // ============================================================================\r\n\r\n  describe('init()', () => {\r\n    it('should initialize SQLite database successfully', async () => {\r\n      await ticketDb.init();\r\n      // In-memory database initialized (no file needed)\r\n      expect(ticketDb).toBeDefined();\r\n    });\r\n\r\n    it('should create required tables', async () => {\r\n      await ticketDb.init();\r\n\r\n      // Give filesystem a moment to flush\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Test',\r\n        description: 'Test ticket',\r\n      });\r\n      expect(ticket.id).toBeDefined();\r\n    });\r\n\r\n    it('should enable foreign key constraints', async () => {\r\n      await ticketDb.init();\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Test',\r\n        description: 'Test',\r\n      });\r\n      const reply = await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        content: 'Reply',\r\n      });\r\n      expect(reply.ticketId).toBe(ticket.id);\r\n    });\r\n\r\n    it('creates tickets table with id column as PRIMARY KEY', async () => {\r\n      await ticketDb.init();\r\n\r\n      // Verify by creating a ticket (which inserts into id column)\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Test with ID',\r\n        description: 'Verifies id column exists',\r\n        type: 'ai_to_human',\r\n        priority: 1,\r\n      });\r\n\r\n      expect(ticket.id).toBeDefined();\r\n      expect(ticket.id).toMatch(/^ticket_\\d+_[a-z0-9]+$/);\r\n\r\n      // Verify retrieval by id works (proves PRIMARY KEY constraint)\r\n      const retrieved = await ticketDb.getTicket(ticket.id);\r\n      expect(retrieved).not.toBeNull();\r\n      expect(retrieved!.id).toBe(ticket.id);\r\n\r\n      // Verify cannot create ticket with duplicate id\r\n      // (This would fail if id wasn't PRIMARY KEY)\r\n      // Note: Our createTicket auto-generates IDs, so duplicate is unlikely\r\n      // but the PRIMARY KEY constraint is verified by successful insertion + retrieval\r\n    });\r\n\r\n    it('persists ticket when data stays in memory', async () => {\r\n      // In-memory DB: data persists for the lifetime of the connection\r\n      const db1 = new TicketDb(':memory:', true);\r\n      await db1.init();\r\n\r\n      const ticket = await db1.createTicket({\r\n        title: 'Persistent Ticket',\r\n        description: 'Should persist in session',\r\n        type: 'ai_to_human',\r\n        priority: 1,\r\n      }, { skipRouting: true });\r\n\r\n      const ticketId = ticket.id;\r\n      expect(ticketId).toBeDefined();\r\n\r\n      // Verify we can retrieve it in same session\r\n      const retrieved = await db1.getTicket(ticketId);\r\n      expect(retrieved).not.toBeNull();\r\n      expect(retrieved!.id).toBe(ticketId);\r\n      expect(retrieved!.title).toBe('Persistent Ticket');\r\n\r\n      await db1.close();\r\n    });\r\n\r\n    it('falls back to Map if schema creation fails', async () => {\r\n      // Use invalid path to force schema creation failure\r\n      const invalidDb = new TicketDb('/invalid/readonly/path/that/cannot/be/created');\r\n\r\n      // This should fail to create SQLite but succeed with fallback\r\n      await invalidDb.init();\r\n\r\n      // Verify CRUD still works with fallback Map\r\n      const ticket = await invalidDb.createTicket({\r\n        title: 'Fallback Test',\r\n        description: 'Should work with Map fallback',\r\n        type: 'ai_to_human',\r\n        priority: 2,\r\n      });\r\n\r\n      expect(ticket.id).toBeDefined();\r\n      expect(ticket.title).toBe('Fallback Test');\r\n\r\n      // Verify retrieval works\r\n      const retrieved = await invalidDb.getTicket(ticket.id);\r\n      expect(retrieved).not.toBeNull();\r\n      expect(retrieved!.id).toBe(ticket.id);\r\n      expect(retrieved!.title).toBe('Fallback Test');\r\n\r\n      // Verify update works\r\n      const updated = await invalidDb.updateTicket(ticket.id, {\r\n        status: 'in_review',\r\n      });\r\n      expect(updated.status).toBe('in_review');\r\n\r\n      // Verify delete works\r\n      const deleted = await invalidDb.deleteTicket(ticket.id);\r\n      expect(deleted).toBe(true);\r\n\r\n      const afterDelete = await invalidDb.getTicket(ticket.id);\r\n      expect(afterDelete).toBeNull();\r\n\r\n      // No need to close (fallback doesn't use SQLite)\r\n    });\r\n\r\n    it('returns existing instance if already initialized (singleton check)', async () => {\r\n      await ticketDb.init();\r\n\r\n      // Initialize again (should return immediately)\r\n      await ticketDb.init();\r\n\r\n      // Verify database still works\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Post double-init',\r\n        description: 'Should still work',\r\n      });\r\n\r\n      expect(ticket.id).toBeDefined();\r\n      const retrieved = await ticketDb.getTicket(ticket.id);\r\n      expect(retrieved).not.toBeNull();\r\n    });\r\n  });\r\n\r\n  // ============================================================================\r\n  // CRUD Tests\r\n  // ============================================================================\r\n\r\n  describe('createTicket()', () => {\r\n    beforeAll(() => {\r\n      // This suite creates many tickets; extend timeout to avoid flakiness\r\n      jest.setTimeout(20000);\r\n    });\r\n\r\n    beforeEach(async () => {\r\n      await ticketDb.init();\r\n    });\r\n\r\n    it('should create a ticket with required fields', async () => {\r\n      const ticket = await ticketDb.createTicket({\r\n        type: 'ai_to_human',\r\n        priority: 1,\r\n        title: 'Architecture question',\r\n        description: 'How to structure agents?',\r\n      });\r\n\r\n      expect(ticket.id).toMatch(/^ticket_\\d+_[a-z0-9]+$/);\r\n      expect(ticket.type).toBe('ai_to_human');\r\n      expect(ticket.priority).toBe(1);\r\n      expect(ticket.status).toBe('open');\r\n      expect(ticket.createdAt).toBeInstanceOf(Date);\r\n    });\r\n\r\n    it('should use defaults for optional fields', async () => {\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Question',\r\n        description: 'Details',\r\n      });\r\n\r\n      expect(ticket.type).toBe('ai_to_human');\r\n      expect(ticket.priority).toBe(2);\r\n      expect(ticket.status).toBe('open');\r\n      expect(ticket.assignee).toBeUndefined();\r\n    });\r\n\r\n    it('should throw error if title is missing', async () => {\r\n      await expect(\r\n        ticketDb.createTicket({\r\n          description: 'Missing title',\r\n        })\r\n      ).rejects.toThrow(TicketError);\r\n    });\r\n\r\n    it('should enforce max ticket limit', async () => {\r\n      // This test creates 100 tickets which takes longer than default timeout\r\n      jest.setTimeout(30000);\r\n\r\n      // Create max tickets with skipRouting to avoid orchestrator dependency\r\n      for (let i = 0; i < 100; i++) {\r\n        await ticketDb.createTicket({\r\n          title: `Ticket ${i}`,\r\n          description: 'Test',\r\n        }, { skipRouting: true });\r\n      }\r\n\r\n      // 101st should fail\r\n      await expect(\r\n        ticketDb.createTicket({\r\n          title: 'Over limit',\r\n          description: 'Should fail',\r\n        }, { skipRouting: true })\r\n      ).rejects.toThrow('Max tickets');\r\n    });\r\n  });\r\n\r\n  describe('getTicket()', () => {\r\n    beforeEach(async () => {\r\n      await ticketDb.init();\r\n    });\r\n\r\n    it('should retrieve a ticket by ID', async () => {\r\n      const created = await ticketDb.createTicket({\r\n        title: 'Test ticket',\r\n        description: 'Details',\r\n      });\r\n\r\n      const retrieved = await ticketDb.getTicket(created.id);\r\n\r\n      expect(retrieved).toBeDefined();\r\n      expect(retrieved!.id).toBe(created.id);\r\n      expect(retrieved!.title).toBe('Test ticket');\r\n    });\r\n\r\n    it('should return null for non-existent ticket', async () => {\r\n      const result = await ticketDb.getTicket('ticket_nonexistent');\r\n      expect(result).toBeNull();\r\n    });\r\n  });\r\n\r\n  describe('updateTicket()', () => {\r\n    beforeEach(async () => {\r\n      await ticketDb.init();\r\n    });\r\n\r\n    it('should update ticket fields', async () => {\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Original',\r\n        description: 'Original description',\r\n      });\r\n\r\n      const updated = await ticketDb.updateTicket(ticket.id, {\r\n        status: 'in_review',\r\n        priority: 1,\r\n      });\r\n\r\n      expect(updated.status).toBe('in_review');\r\n      expect(updated.priority).toBe(1);\r\n      expect(updated.title).toBe('Original');\r\n    });\r\n\r\n    it('should update the updatedAt timestamp', async () => {\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Test',\r\n        description: 'Test',\r\n      });\r\n\r\n      // Wait a bit\r\n      await new Promise(resolve => setTimeout(resolve, 10));\r\n\r\n      const updated = await ticketDb.updateTicket(ticket.id, {\r\n        status: 'resolved',\r\n      });\r\n\r\n      expect(updated.updatedAt.getTime()).toBeGreaterThan(ticket.createdAt.getTime());\r\n    });\r\n\r\n    it('should throw error if ticket not found', async () => {\r\n      await expect(\r\n        ticketDb.updateTicket('ticket_nonexistent', { status: 'resolved' })\r\n      ).rejects.toThrow();\r\n    });\r\n  });\r\n\r\n  describe('deleteTicket()', () => {\r\n    beforeEach(async () => {\r\n      await ticketDb.init();\r\n    });\r\n\r\n    it('should delete a ticket', async () => {\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'To delete',\r\n        description: 'Test',\r\n      });\r\n\r\n      const deleted = await ticketDb.deleteTicket(ticket.id);\r\n      expect(deleted).toBe(true);\r\n\r\n      const retrieved = await ticketDb.getTicket(ticket.id);\r\n      expect(retrieved).toBeNull();\r\n    });\r\n\r\n    it('should return false for non-existent ticket', async () => {\r\n      const result = await ticketDb.deleteTicket('ticket_nonexistent');\r\n      expect(result).toBe(false);\r\n    });\r\n\r\n    it('should cascade delete replies', async () => {\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'With replies',\r\n        description: 'Test',\r\n      });\r\n\r\n      await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        content: 'Reply 1',\r\n      });\r\n\r\n      await ticketDb.deleteTicket(ticket.id);\r\n\r\n      const replies = await ticketDb.getReplies(ticket.id);\r\n      expect(replies).toEqual([]);\r\n    });\r\n  });\r\n\r\n  // ============================================================================\r\n  // Reply Threading Tests\r\n  // ============================================================================\r\n\r\n  describe('addReply()', () => {\r\n    beforeEach(async () => {\r\n      await ticketDb.init();\r\n    });\r\n\r\n    it('should add a reply to a ticket', async () => {\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Question',\r\n        description: 'Need help',\r\n      });\r\n\r\n      const reply = await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        author: 'ai',\r\n        content: 'Here is my answer',\r\n      });\r\n\r\n      expect(reply.id).toMatch(/^reply_\\d+_[a-z0-9]+$/);\r\n      expect(reply.ticketId).toBe(ticket.id);\r\n      expect(reply.author).toBe('ai');\r\n      expect(reply.content).toBe('Here is my answer');\r\n      expect(reply.createdAt).toBeInstanceOf(Date);\r\n    });\r\n\r\n    it('should throw error if ticket not found', async () => {\r\n      await expect(\r\n        ticketDb.addReply({\r\n          ticketId: 'ticket_nonexistent',\r\n          content: 'Reply',\r\n        })\r\n      ).rejects.toThrow(TicketError);\r\n    });\r\n\r\n    it('should support multiple replies to one ticket', async () => {\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Question',\r\n        description: 'Test',\r\n      });\r\n\r\n      const reply1 = await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        author: 'ai',\r\n        content: 'Response 1',\r\n      });\r\n\r\n      const reply2 = await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        author: 'human',\r\n        content: 'Follow-up',\r\n      });\r\n\r\n      const replies = await ticketDb.getReplies(ticket.id);\r\n      expect(replies).toHaveLength(2);\r\n      expect(replies[0].id).toBe(reply1.id);\r\n      expect(replies[1].id).toBe(reply2.id);\r\n    });\r\n  });\r\n\r\n  describe('getReplies()', () => {\r\n    beforeEach(async () => {\r\n      await ticketDb.init();\r\n    });\r\n\r\n    it('should retrieve replies in chronological order', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Test',\r\n        description: 'Test',\r\n      });\r\n\r\n      await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        author: 'ai',\r\n        content: 'First',\r\n      });\r\n\r\n      await new Promise(resolve => setTimeout(resolve, 10));\r\n\r\n      await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        author: 'human',\r\n        content: 'Second',\r\n      });\r\n\r\n      const replies = await ticketDb.getReplies(ticket.id);\r\n      expect(replies[0].content).toBe('First');\r\n      expect(replies[1].content).toBe('Second');\r\n    });\r\n\r\n    it('should return empty array for ticket with no replies', async () => {\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'No replies',\r\n        description: 'Test',\r\n      });\r\n\r\n      const replies = await ticketDb.getReplies(ticket.id);\r\n      expect(replies).toEqual([]);\r\n    });\r\n  });\r\n\r\n  // ============================================================================\r\n  // Fallback Mode Tests\r\n  // ============================================================================\r\n\r\n  describe('Fallback Mode (SQLite Disabled)', () => {\r\n    it('should use Map fallback when SQLite fails', async () => {\r\n      // This test simulates fallback by directly enabling it\r\n      ticketDb = new TicketDb('/invalid/path/that/cannot/be/created');\r\n      await ticketDb.init(); // Will fail and switch to fallback\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'In fallback',\r\n        description: 'Test',\r\n      });\r\n\r\n      expect(ticket.id).toBeDefined();\r\n\r\n      const retrieved = await ticketDb.getTicket(ticket.id);\r\n      // In fallback mode, basic properties should match\r\n      expect(retrieved).toBeDefined();\r\n      expect(retrieved!.id).toBe(ticket.id);\r\n      expect(retrieved!.title).toBe('In fallback');\r\n      expect(retrieved!.description).toBe('Test');\r\n    });\r\n\r\n    it('should maintain CRUD in fallback mode', async () => {\r\n      ticketDb = new TicketDb('/invalid/path');\r\n      await ticketDb.init();\r\n\r\n      const ticket1 = await ticketDb.createTicket({\r\n        title: 'Ticket 1',\r\n        description: 'Test',\r\n      });\r\n\r\n      const updated = await ticketDb.updateTicket(ticket1.id, {\r\n        status: 'resolved',\r\n      });\r\n\r\n      expect(updated.status).toBe('resolved');\r\n\r\n      const deleted = await ticketDb.deleteTicket(ticket1.id);\r\n      expect(deleted).toBe(true);\r\n    });\r\n\r\n    it('should thread replies in fallback mode', async () => {\r\n      ticketDb = new TicketDb('/invalid/path');\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Fallback ticket',\r\n        description: 'Test',\r\n      });\r\n\r\n      const reply = await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        content: 'Fallback reply',\r\n      });\r\n\r\n      const replies = await ticketDb.getReplies(ticket.id);\r\n      expect(replies).toHaveLength(1);\r\n      expect(replies[0].id).toBe(reply.id);\r\n    });\r\n  });\r\n\r\n  // ============================================================================\r\n  // Persistence & Integration Tests\r\n  // ============================================================================\r\n\r\n  describe('Persistence', () => {\r\n    it('should persist tickets within session', async () => {\r\n      const ticketDb1 = new TicketDb(':memory:');\r\n      await ticketDb1.init();\r\n\r\n      const ticket = await ticketDb1.createTicket({\r\n        title: 'Persistent',\r\n        description: 'Should survive session',\r\n      }, { skipRouting: true });\r\n\r\n      // Verify ticket exists\r\n      const beforeClose = await ticketDb1.getTicket(ticket.id);\r\n      expect(beforeClose).toBeDefined();\r\n      expect(beforeClose!.title).toBe('Persistent');\r\n\r\n      // For in-memory DB, closing releases data, so we can't verify cross-session persistence\r\n      await ticketDb1.close();\r\n    });\r\n\r\n\r\n    it('should persist replies within session', async () => {\r\n      const ticketDb1 = new TicketDb(':memory:');\r\n      await ticketDb1.init();\r\n\r\n      const ticket = await ticketDb1.createTicket({\r\n        title: 'Test',\r\n        description: 'Test',\r\n      }, { skipRouting: true });\r\n\r\n      await ticketDb1.addReply({\r\n        ticketId: ticket.id,\r\n        content: 'Persistent reply',\r\n      });\r\n\r\n      // Verify reply exists before close\r\n      const beforeClose = await ticketDb1.getReplies(ticket.id);\r\n      expect(beforeClose).toHaveLength(1);\r\n      expect(beforeClose[0].content).toBe('Persistent reply');\r\n\r\n      await ticketDb1.close();\r\n    });\r\n  });\r\n\r\n  // ============================================================================\r\n  // Connection Cleanup Tests\r\n  // ============================================================================\r\n\r\n  describe('close()', () => {\r\n    it('closes database without errors', async () => {\r\n      await ticketDb.init();\r\n      await expect(ticketDb.close()).resolves.not.toThrow();\r\n    });\r\n\r\n    it('handles close when no database is open', async () => {\r\n      const freshDb = new TicketDb(':memory:');\r\n      await expect(freshDb.close()).resolves.not.toThrow();\r\n    });\r\n\r\n    it('closes without errors for in-memory database', async () => {\r\n      const db1 = new TicketDb(':memory:');\r\n      await db1.init();\r\n\r\n      const ticket = await db1.createTicket({\r\n        title: 'Test close',\r\n        description: 'Verifies close works properly',\r\n      });\r\n\r\n      // Should be able to close without errors\r\n      await expect(db1.close()).resolves.not.toThrow();\r\n    });\r\n\r\n    it('prevents operations after close', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Before close',\r\n        description: 'Test',\r\n      });\r\n\r\n      await ticketDb.close();\r\n\r\n      // Operations after close should fail or use fallback\r\n      await expect(\r\n        ticketDb.createTicket({ title: 'After close', description: 'Should fail' })\r\n      ).rejects.toThrow();\r\n    });\r\n  });\r\n\r\n  // ============================================================================\r\n  // Ticket ΓåÆ Task Queue Integration Tests (P1 Task 2)\r\n  // ============================================================================\r\n\r\n  describe('Ticket ΓåÆ Task Queue Integration', () => {\r\n    // Note: These tests verify integration with ProgrammingOrchestrator\r\n    // Tests use skipRouting option to isolate TicketDb functionality\r\n    // Full integration tests would involve live orchestrator instance\r\n\r\n    it('should route ticket with skipRouting=false (default)', async () => {\r\n      await ticketDb.init();\r\n\r\n      // Create a ticket without skipping routing\r\n      // This should trigger routing if Orchestrator is initialized\r\n      const ticket = await ticketDb.createTicket({\r\n        type: 'human_to_ai',\r\n        title: 'How do I implement error handling?',\r\n        description: 'Need guidance on TypeScript patterns',\r\n        priority: 2,\r\n      });\r\n\r\n      expect(ticket.id).toBeDefined();\r\n      expect(ticket.title).toBe('How do I implement error handling?');\r\n      // Routing happens asynchronously, so we don't fail if Orchestrator isn't available\r\n    });\r\n\r\n    it('should skip routing when options.skipRouting=true', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket(\r\n        {\r\n          type: 'human_to_ai',\r\n          title: 'Skip routing test',\r\n          description: 'This should not trigger routing',\r\n          priority: 1,\r\n        },\r\n        { skipRouting: true } // Skip routing\r\n      );\r\n\r\n      expect(ticket.id).toBeDefined();\r\n      // Should complete without errors even if Orchestrator not available\r\n    });\r\n\r\n    it('should persist ticket and retrieve it correctly', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        type: 'human_to_ai',\r\n        title: 'Architecture planning question',\r\n        description: 'Need help designing the system architecture',\r\n        priority: 1,\r\n      });\r\n\r\n      const retrieved = await ticketDb.getTicket(ticket.id);\r\n      expect(retrieved).not.toBeNull();\r\n      expect(retrieved!.title).toBe('Architecture planning question');\r\n      expect(retrieved!.priority).toBe(1);\r\n    });\r\n\r\n    it('should handle routing failures gracefully', async () => {\r\n      await ticketDb.init();\r\n\r\n      // This test verifies that if routing fails, the ticket is still created and saved\r\n      const ticket = await ticketDb.createTicket({\r\n        type: 'ai_to_human',\r\n        title: 'Test robustness',\r\n        description: 'Verify ticket is saved even if routing fails',\r\n        priority: 2,\r\n      });\r\n\r\n      // Ticket should still be retrievable even if routing failed\r\n      const retrieved = await ticketDb.getTicket(ticket.id);\r\n      expect(retrieved).not.toBeNull();\r\n      expect(retrieved!.id).toBe(ticket.id);\r\n    });\r\n\r\n    it('should handle createTicket with various priority levels', async () => {\r\n      await ticketDb.init();\r\n\r\n      // Test P1 (priority 1)\r\n      const p1Ticket = await ticketDb.createTicket(\r\n        {\r\n          type: 'human_to_ai',\r\n          title: 'Critical issue',\r\n          description: 'Must be addressed immediately',\r\n          priority: 1,\r\n        },\r\n        { skipRouting: true }\r\n      );\r\n      expect(p1Ticket.priority).toBe(1);\r\n\r\n      // Test P2 (priority 2)\r\n      const p2Ticket = await ticketDb.createTicket(\r\n        {\r\n          type: 'human_to_ai',\r\n          title: 'Important task',\r\n          description: 'Should be done soon',\r\n          priority: 2,\r\n        },\r\n        { skipRouting: true }\r\n      );\r\n      expect(p2Ticket.priority).toBe(2);\r\n\r\n      // Test P3 (priority 3)\r\n      const p3Ticket = await ticketDb.createTicket(\r\n        {\r\n          type: 'human_to_ai',\r\n          title: 'Nice to have',\r\n          description: 'Can be done later',\r\n          priority: 3,\r\n        },\r\n        { skipRouting: true }\r\n      );\r\n      expect(p3Ticket.priority).toBe(3);\r\n    });\r\n\r\n    it('should create valid tickets with all optional fields', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket(\r\n        {\r\n          type: 'human_to_ai',\r\n          title: 'Full ticket with all fields',\r\n          description: 'Testing optional fields',\r\n          priority: 2,\r\n          assignee: 'answer-team',\r\n          labels: ['urgent', 'feature'],\r\n        },\r\n        { skipRouting: true }\r\n      );\r\n\r\n      const retrieved = await ticketDb.getTicket(ticket.id);\r\n      expect(retrieved!.assignee).toBe('answer-team');\r\n      expect(retrieved!.labels).toEqual(['urgent', 'feature']);\r\n    });\r\n\r\n    it('should reject ticket creation without title', async () => {\r\n      await ticketDb.init();\r\n\r\n      await expect(\r\n        ticketDb.createTicket(\r\n          {\r\n            type: 'human_to_ai',\r\n            title: '', // Empty title\r\n            description: 'Missing title',\r\n            priority: 2,\r\n          },\r\n          { skipRouting: true }\r\n        )\r\n      ).rejects.toThrow('Ticket title is required');\r\n    });\r\n  });\r\n\r\n  // ========================================================================\r\n  // Branch Coverage: Error Handling & Edge Cases\r\n  // ========================================================================\r\n  describe('Error Handling & Edge Cases', () => {\r\n    it('should handle getTicket with non-existent ID in fallback mode', async () => {\r\n      ticketDb = new TicketDb('/invalid/path');\r\n      await ticketDb.init();\r\n\r\n      const result = await ticketDb.getTicket('non-existent-id');\r\n      expect(result).toBeNull();\r\n    });\r\n\r\n    it('should handle updateTicket with non-existent ID', async () => {\r\n      await ticketDb.init();\r\n\r\n      await expect(\r\n        ticketDb.updateTicket('non-existent-id', { status: 'resolved' })\r\n      ).rejects.toThrow('Ticket not found');\r\n    });\r\n\r\n    it('should handle updateTicket with non-existent ID in fallback mode', async () => {\r\n      ticketDb = new TicketDb('/invalid/path');\r\n      await ticketDb.init();\r\n\r\n      await expect(\r\n        ticketDb.updateTicket('non-existent-id', { status: 'resolved' })\r\n      ).rejects.toThrow('Ticket not found');\r\n    });\r\n\r\n    it('should return false when deleting non-existent ticket', async () => {\r\n      await ticketDb.init();\r\n\r\n      const result = await ticketDb.deleteTicket('non-existent-id');\r\n      expect(result).toBe(false);\r\n    });\r\n\r\n    it('should return false when deleting non-existent ticket in fallback mode', async () => {\r\n      ticketDb = new TicketDb('/invalid/path');\r\n      await ticketDb.init();\r\n\r\n      const result = await ticketDb.deleteTicket('non-existent-id');\r\n      expect(result).toBe(false);\r\n    });\r\n\r\n    it('should handle addReply with non-existent ticket', async () => {\r\n      await ticketDb.init();\r\n\r\n      await expect(\r\n        ticketDb.addReply({\r\n          ticketId: 'non-existent',\r\n          content: 'Reply'\r\n        })\r\n      ).rejects.toThrow('Ticket not found');\r\n    });\r\n\r\n    it('should handle addReply with non-existent ticket in fallback mode', async () => {\r\n      ticketDb = new TicketDb('/invalid/path');\r\n      await ticketDb.init();\r\n\r\n      await expect(\r\n        ticketDb.addReply({\r\n          ticketId: 'non-existent',\r\n          content: 'Reply'\r\n        })\r\n      ).rejects.toThrow('Ticket not found');\r\n    });\r\n\r\n    it('should return empty array for getReplies with non-existent ticket', async () => {\r\n      await ticketDb.init();\r\n\r\n      const replies = await ticketDb.getReplies('non-existent-id');\r\n      expect(replies).toEqual([]);\r\n    });\r\n\r\n    it('should return empty array for getReplies with non-existent ticket in fallback mode', async () => {\r\n      ticketDb = new TicketDb('/invalid/path');\r\n      await ticketDb.init();\r\n\r\n      const replies = await ticketDb.getReplies('non-existent-id');\r\n      expect(replies).toEqual([]);\r\n    });\r\n\r\n    it('should create ticket with all optional fields', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        type: 'ai_to_human',\r\n        status: 'in_review',\r\n        priority: 1,\r\n        title: 'Complete Ticket',\r\n        description: 'Full details',\r\n        assignee: 'testuser',\r\n        labels: ['bug', 'urgent']\r\n      }, { skipRouting: true });\r\n\r\n      expect(ticket.type).toBe('ai_to_human');\r\n      expect(ticket.status).toBe('in_review');\r\n      expect(ticket.priority).toBe(1);\r\n      expect(ticket.assignee).toBe('testuser');\r\n      expect(ticket.labels).toEqual(['bug', 'urgent']);\r\n    });\r\n\r\n    it('should update ticket with labels', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Test',\r\n        description: 'Test'\r\n      }, { skipRouting: true });\r\n\r\n      const updated = await ticketDb.updateTicket(ticket.id, {\r\n        labels: ['feature', 'high-priority']\r\n      });\r\n\r\n      expect(updated.labels).toEqual(['feature', 'high-priority']);\r\n    });\r\n\r\n    it('should create ticket with null labels', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'No Labels',\r\n        description: 'Test',\r\n        labels: undefined\r\n      }, { skipRouting: true });\r\n\r\n      expect(ticket.labels).toBeUndefined();\r\n    });\r\n\r\n    it('should handle multiple replies to same ticket', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Test',\r\n        description: 'Test'\r\n      }, { skipRouting: true });\r\n\r\n      await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        content: 'Reply 1'\r\n      });\r\n\r\n      await ticketDb.addReply({\r\n        ticketId: ticket.id,\r\n        content: 'Reply 2'\r\n      });\r\n\r\n      const replies = await ticketDb.getReplies(ticket.id);\r\n      expect(replies.length).toBe(2);\r\n    });\r\n\r\n    it('should update ticket status to resolved', async () => {\r\n      await ticketDb.init();\r\n\r\n      const ticket = await ticketDb.createTicket({\r\n        title: 'Test',\r\n        description: 'Test',\r\n        status: 'open'\r\n      }, { skipRouting: true });\r\n\r\n      const updated = await ticketDb.updateTicket(ticket.id, {\r\n        status: 'resolved'\r\n      });\r\n\r\n      expect(updated.status).toBe('resolved');\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\bossRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\contextBundler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\hello-world.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\llmConfigManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\plansReader.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errMsg' is assigned a value but never used.","line":123,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Plans Reader Service\r\n * \r\n * Reads all markdown files from the Plans/ folder recursively.\r\n * Filters out backup files, ipynb files, and temporary files.\r\n * \r\n * @module plansReader\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs/promises';\r\n\r\n/**\r\n * ≡ƒôä Plan File Information\r\n */\r\nexport interface PlanFile {\r\n    path: string;                    // Full file path\r\n    relativeDir: string;             // Relative directory (e.g., \"Plans\", \"Plans/COE-Master-Plan\")\r\n    name: string;                    // File name (e.g., \"CONSOLIDATED-MASTER-PLAN.md\")\r\n    size: number;                    // File size in bytes\r\n    content: string;                 // File content\r\n    category?: string;               // Category (architecture, agent-spec, workflow, etc.)\r\n    priority?: number;               // Reading priority (lower = read first)\r\n}\r\n\r\n/**\r\n * ≡ƒöì Plans Reader Service\r\n * Reads and categorizes plan files from the Plans/ folder\r\n */\r\nexport class PlansReader {\r\n    /**\r\n     * Priority mapping for important files\r\n     * Lower number = higher priority (read first)\r\n     */\r\n    private static readonly FILE_PRIORITY: Record<string, number> = {\r\n        'CONSOLIDATED-MASTER-PLAN.md': 1,\r\n        'README.md': 2,\r\n        '02-Agent-Role-Definitions.md': 3,\r\n        '05-MCP-API-Reference.md': 4,\r\n        'MODULAR-EXECUTION-PHILOSOPHY.md': 5,\r\n        'PLANNING-WIZARD-SPECIFICATION.md': 6,\r\n        'ANSWER-AI-TEAM-SPECIFICATION.md': 7,\r\n    };\r\n\r\n    /**\r\n     * ≡ƒôé Read all plan files from the Plans/ folder\r\n     * \r\n     * @returns Array of plan files sorted by priority\r\n     * @throws Error if Plans folder not found or read fails\r\n     */\r\n    static async readAllPlans(): Promise<PlanFile[]> {\r\n        const workspaceFolders = vscode.workspace.workspaceFolders;\r\n        if (!workspaceFolders || workspaceFolders.length === 0) {\r\n            throw new Error('No workspace folder found');\r\n        }\r\n\r\n        const workspaceRoot = workspaceFolders[0].uri.fsPath;\r\n        const plansDir = path.join(workspaceRoot, 'Plans');\r\n\r\n        try {\r\n            // Check if Plans directory exists\r\n            await fs.access(plansDir);\r\n        } catch {\r\n            throw new Error(`Plans directory not found at ${plansDir}`);\r\n        }\r\n\r\n        const planFiles: PlanFile[] = [];\r\n\r\n        // Recursively read all .md files\r\n        const readDir = async (dir: string, baseDir: string = 'Plans'): Promise<void> => {\r\n            const entries = await fs.readdir(dir, { withFileTypes: true });\r\n\r\n            for (const entry of entries) {\r\n                const fullPath = path.join(dir, entry.name);\r\n                const relativeDir = path.relative(plansDir, fullPath);\r\n\r\n                // Skip backup, temp, and ipynb files\r\n                if (\r\n                    entry.name.startsWith('old-') ||\r\n                    entry.name.startsWith('temp-') ||\r\n                    entry.name.startsWith('.') ||\r\n                    entry.name.endsWith('.ipynb') ||\r\n                    entry.name.endsWith('.backup')\r\n                ) {\r\n                    continue;\r\n                }\r\n\r\n                if (entry.isDirectory()) {\r\n                    // Recursively read subdirectories\r\n                    await readDir(fullPath, path.join(baseDir, entry.name));\r\n                } else if (entry.name.endsWith('.md')) {\r\n                    // Read markdown file\r\n                    try {\r\n                        const content = await fs.readFile(fullPath, 'utf-8');\r\n                        const stats = await fs.stat(fullPath);\r\n\r\n                        // Determine category based on file name or directory\r\n                        let category = 'general';\r\n                        if (entry.name.includes('Agent') || entry.name.includes('Team')) {\r\n                            category = 'agent-spec';\r\n                        } else if (entry.name.includes('MCP')) {\r\n                            category = 'api-reference';\r\n                        } else if (entry.name.includes('Workflow') || entry.name.includes('Process')) {\r\n                            category = 'workflow';\r\n                        } else if (entry.name.includes('Architecture')) {\r\n                            category = 'architecture';\r\n                        }\r\n\r\n                        // Get priority from mapping, or use default\r\n                        const priority = this.FILE_PRIORITY[entry.name] || 999;\r\n\r\n                        planFiles.push({\r\n                            path: fullPath,\r\n                            relativeDir: path.dirname(relativeDir) || 'Plans',\r\n                            name: entry.name,\r\n                            size: stats.size,\r\n                            content,\r\n                            category,\r\n                            priority,\r\n                        });\r\n                    } catch (error) {\r\n                        const errMsg = error instanceof Error ? error.message : String(error);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        await readDir(plansDir);\r\n\r\n        // Sort by priority (ascending)\r\n        planFiles.sort((a, b) => (a.priority || 999) - (b.priority || 999));\r\n\r\n        return planFiles;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôè Estimate token count for content\r\n     * Rough estimation: ~1 token per 4 characters for English text\r\n     * \r\n     * @param content - Text content\r\n     * @returns Estimated token count\r\n     */\r\n    static estimateTokens(content: string): number {\r\n        // Rough estimation: 1 token Γëê 4 characters in English\r\n        return Math.ceil(content.length / 4);\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôï Get category label for display\r\n     * \r\n     * @param category - Category string\r\n     * @returns Human-readable category name\r\n     */\r\n    static getCategoryLabel(category?: string): string {\r\n        const labels: Record<string, string> = {\r\n            'agent-spec': 'Agent Specification',\r\n            'api-reference': 'API Reference',\r\n            'workflow': 'Workflow',\r\n            'architecture': 'Architecture',\r\n            'general': 'General',\r\n        };\r\n        return labels[category || 'general'] || 'Unknown';\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\plansWatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\prdGenerator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PRDMetadata' is defined but never used.","line":17,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PRD Generator Service\r\n * \r\n * Orchestrates the entire PRD generation workflow:\r\n * 1. Read Plans/ folder\r\n * 2. Bundle content with token limits\r\n * 3. Call LLM for synthesis\r\n * 4. Write to PRD.md/PRD.json\r\n * 5. Handle errors and retries\r\n * \r\n * @module prdGenerator\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport { PlansReader } from './plansReader';\r\nimport { ContextBundler } from './contextBundler';\r\nimport { PRDWriter, PRDMetadata } from './prdWriter';\r\nimport { PRDGenerationPrompt } from '../prompts/prdGenerationPrompt';\r\nimport { FileConfigManager, LLMConfig } from '../utils/fileConfig';\r\nimport { callLLMWithStreaming } from '../utils/streamingLLM';\r\n\r\n/**\r\n * ≡ƒöä PRD Generation Options\r\n */\r\nexport interface PRDGenerationOptions {\r\n    tokenLimit?: number;          // Max input tokens (default 4000)\r\n    retryOnFailure?: boolean;     // Retry if validation fails (default true)\r\n    showPreview?: boolean;        // Show diff preview before writing (default true)\r\n    llmConfig?: {\r\n        url: string;\r\n        model: string;\r\n        maxOutputTokens: number;\r\n        timeoutSeconds: number;\r\n        temperature?: number;\r\n    };\r\n}\r\n\r\n/**\r\n * ≡ƒôè Generation Result\r\n */\r\nexport interface GenerationResult {\r\n    success: boolean;\r\n    prdContent?: string;\r\n    mdPath?: string;\r\n    jsonPath?: string;\r\n    mdUri?: vscode.Uri;\r\n    jsonUri?: vscode.Uri;\r\n    backupPath?: string;\r\n    message: string;\r\n    warning?: string;\r\n    tokenCount?: number;\r\n    duration?: number;  // milliseconds\r\n}\r\n\r\n/**\r\n * ≡ƒñû PRD Generator Service\r\n * Main orchestrator for PRD generation\r\n */\r\nexport class PRDGenerator {\r\n    /**\r\n     * ≡ƒÜÇ Generate PRD from Plans folder\r\n     * \r\n     * Full workflow:\r\n     * 1. Read all .md files from Plans/\r\n     * 2. Bundle with token limits\r\n     * 3. Create prompts\r\n     * 4. Call LLM with streaming\r\n     * 5. Validate output\r\n     * 6. Write to PRD.md/PRD.json\r\n     * \r\n     * @param options - Generation options\r\n     * @param onStatus - Callback for status updates\r\n     * @param outputChannel - Output channel for streaming tokens\r\n     * @returns Generation result\r\n     */\r\n    static async generate(\r\n        options: PRDGenerationOptions = {},\r\n        onStatus?: (status: string) => void,\r\n        outputChannel?: vscode.OutputChannel\r\n    ): Promise<GenerationResult> {\r\n        const startTime = Date.now();\r\n        const tokenLimit = options.tokenLimit || 4000;\r\n\r\n        try {\r\n            // Step 1: Read plans\r\n            onStatus?.('≡ƒôé Reading Plans/ folder...');\r\n            const planFiles = await PlansReader.readAllPlans();\r\n            if (planFiles.length === 0) {\r\n                return {\r\n                    success: false,\r\n                    message: 'Γ¥î No plan files found in Plans/ folder',\r\n                };\r\n            }\r\n            onStatus?.(`Γ£à Found ${planFiles.length} plan files`);\r\n\r\n            // Step 2: Bundle content\r\n            onStatus?.('≡ƒôª Bundling content with token limit...');\r\n            const bundleResult = ContextBundler.bundle(planFiles, tokenLimit);\r\n            onStatus?.(ContextBundler.formatBundleInfo(bundleResult));\r\n\r\n            if (bundleResult.warning) {\r\n                onStatus?.(`ΓÜá∩╕Å  ${bundleResult.warning}`);\r\n            }\r\n\r\n            // Step 3: Create prompts\r\n            onStatus?.('Γ£Å∩╕Å  Creating prompts...');\r\n            const systemPrompt = PRDGenerationPrompt.getSystemPrompt();\r\n            const userPrompt = PRDGenerationPrompt.getUserPrompt(bundleResult.prompt);\r\n\r\n            // Step 4: Call LLM (with streaming)\r\n            onStatus?.('≡ƒñû Calling LLM for PRD synthesis (streaming)...');\r\n            const llmResponse = await this.callLLM(\r\n                systemPrompt,\r\n                userPrompt,\r\n                options.llmConfig,\r\n                outputChannel\r\n            );\r\n\r\n            if (!llmResponse.success) {\r\n                return {\r\n                    success: false,\r\n                    message: `Γ¥î LLM call failed: ${llmResponse.error}`,\r\n                };\r\n            }\r\n\r\n            let prdContent = llmResponse.content!;\r\n\r\n            // Step 5: Validate output\r\n            onStatus?.('Γ£à Validating PRD structure...');\r\n            const validation = PRDGenerationPrompt.validatePRDOutput(prdContent);\r\n\r\n            if (!validation.isValid && options.retryOnFailure) {\r\n                onStatus?.('≡ƒöä Validation failed - retrying with corrected prompt...');\r\n                const retryPrompt = PRDGenerationPrompt.getRetryPrompt(\r\n                    prdContent,\r\n                    validation.missingSection?.join(', ') || 'Unknown validation error'\r\n                );\r\n\r\n                const retryResponse = await this.callLLM(\r\n                    systemPrompt,\r\n                    retryPrompt,\r\n                    options.llmConfig,\r\n                    outputChannel\r\n                );\r\n\r\n                if (retryResponse.success) {\r\n                    prdContent = retryResponse.content!;\r\n                    onStatus?.('Γ£à Retry successful');\r\n                } else {\r\n                    onStatus?.('ΓÜá∩╕Å  Retry failed, using original content');\r\n                }\r\n            }\r\n\r\n            if (!validation.isValid) {\r\n                onStatus?.(\r\n                    `ΓÜá∩╕Å  ΓÜá∩╕Å  Validation failed: Missing sections: ${validation.missingSection?.join(', ')}`\r\n                );\r\n            }\r\n\r\n            // Step 6: Write to files\r\n            onStatus?.('≡ƒÆ╛ Writing PRD.md and PRD.json...');\r\n            const metadata = PRDWriter.createMetadata(\r\n                bundleResult.includedFiles,\r\n                bundleResult.totalTokens\r\n            );\r\n\r\n            const writeResult = await PRDWriter.writePRD(prdContent, metadata);\r\n            onStatus?.(`Γ£à Wrote PRD.md to: ${writeResult.mdPath}`);\r\n            onStatus?.(`Γ£à Wrote PRD.json to: ${writeResult.jsonPath}`);\r\n\r\n            const duration = Date.now() - startTime;\r\n\r\n            return {\r\n                success: true,\r\n                prdContent,\r\n                mdPath: writeResult.mdPath,\r\n                jsonPath: writeResult.jsonPath,\r\n                mdUri: writeResult.mdUri,\r\n                jsonUri: writeResult.jsonUri,\r\n                backupPath: writeResult.backupPath,\r\n                message: writeResult.message,\r\n                warning: bundleResult.warning || (validation.warnings?.join('; ')),\r\n                tokenCount: bundleResult.totalTokens,\r\n                duration,\r\n            };\r\n        } catch (error) {\r\n            const errMsg = error instanceof Error ? error.message : String(error);\r\n            return {\r\n                success: false,\r\n                message: `Γ¥î PRD generation failed: ${errMsg}`,\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒîè Call LLM with streaming and inactivity timeout\r\n     * \r\n     * Uses streaming fetch with inactivity-based timeout (not hard timeout).\r\n     * Falls back to non-streaming if stream fails.\r\n     * Appends tokens to output channel in real-time.\r\n     * \r\n     * @param systemPrompt - System prompt\r\n     * @param userPrompt - User prompt\r\n     * @param llmConfig - LLM configuration\r\n     * @param outputChannel - Output channel for token streaming (optional)\r\n     * @returns Response with generated content\r\n     */\r\n    private static async callLLM(\r\n        systemPrompt: string,\r\n        userPrompt: string,\r\n        llmConfig?: PRDGenerationOptions['llmConfig'],\r\n        outputChannel?: vscode.OutputChannel\r\n    ): Promise<{\r\n        success: boolean;\r\n        content?: string;\r\n        error?: string;\r\n    }> {\r\n        // Use passed config or get from global config\r\n        const fullConfig = llmConfig || this.getDefaultLLMConfig();\r\n        if (!fullConfig) {\r\n            throw new Error('LLM configuration is required');\r\n        }\r\n\r\n        // Convert to LLMConfig type expected by streaming utility\r\n        const streamingConfig: LLMConfig = {\r\n            url: fullConfig.url,\r\n            model: fullConfig.model,\r\n            inputTokenLimit: 4000,\r\n            maxOutputTokens: fullConfig.maxOutputTokens || 4000,\r\n            timeoutSeconds: fullConfig.timeoutSeconds || 300,\r\n            temperature: fullConfig.temperature || 0.3,\r\n        };\r\n\r\n        // Track collected tokens for PRD generation\r\n        const collectedTokens: string[] = [];\r\n\r\n        try {\r\n            outputChannel?.appendLine(\r\n                `≡ƒîè Starting streaming PRD generation (inactivity timeout: ${streamingConfig.timeoutSeconds}s)...`\r\n            );\r\n\r\n            const result = await callLLMWithStreaming({\r\n                config: streamingConfig,\r\n                systemPrompt,\r\n                userPrompt,\r\n                temperature: 0.3,  // Deterministic for PRD generation\r\n                maxTokens: streamingConfig.maxOutputTokens,\r\n                onToken: (token) => {\r\n                    collectedTokens.push(token);\r\n                    // Note: vscode.OutputChannel doesn't support append(), only appendLine()\r\n                    // Token streaming happens in-memory and is output after completion\r\n                },\r\n                onError: (error) => {\r\n                    outputChannel?.appendLine(`ΓÜá∩╕Å  Streaming error: ${error}`);\r\n                },\r\n                onComplete: () => {\r\n                    outputChannel?.appendLine('Γ£à Streaming complete');\r\n                },\r\n            });\r\n\r\n            if (!result.success) {\r\n                outputChannel?.appendLine(`Γ¥î LLM call failed: ${result.error}`);\r\n                return {\r\n                    success: false,\r\n                    error: result.error || 'Unknown streaming error',\r\n                };\r\n            }\r\n\r\n            const content = result.content || (collectedTokens.length > 0 ? collectedTokens.join('') : '');\r\n\r\n            if (!content) {\r\n                outputChannel?.appendLine('Γ¥î LLM returned empty response');\r\n                return {\r\n                    success: false,\r\n                    error: 'LLM returned empty response',\r\n                };\r\n            }\r\n\r\n            outputChannel?.appendLine(`Γ£à Received ${collectedTokens.length} tokens from LLM (method: ${result.method})`);\r\n\r\n            return {\r\n                success: true,\r\n                content,\r\n            };\r\n        } catch (error) {\r\n            const errMsg = error instanceof Error ? error.message : String(error);\r\n            outputChannel?.appendLine(`Γ¥î Fatal error in LLM call: ${errMsg}`);\r\n            return {\r\n                success: false,\r\n                error: errMsg,\r\n            };\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * ΓÜÖ∩╕Å  Get default LLM configuration\r\n     * Reads from FileConfigManager (.coe/config.json) with fallback to hardcoded defaults\r\n     * \r\n     * @returns Default LLM config with timeout from config\r\n     */\r\n    private static getDefaultLLMConfig(): Required<PRDGenerationOptions['llmConfig']> {\r\n        try {\r\n            const fileConfig = FileConfigManager.getLLMConfig();\r\n            const timeoutSeconds = fileConfig.timeoutSeconds || 300;\r\n\r\n            return {\r\n                url: fileConfig.url,\r\n                model: fileConfig.model,\r\n                maxOutputTokens: fileConfig.maxOutputTokens || 4000,\r\n                timeoutSeconds,\r\n                temperature: fileConfig.temperature || 0.3,\r\n            };\r\n        } catch (error) {\r\n            // Fallback to hardcoded defaults if config unavailable\r\n            const fallbackTimeout = 300;\r\n            return {\r\n                url: 'http://192.168.1.205:1234/v1/chat/completions',\r\n                model: 'mistralai/ministral-3-14b-reasoning',\r\n                maxOutputTokens: 4000,\r\n                timeoutSeconds: fallbackTimeout,\r\n                temperature: 0.3,\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\prdWriter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errMsg' is assigned a value but never used.","line":177,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":177,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PRD Writer Service\r\n * \r\n * Writes generated PRD content to PRD.md and PRD.json files.\r\n * Creates backups and handles formatting.\r\n * \r\n * @module prdWriter\r\n */\r\n\r\nimport * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport * as vscode from 'vscode';\r\n\r\n/**\r\n * ≡ƒô¥ PRD Metadata\r\n */\r\nexport interface PRDMetadata {\r\n    generatedAt: string;         // ISO 8601 timestamp\r\n    version: string;             // Version number\r\n    generatedFrom: string[];     // Source files\r\n    tokenCount: number;          // Total tokens used\r\n}\r\n\r\n/**\r\n * ≡ƒôï PRD JSON Structure (machine-readable)\r\n */\r\nexport interface PRDJSON {\r\n    metadata: PRDMetadata;\r\n    content: string;             // Full PRD markdown content\r\n    sections: {\r\n        [key: string]: string;   // Section name -> content\r\n    };\r\n}\r\n\r\n/**\r\n * Γ£ì∩╕Å  PRD Writer Service\r\n * Writes PRD files with backup and validation\r\n */\r\nexport class PRDWriter {\r\n    /**\r\n     * ≡ƒÆ╛ Write PRD to workspace\r\n     * \r\n     * Creates:\r\n     * - PRD.md (markdown for humans)\r\n     * - PRD.json (JSON for machines/agents)\r\n     * - PRD.backup-[timestamp].md (backup of previous)\r\n     * \r\n     * @param prdContent - Generated PRD markdown content\r\n     * @param metadata - PRD metadata\r\n     * @returns Object with paths, URIs, and success status\r\n     * @throws Error if write fails\r\n     */\r\n    static async writePRD(prdContent: string, metadata: PRDMetadata): Promise<{\r\n        mdPath: string;\r\n        jsonPath: string;\r\n        mdUri: vscode.Uri;\r\n        jsonUri: vscode.Uri;\r\n        backupPath?: string;\r\n        success: boolean;\r\n        message: string;\r\n    }> {\r\n        const workspaceFolders = vscode.workspace.workspaceFolders;\r\n        if (!workspaceFolders || workspaceFolders.length === 0) {\r\n            throw new Error('No workspace folder found');\r\n        }\r\n\r\n        // Use workspace root URI for proper path construction\r\n        const workspaceRootUri = workspaceFolders[0].uri;\r\n        const mdUri = vscode.Uri.joinPath(workspaceRootUri, 'PRD.md');\r\n        const jsonUri = vscode.Uri.joinPath(workspaceRootUri, 'PRD.json');\r\n        const mdPath = mdUri.fsPath;\r\n        const jsonPath = jsonUri.fsPath;\r\n\r\n\r\n        try {\r\n            // Create backup of existing PRD.md\r\n            let backupPath: string | undefined;\r\n            try {\r\n                await fs.access(mdPath);\r\n                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n                backupPath = path.join(workspaceRootUri.fsPath, `PRD.backup-${timestamp}.md`);\r\n                const existingContent = await fs.readFile(mdPath, 'utf-8');\r\n                await fs.writeFile(backupPath, existingContent, 'utf-8');\r\n            } catch {\r\n                // No existing PRD or backup failed - that's OK\r\n            }\r\n\r\n            // Write markdown file with frontmatter\r\n            const frontmatter = `<!-- Generated from Plans/ on ${metadata.generatedAt} -->\r\n<!-- Generated by COE PRD Generator -->\r\n<!-- Version: ${metadata.version} -->\r\n<!-- Tokens used: ${metadata.tokenCount} -->\r\n\r\n`;\r\n            const mdContent = frontmatter + prdContent;\r\n            await fs.writeFile(mdPath, mdContent, 'utf-8');\r\n\r\n            // Write JSON file (machine-readable, can be parsed by agents)\r\n            const prdjson: PRDJSON = {\r\n                metadata,\r\n                content: prdContent,\r\n                sections: this.extractSections(prdContent),\r\n            };\r\n            await fs.writeFile(jsonPath, JSON.stringify(prdjson, null, 2), 'utf-8');\r\n\r\n            // Refresh VS Code explorer so files appear immediately\r\n            try {\r\n                await vscode.commands.executeCommand('workbench.files.action.refreshFilesExplorer');\r\n            } catch (error) {\r\n                // Non-critical, continue\r\n            }\r\n\r\n            return {\r\n                mdPath,\r\n                jsonPath,\r\n                mdUri,\r\n                jsonUri,\r\n                backupPath,\r\n                success: true,\r\n                message: `Γ£à PRD regenerated successfully (${metadata.tokenCount} tokens)`,\r\n            };\r\n        } catch (error) {\r\n            const errMsg = error instanceof Error ? error.message : String(error);\r\n            throw new Error(`Failed to write PRD: ${errMsg}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôé Extract sections from PRD markdown\r\n     * Splits PRD by top-level headers (##)\r\n     * \r\n     * @param prdContent - PR markdown content\r\n     * @returns Object with sections\r\n     */\r\n    private static extractSections(prdContent: string): Record<string, string> {\r\n        const sections: Record<string, string> = {};\r\n        const lines = prdContent.split('\\n');\r\n        let currentSection = 'Overview';\r\n        let currentContent: string[] = [];\r\n\r\n        for (const line of lines) {\r\n            if (line.startsWith('## ')) {\r\n                // Save previous section\r\n                if (currentContent.length > 0) {\r\n                    sections[currentSection] = currentContent.join('\\n').trim();\r\n                }\r\n                // Start new section\r\n                currentSection = line.substring(3).trim();\r\n                currentContent = [];\r\n            } else {\r\n                currentContent.push(line);\r\n            }\r\n        }\r\n\r\n        // Save last section\r\n        if (currentContent.length > 0) {\r\n            sections[currentSection] = currentContent.join('\\n').trim();\r\n        }\r\n\r\n        return sections;\r\n    }\r\n\r\n    /**\r\n     * ≡ƒöì Show diff preview before overwriting\r\n     * \r\n     * Opens a diff view comparing old and new PRD\r\n     * \r\n     * @param oldPath - Path to existing PRD\r\n     * @param newPath - Path to temp new PRD\r\n     */\r\n    static async showDiffPreview(oldPath: string, newPath: string): Promise<void> {\r\n        try {\r\n            const oldUri = vscode.Uri.file(oldPath);\r\n            const newUri = vscode.Uri.file(newPath);\r\n            await vscode.commands.executeCommand('vscode.diff', oldUri, newUri, 'PRD Changes Preview');\r\n        } catch (error) {\r\n            const errMsg = error instanceof Error ? error.message : String(error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôè Create metadata for PRD\r\n     * \r\n     * @param files - Source files that were included\r\n     * @param tokens - Total tokens used\r\n     * @returns Metadata object\r\n     */\r\n    static createMetadata(files: string[], tokens: number): PRDMetadata {\r\n        return {\r\n            generatedAt: new Date().toISOString(),\r\n            version: '1.0.0',\r\n            generatedFrom: files,\r\n            tokenCount: tokens,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * ≡ƒôï Format PRD for preview in notification\r\n     * \r\n     * @param prdContent - Full PRD content\r\n     * @returns Shortened preview (first 500 chars)\r\n     */\r\n    static getContentPreview(prdContent: string, maxChars: number = 300): string {\r\n        if (prdContent.length <= maxChars) {\r\n            return prdContent;\r\n        }\r\n        return prdContent.substring(0, maxChars) + '\\n... [truncated for display]';\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\services\\ticketDb.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":472,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":472,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18352,18355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18352,18355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":820,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":820,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31473,31476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31473,31476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":834,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":834,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31903,31906],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31903,31906],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":834,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":834,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31924,31927],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31924,31927],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":848,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":848,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32334,32337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32334,32337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":848,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":848,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32355,32358],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32355,32358],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":862,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":862,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32756,32759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32756,32759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":877,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":877,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33244,33247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33244,33247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import sqlite3 from 'sqlite3';\r\nimport path from 'path';\r\nimport * as fs from 'fs';\r\nimport { randomUUID } from 'crypto';\r\nimport { logger } from '../utils/logger';\r\nimport { BossRouter } from './bossRouter';\r\nimport { TaskPriority, TaskStatus } from '../orchestrator/programmingOrchestrator';\r\n\r\n// ============================================================================\r\n// ≡ƒÄ½ Types & Interfaces\r\n// ============================================================================\r\n\r\n/**\r\n * Ticket represents an agent-human communication request\r\n */\r\nexport interface Ticket {\r\n    id: string;\r\n    type: 'ai_to_human' | 'human_to_ai';\r\n    status: 'open' | 'in_review' | 'resolved' | 'rejected' | 'escalated';\r\n    priority: 1 | 2 | 3;\r\n    title: string;\r\n    description: string;\r\n    createdAt: Date;\r\n    updatedAt: Date;\r\n    assignee?: string;\r\n    labels?: string[];\r\n}\r\n\r\n/**\r\n * Reply represents a response thread on a ticket\r\n */\r\nexport interface Reply {\r\n    id: string;\r\n    ticketId: string;\r\n    author: 'ai' | 'human';\r\n    content: string;\r\n    createdAt: Date;\r\n}\r\n\r\n/**\r\n * TicketError is thrown when ticket operations fail\r\n */\r\nexport class TicketError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'TicketError';\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// ≡ƒùä∩╕Å TicketDb Service Class\r\n// ============================================================================\r\n\r\n/**\r\n * ≡ƒÄ½ TicketDb - Persistent ticket storage service\r\n *\r\n * Manages tickets and replies using SQLite with in-memory fallback.\r\n * If SQLite initialization fails, transparently falls back to Map-based storage.\r\n *\r\n * @class TicketDb\r\n * @example\r\n * const ticketDb = new TicketDb('.coe');\r\n * await ticketDb.init();\r\n * const ticket = await ticketDb.createTicket({\r\n *   type: 'ai_to_human',\r\n *   priority: 1,\r\n *   title: 'Architecture question',\r\n *   description: 'How should we structure agents?'\r\n * });\r\n */\r\n/**\r\n * Retry configuration for handling OneDrive file locks\r\n */\r\ninterface RetryConfig {\r\n    maxAttempts: number;\r\n    delayMs: number;\r\n}\r\n\r\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\r\n    maxAttempts: 3,\r\n    delayMs: 500\r\n};\r\n\r\nexport class TicketDb {\r\n    private db: sqlite3.Database | null = null;\r\n    private fallbackTickets: Map<string, Ticket> = new Map();\r\n    private fallbackReplies: Map<string, Reply[]> = new Map();\r\n    private useFallback = false;\r\n    private isInitialized = false;\r\n    private dbPath: string;\r\n    private readonly maxTickets = 100;\r\n    private readonly schemaVersion = 1;\r\n    private retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG;\r\n    private readonly isMemoryDb: boolean;\r\n\r\n    // DEV_RESET_DB: Drop and recreate tables on init (set false in production)\r\n    // TODO: Remove after dev, use config instead\r\n    private readonly DEV_RESET_DB: boolean;\r\n\r\n    constructor(dbDir: string = '.coe', resetOnInit: boolean = true) {\r\n        // Support in-memory database for testing: pass ':memory:' as dbDir\r\n        this.isMemoryDb = dbDir === ':memory:';\r\n        this.dbPath = this.isMemoryDb ? ':memory:' : path.join(dbDir, 'tickets.db');\r\n        this.DEV_RESET_DB = resetOnInit;\r\n    }\r\n\r\n    /**\r\n     * Initialize the ticket database with schema\r\n     *\r\n     * Creates tables if they don't exist. On failure, switches to in-memory fallback.\r\n     * Checks schema version for future migration compatibility.\r\n     * In dev mode (DEV_RESET_DB=true), drops and recreates tables for clean state.\r\n     *\r\n     * @async\r\n     * @returns {Promise<void>}\r\n     * @throws {TicketError} If permanent initialization failure (rare, fallback used)\r\n     *\r\n     * @example\r\n     * await ticketDb.init();\r\n     */\r\n    async init(): Promise<void> {\r\n        // Singleton check: return if already initialized\r\n        if (this.isInitialized && this.db) {\r\n            logger.info('[TicketDb] Already initialized, skipping');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Only create directory for file-based databases\r\n            if (!this.isMemoryDb) {\r\n                const dbDir = path.dirname(this.dbPath);\r\n                if (!fs.existsSync(dbDir)) {\r\n                    fs.mkdirSync(dbDir, { recursive: true });\r\n                    logger.info(`[TicketDb] Created directory: ${dbDir}`);\r\n                }\r\n                logger.info(`[TicketDb] Opening database: ${this.dbPath}`);\r\n            } else {\r\n                logger.info('[TicketDb] Using in-memory SQLite database');\r\n            }\r\n\r\n            // Initialize SQLite connection\r\n            this.db = await new Promise<sqlite3.Database>((resolve, reject) => {\r\n                const db = new sqlite3.Database(this.dbPath, (err) => {\r\n                    if (err) {\r\n                        logger.error(`[TicketDb] SQLite connection failed: ${err.message}`, { err });\r\n                        reject(err);\r\n                    } else {\r\n                        logger.info('[TicketDb] Database connection established');\r\n                        resolve(db);\r\n                    }\r\n                });\r\n            });\r\n\r\n            if (!this.db) {\r\n                throw new Error('Database connection failed');\r\n            }\r\n\r\n            // Create schema using serialize() for deterministic ordering\r\n            await this.createSchema();\r\n\r\n            logger.info('[TicketDb] Schema ready');\r\n            logger.info('≡ƒÄ½ TicketDb initialized with SQLite backend');\r\n\r\n            this.isInitialized = true;\r\n            this.useFallback = false;\r\n\r\n        } catch (error) {\r\n            logger.error(`[TicketDb] Initialization error, falling back to Map: ${error}`, { error });\r\n            logger.error(`[TicketDb] Stack trace: ${error instanceof Error ? error.stack : 'N/A'}`);\r\n            this.useFallback = true;\r\n            this.db = null;\r\n            this.isInitialized = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÅù∩╕Å Create or recreate database schema\r\n     * \r\n     * In dev mode (DEV_RESET_DB=true): Drops existing tables first\r\n     * Creates tickets, replies, and meta tables with proper PRIMARY KEY constraints\r\n     * Uses db.serialize() to ensure operations execute in order\r\n     * \r\n     * @private\r\n     * @returns {Promise<void>}\r\n     * @throws {Error} If schema creation fails\r\n     */\r\n    private async createSchema(): Promise<void> {\r\n        if (!this.db) {\r\n            throw new Error('Database not open');\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.db!.serialize(() => {\r\n                logger.info('[TicketDb] Creating tables...');\r\n\r\n                // DEV MODE: Drop tables if flag is set (fresh start for schema changes)\r\n                if (this.DEV_RESET_DB) {\r\n                    logger.warn('[TicketDb] DEV_RESET_DB=true, dropping existing tables');\r\n\r\n                    this.db!.run('DROP TABLE IF EXISTS replies', (err) => {\r\n                        if (err) {\r\n                            logger.error('[TicketDb] Error dropping replies table:', err);\r\n                        } else {\r\n                            logger.info('[TicketDb] Dropped replies table');\r\n                        }\r\n                    });\r\n\r\n                    this.db!.run('DROP TABLE IF EXISTS tickets', (err) => {\r\n                        if (err) {\r\n                            logger.error('[TicketDb] Error dropping tickets table:', err);\r\n                        } else {\r\n                            logger.info('[TicketDb] Dropped tickets table');\r\n                        }\r\n                    });\r\n\r\n                    this.db!.run('DROP TABLE IF EXISTS meta', (err) => {\r\n                        if (err) {\r\n                            logger.error('[TicketDb] Error dropping meta table:', err);\r\n                        } else {\r\n                            logger.info('[TicketDb] Dropped meta table');\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // Enable foreign keys\r\n                this.db!.run('PRAGMA foreign_keys = ON', (err) => {\r\n                    if (err) {\r\n                        logger.error('[TicketDb] Error enabling foreign keys:', err);\r\n                    } else {\r\n                        logger.info('[TicketDb] Foreign keys enabled');\r\n                    }\r\n                });\r\n\r\n                // Create tickets table\r\n                const createTicketsTable = `\r\n                    CREATE TABLE IF NOT EXISTS tickets (\r\n                        id TEXT PRIMARY KEY,\r\n                        type TEXT NOT NULL CHECK(type IN ('ai_to_human', 'human_to_ai')),\r\n                        status TEXT NOT NULL CHECK(status IN ('open', 'in_review', 'resolved', 'rejected', 'escalated')),\r\n                        priority INTEGER NOT NULL CHECK(priority IN (1, 2, 3)),\r\n                        title TEXT NOT NULL,\r\n                        description TEXT NOT NULL,\r\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                        assignee TEXT,\r\n                        labels TEXT\r\n                    )\r\n                `;\r\n\r\n                this.db!.run(createTicketsTable, (err) => {\r\n                    if (err) {\r\n                        logger.error('[TicketDb] Error creating tickets table:', err);\r\n                        logger.error('[TicketDb] SQL:', createTicketsTable);\r\n                        reject(err);\r\n                        return;\r\n                    }\r\n                    logger.info('[TicketDb] Γ£à tickets table ready');\r\n                });\r\n\r\n                // Create replies table\r\n                const createRepliesTable = `\r\n                    CREATE TABLE IF NOT EXISTS replies (\r\n                        id TEXT PRIMARY KEY,\r\n                        ticket_id TEXT NOT NULL,\r\n                        author TEXT NOT NULL CHECK(author IN ('ai', 'human')),\r\n                        content TEXT NOT NULL,\r\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                        FOREIGN KEY (ticket_id) REFERENCES tickets(id) ON DELETE CASCADE\r\n                    )\r\n                `;\r\n\r\n                this.db!.run(createRepliesTable, (err) => {\r\n                    if (err) {\r\n                        logger.error('[TicketDb] Error creating replies table:', err);\r\n                        logger.error('[TicketDb] SQL:', createRepliesTable);\r\n                        reject(err);\r\n                        return;\r\n                    }\r\n                    logger.info('[TicketDb] Γ£à replies table ready');\r\n                });\r\n\r\n                // Create meta table\r\n                const createMetaTable = `\r\n                    CREATE TABLE IF NOT EXISTS meta (\r\n                        key TEXT PRIMARY KEY,\r\n                        value TEXT\r\n                    )\r\n                `;\r\n\r\n                this.db!.run(createMetaTable, (err) => {\r\n                    if (err) {\r\n                        logger.error('[TicketDb] Error creating meta table:', err);\r\n                        logger.error('[TicketDb] SQL:', createMetaTable);\r\n                        reject(err);\r\n                        return;\r\n                    }\r\n                    logger.info('[TicketDb] Γ£à meta table ready');\r\n                });\r\n\r\n                // Set schema version\r\n                this.db!.run(\r\n                    \"INSERT OR IGNORE INTO meta (key, value) VALUES ('schema_version', ?)\",\r\n                    [this.schemaVersion.toString()],\r\n                    (err) => {\r\n                        if (err) {\r\n                            logger.error('[TicketDb] Error setting schema version:', err);\r\n                            reject(err);\r\n                            return;\r\n                        }\r\n                        logger.info('[TicketDb] Schema version set');\r\n                        resolve();\r\n                    }\r\n                );\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new ticket\r\n     *\r\n     * Generates unique ID and timestamps, validates required fields.\r\n     * Enforces max ticket limit to prevent bloat.\r\n     * Automatically routes ticket to appropriate agent team and adds task to queue.\r\n     *\r\n     * @param {Partial<Ticket>} ticket - Ticket data (type, priority, title, description)\r\n     * @param {Object} options - Optional configuration\r\n     * @param {boolean} options.skipRouting - Skip automatic routing (default: false)\r\n     * @returns {Promise<Ticket>} Created ticket with ID and timestamps\r\n     * @throws {TicketError} If limit exceeded or required fields missing\r\n     *\r\n     * @example\r\n     * const ticket = await ticketDb.createTicket({\r\n     *   type: 'ai_to_human',\r\n     *   priority: 1,\r\n     *   title: 'Agent coordination question',\r\n     *   description: 'How to implement task routing?'\r\n     * });\r\n     */\r\n    async createTicket(ticket: Partial<Ticket>, options?: { skipRouting?: boolean }): Promise<Ticket> {\r\n        const id = `ticket_${Date.now()}_${randomUUID().substring(0, 8)}`;\r\n        const now = new Date();\r\n\r\n        const fullTicket: Ticket = {\r\n            id,\r\n            type: ticket.type || 'ai_to_human',\r\n            status: ticket.status || 'open',\r\n            priority: ticket.priority || 2,\r\n            title: ticket.title || '',\r\n            description: ticket.description || '',\r\n            createdAt: now,\r\n            updatedAt: now,\r\n            assignee: ticket.assignee,\r\n            labels: ticket.labels,\r\n        };\r\n\r\n        // Validate\r\n        if (!fullTicket.title) {\r\n            throw new TicketError('Ticket title is required');\r\n        }\r\n\r\n        try {\r\n            if (this.useFallback) {\r\n                if (this.fallbackTickets.size >= this.maxTickets) {\r\n                    throw new TicketError(`Max tickets (${this.maxTickets}) reached`);\r\n                }\r\n                this.fallbackTickets.set(id, fullTicket);\r\n\r\n                // Route and enqueue even in fallback mode (unless skipped)\r\n                if (!options?.skipRouting) {\r\n                    try {\r\n                        await this.routeAndEnqueueTicket(fullTicket);\r\n                    } catch (error) {\r\n                        logger.warn(`Failed to route ticket in fallback mode: ${error}`);\r\n                    }\r\n                }\r\n\r\n                return fullTicket;\r\n            }\r\n\r\n            // Check count\r\n            const countResult = await this.getAsync('SELECT COUNT(*) as count FROM tickets');\r\n            if (countResult && countResult.count >= this.maxTickets) {\r\n                throw new TicketError(`Max tickets (${this.maxTickets}) reached`);\r\n            }\r\n\r\n            const labels = fullTicket.labels ? JSON.stringify(fullTicket.labels) : null;\r\n\r\n            await this.runWithRetry(() => this.runAsync(\r\n                `INSERT INTO tickets (id, type, status, priority, title, description, assignee, labels)\r\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\r\n                [\r\n                    fullTicket.id,\r\n                    fullTicket.type,\r\n                    fullTicket.status,\r\n                    fullTicket.priority,\r\n                    fullTicket.title,\r\n                    fullTicket.description,\r\n                    fullTicket.assignee || null,\r\n                    labels,\r\n                ]\r\n            ));\r\n\r\n            // Route and enqueue ticket to task queue (unless explicitly skipped)\r\n            if (!options?.skipRouting) {\r\n                try {\r\n                    await this.routeAndEnqueueTicket(fullTicket);\r\n                } catch (error) {\r\n                    // Log error but don't throw - ticket is already saved\r\n                    logger.error(`Failed to route/enqueue ticket ${fullTicket.id}: ${error}`);\r\n                }\r\n            }\r\n\r\n            return fullTicket;\r\n        } catch (error) {\r\n            if (error instanceof TicketError) throw error;\r\n            logger.error(`≡ƒÄ½ Failed to create ticket: ${error}`, { error });\r\n            throw new TicketError(`Create ticket failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒÄ» Route ticket to agent team and add task to orchestrator queue\r\n     * \r\n     * Private method called automatically by createTicket().\r\n     * Routes ticket using BossRouter, then creates a task in the orchestrator queue.\r\n     * Includes error handling to avoid losing tickets if routing fails.\r\n     * \r\n     * @private\r\n     * @param {Ticket} ticket - The ticket to route\r\n     * @returns {Promise<void>}\r\n     */\r\n    private async routeAndEnqueueTicket(ticket: Ticket): Promise<void> {\r\n        try {\r\n            // Get singleton instances\r\n            const router = BossRouter.getInstance();\r\n\r\n            // Dynamically import to avoid circular dependency\r\n            // getOrchestrator() is exported from extension.ts\r\n            let orchestrator;\r\n            try {\r\n                const extensionModule = await import('../extension');\r\n                orchestrator = extensionModule.getOrchestrator();\r\n            } catch (error) {\r\n                logger.warn('Orchestrator not available yet, skipping task enqueue');\r\n                return;\r\n            }\r\n\r\n            if (!orchestrator) {\r\n                logger.info('Orchestrator not initialized, skipping routing');\r\n                return;\r\n            }\r\n\r\n            // Convert TicketDb.Ticket to format expected by BossRouter\r\n            // BossRouter expects: ticket_id, type, priority, title, description\r\n            const ticketForRouter = {\r\n                ticket_id: ticket.id,\r\n                type: ticket.type,\r\n                priority: ticket.priority,\r\n                title: ticket.title,\r\n                description: ticket.description,\r\n                status: ticket.status,\r\n                creator: ticket.assignee || 'system',\r\n                assignee: ticket.assignee || 'unassigned',\r\n                thread: [],\r\n                created_at: ticket.createdAt,\r\n                updated_at: ticket.updatedAt,\r\n            };\r\n\r\n            // Route ticket to determine agent team\r\n            let routedTeam: string;\r\n            try {\r\n                routedTeam = router.routeTicket(ticketForRouter as any);\r\n                logger.info(`≡ƒÄ» Ticket ${ticket.id} routed to ${routedTeam}`);\r\n            } catch (error) {\r\n                logger.warn(`Failed to route ticket ${ticket.id}, escalating: ${error}`);\r\n                routedTeam = 'escalate';\r\n            }\r\n\r\n            // Check if task already exists for this ticket (duplicate prevention)\r\n            const taskExists = await orchestrator.hasTaskForTicket(ticket.id);\r\n            if (taskExists) {\r\n                logger.info(`ΓÅ¡∩╕Å Task already exists for ticket ${ticket.id}, skipping enqueue`);\r\n                return;\r\n            }\r\n\r\n            // Create task object with metadata linking to ticket\r\n            const taskId = `task-${ticket.id}`;\r\n            const task = {\r\n                taskId,\r\n                title: ticket.title,\r\n                description: ticket.description,\r\n                // Map ticket priority (1,2,3) to task priority (P1, P2, P3)\r\n                priority: ticket.priority === 1 ? TaskPriority.P1 :\r\n                    ticket.priority === 2 ? TaskPriority.P2 :\r\n                        TaskPriority.P3,\r\n                status: TaskStatus.READY,\r\n                dependencies: [],\r\n                blockedBy: [],\r\n                estimatedHours: 1,\r\n                acceptanceCriteria: [\r\n                    `Address ticket: ${ticket.title}`,\r\n                    'Provide complete and accurate response',\r\n                    'Assign to appropriate team for follow-up'\r\n                ],\r\n                relatedFiles: [],\r\n                fromPlanningTeam: true, // Tickets treated as planning items from user\r\n                createdAt: new Date(),\r\n                assignedTo: routedTeam,\r\n                // Store ticket metadata for reference\r\n                metadata: {\r\n                    ticketId: ticket.id,\r\n                    routedTeam: routedTeam,\r\n                    isFromTicket: true,\r\n                }\r\n            };\r\n\r\n            // Add task to orchestrator queue\r\n            orchestrator.addTask(task);\r\n            logger.info(`Γ£à Ticket ${ticket.id} routed to ${routedTeam} ΓåÆ queued as task ${taskId}`);\r\n\r\n        } catch (error) {\r\n            // Non-critical error - ticket is already saved\r\n            // Don't re-throw, just log\r\n            logger.error(`Failed to route/enqueue ticket: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a ticket by ID\r\n     *\r\n     * @param {string} id - Ticket ID\r\n     * @returns {Promise<Ticket | null>} Ticket or null if not found\r\n     *\r\n     * @example\r\n     * const ticket = await ticketDb.getTicket('ticket_123_xyz');\r\n     */\r\n    async getTicket(id: string): Promise<Ticket | null> {\r\n        try {\r\n            if (this.useFallback) {\r\n                return this.fallbackTickets.get(id) || null;\r\n            }\r\n\r\n            const row = await this.getAsync('SELECT * FROM tickets WHERE id = ?', [id]);\r\n            return row ? this.rowToTicket(row) : null;\r\n        } catch (error) {\r\n            logger.error(`≡ƒÄ½ Failed to get ticket ${id}: ${error}`, { error });\r\n            throw new TicketError(`Get ticket failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update a ticket\r\n     *\r\n     * Merges updates with existing ticket, updates timestamp.\r\n     *\r\n     * @param {string} id - Ticket ID\r\n     * @param {Partial<Ticket>} updates - Fields to update (status, priority, etc.)\r\n     * @returns {Promise<Ticket>} Updated ticket\r\n     * @throws {TicketError} If ticket not found\r\n     *\r\n     * @example\r\n     * const updated = await ticketDb.updateTicket('ticket_123_xyz', {\r\n     *   status: 'resolved',\r\n     *   priority: 1\r\n     * });\r\n     */\r\n    async updateTicket(id: string, updates: Partial<Ticket>): Promise<Ticket> {\r\n        try {\r\n            const existing = await this.getTicket(id);\r\n            if (!existing) {\r\n                throw new TicketError(`Ticket not found: ${id}`);\r\n            }\r\n\r\n            const updated: Ticket = { ...existing, ...updates, id, updatedAt: new Date() };\r\n\r\n            if (this.useFallback) {\r\n                this.fallbackTickets.set(id, updated);\r\n                return updated;\r\n            }\r\n\r\n            const labels = updated.labels ? JSON.stringify(updated.labels) : null;\r\n\r\n            await this.runWithRetry(() => this.runAsync(\r\n                `UPDATE tickets SET type=?, status=?, priority=?, title=?, description=?, assignee=?, labels=?, updated_at=CURRENT_TIMESTAMP\r\n         WHERE id = ?`,\r\n                [\r\n                    updated.type,\r\n                    updated.status,\r\n                    updated.priority,\r\n                    updated.title,\r\n                    updated.description,\r\n                    updated.assignee || null,\r\n                    labels,\r\n                    id,\r\n                ]\r\n            ));\r\n\r\n            return updated;\r\n        } catch (error) {\r\n            if (error instanceof TicketError) throw error;\r\n            logger.error(`≡ƒÄ½ Failed to update ticket ${id}: ${error}`, { error });\r\n            throw new TicketError(`Update ticket failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a ticket and its replies\r\n     *\r\n     * @param {string} id - Ticket ID\r\n     * @returns {Promise<boolean>} True if deleted, false if not found\r\n     *\r\n     * @example\r\n     * const deleted = await ticketDb.deleteTicket('ticket_123_xyz');\r\n     */\r\n    async deleteTicket(id: string): Promise<boolean> {\r\n        try {\r\n            if (this.useFallback) {\r\n                const existed = this.fallbackTickets.has(id);\r\n                this.fallbackTickets.delete(id);\r\n                this.fallbackReplies.delete(id);\r\n                return existed;\r\n            }\r\n\r\n            await this.runWithRetry(() => this.runAsync('DELETE FROM tickets WHERE id = ?', [id]));\r\n            return true;\r\n        } catch (error) {\r\n            logger.error(`≡ƒÄ½ Failed to delete ticket ${id}: ${error}`, { error });\r\n            throw new TicketError(`Delete ticket failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a reply to a ticket\r\n     *\r\n     * Creates threaded conversation on a ticket.\r\n     *\r\n     * @param {Partial<Reply>} reply - Reply data (ticketId, author, content)\r\n     * @returns {Promise<Reply>} Created reply with ID and timestamp\r\n     * @throws {TicketError} If ticket not found\r\n     *\r\n     * @example\r\n     * const reply = await ticketDb.addReply({\r\n     *   ticketId: 'ticket_123_xyz',\r\n     *   author: 'ai',\r\n     *   content: 'Here is my answer based on the codebase...'\r\n     * });\r\n     */\r\n    async addReply(reply: Partial<Reply>): Promise<Reply> {\r\n        const id = `reply_${Date.now()}_${randomUUID().substring(0, 8)}`;\r\n\r\n        const fullReply: Reply = {\r\n            id,\r\n            ticketId: reply.ticketId || '',\r\n            author: reply.author || 'ai',\r\n            content: reply.content || '',\r\n            createdAt: new Date(),\r\n        };\r\n\r\n        try {\r\n            // Verify ticket exists\r\n            const ticket = await this.getTicket(fullReply.ticketId);\r\n            if (!ticket) {\r\n                throw new TicketError(`Ticket not found: ${fullReply.ticketId}`);\r\n            }\r\n\r\n            if (this.useFallback) {\r\n                if (!this.fallbackReplies.has(fullReply.ticketId)) {\r\n                    this.fallbackReplies.set(fullReply.ticketId, []);\r\n                }\r\n                this.fallbackReplies.get(fullReply.ticketId)!.push(fullReply);\r\n                return fullReply;\r\n            }\r\n\r\n            await this.runWithRetry(() => this.runAsync(\r\n                `INSERT INTO replies (id, ticket_id, author, content)\r\n         VALUES (?, ?, ?, ?)`,\r\n                [fullReply.id, fullReply.ticketId, fullReply.author, fullReply.content]\r\n            ));\r\n\r\n            return fullReply;\r\n        } catch (error) {\r\n            if (error instanceof TicketError) throw error;\r\n            logger.error(`≡ƒÄ½ Failed to add reply: ${error}`, { error });\r\n            throw new TicketError(`Add reply failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all replies for a ticket\r\n     *\r\n     * @param {string} ticketId - Ticket ID\r\n     * @returns {Promise<Reply[]>} Array of replies ordered by creation date\r\n     *\r\n     * @example\r\n     * const replies = await ticketDb.getReplies('ticket_123_xyz');\r\n     * // Process replies: replies.forEach(r => { handleReply(r.content); });\r\n     */\r\n\r\n    async getReplies(ticketId: string): Promise<Reply[]> {\r\n        try {\r\n            if (this.useFallback) {\r\n                return this.fallbackReplies.get(ticketId) || [];\r\n            }\r\n\r\n            const rows = await this.allAsync(\r\n                `SELECT * FROM replies WHERE ticket_id = ? ORDER BY created_at ASC`,\r\n                [ticketId]\r\n            );\r\n\r\n            return rows.map(row => this.rowToReply(row));\r\n        } catch (error) {\r\n            logger.error(`≡ƒÄ½ Failed to get replies for ${ticketId}: ${error}`, { error });\r\n            throw new TicketError(`Get replies failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ≡ƒùæ∩╕Å Close database connection and release resources\r\n     * \r\n     * Safely closes SQLite connection with retry logic and nulls the handle\r\n     * to ensure file lock is released (important for OneDrive/Windows).\r\n     * \r\n     * @async\r\n     * @returns {Promise<void>}\r\n     */\r\n    async close(): Promise<void> {\r\n        if (!this.db) {\r\n            logger.info('[TicketDb] No database to close');\r\n            return;\r\n        }\r\n\r\n        logger.info(`[TicketDb] Closing database at ${new Date().toISOString()}`);\r\n\r\n        try {\r\n            await new Promise<void>((resolve, reject) => {\r\n                this.db!.close((err) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve();\r\n                    }\r\n                });\r\n            });\r\n\r\n            logger.info(`[TicketDb] Γ£à Database closed successfully at ${new Date().toISOString()}`);\r\n        } catch (error) {\r\n            logger.error('[TicketDb] Error closing database:', error);\r\n            logger.error('[TicketDb] Stack trace:', error instanceof Error ? error.stack : 'N/A');\r\n\r\n            // Retry once after delay (OneDrive workaround)\r\n            logger.warn('[TicketDb] Retrying close after 1000ms delay...');\r\n            await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n            try {\r\n                await new Promise<void>((resolve, reject) => {\r\n                    this.db!.close((err) => {\r\n                        if (err) {\r\n                            reject(err);\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    });\r\n                });\r\n                logger.info('[TicketDb] Γ£à Database closed successfully on retry');\r\n            } catch (retryError) {\r\n                logger.error('[TicketDb] Failed to close database on retry:', retryError);\r\n                throw retryError;\r\n            }\r\n        } finally {\r\n            // Always null the handle to release reference\r\n            this.db = null;\r\n            this.isInitialized = false;\r\n            logger.info('[TicketDb] Database handle nulled and initialization flag reset');\r\n        }\r\n    }\r\n\r\n    // ============================================================================\r\n    // Private Helper Methods\r\n    // ============================================================================\r\n\r\n    /**\r\n     * Run operation with retry logic for EBUSY errors\r\n     * \r\n     * Retries operations that fail with EBUSY/locked errors (common on OneDrive).\r\n     * After max retries, switches to fallback mode.\r\n     * \r\n     * @param operation - Async operation to retry\r\n     * @param attemptNum - Current attempt number (internal)\r\n     * @returns Promise resolving to operation result\r\n     */\r\n    private async runWithRetry<T>(\r\n        operation: () => Promise<T>,\r\n        attemptNum: number = 1\r\n    ): Promise<T> {\r\n        try {\r\n            return await operation();\r\n        } catch (error) {\r\n            const errMsg = error instanceof Error ? error.message : String(error);\r\n            const isEBUSY = errMsg.includes('EBUSY') || errMsg.includes('locked');\r\n\r\n            if (isEBUSY && attemptNum < this.retryConfig.maxAttempts) {\r\n                logger.warn(\r\n                    `ΓÜá∩╕Å  DB operation failed (attempt ${attemptNum}/${this.retryConfig.maxAttempts}): ${errMsg} - retrying...`\r\n                );\r\n                await new Promise(resolve => setTimeout(resolve, this.retryConfig.delayMs));\r\n                return this.runWithRetry(operation, attemptNum + 1);\r\n            }\r\n\r\n            // Max retries exceeded or non-EBUSY error\r\n            if (isEBUSY) {\r\n                logger.error(\r\n                    `Γ¥î DB operation failed after ${this.retryConfig.maxAttempts} attempts - switching to fallback`\r\n                );\r\n                this.useFallback = true;\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async runAsync(sql: string, params: any[] = []): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            this.db.run(sql, params, function (err) {\r\n                if (err) reject(err);\r\n                else resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    private async getAsync(sql: string, params: any[] = []): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            this.db.get(sql, params, (err, row) => {\r\n                if (err) reject(err);\r\n                else resolve(row);\r\n            });\r\n        });\r\n    }\r\n\r\n    private async allAsync(sql: string, params: any[] = []): Promise<any[]> {\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.db) {\r\n                reject(new Error('Database not initialized'));\r\n                return;\r\n            }\r\n\r\n            this.db.all(sql, params, (err, rows) => {\r\n                if (err) reject(err);\r\n                else resolve(rows || []);\r\n            });\r\n        });\r\n    }\r\n\r\n    private rowToTicket(row: any): Ticket {\r\n        return {\r\n            id: row.id,\r\n            type: row.type,\r\n            status: row.status,\r\n            priority: row.priority,\r\n            title: row.title,\r\n            description: row.description,\r\n            createdAt: new Date(row.created_at),\r\n            updatedAt: new Date(row.updated_at),\r\n            assignee: row.assignee,\r\n            labels: row.labels ? JSON.parse(row.labels) : undefined,\r\n        };\r\n    }\r\n\r\n    private rowToReply(row: any): Reply {\r\n        return {\r\n            id: row.id,\r\n            ticketId: row.ticket_id,\r\n            author: row.author,\r\n            content: row.content,\r\n            createdAt: new Date(row.created_at),\r\n        };\r\n    }\r\n}\r\n\r\nexport default TicketDb;\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\sum.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\tasks\\dependencies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\tasks\\queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\tasks\\taskManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updates' is defined but never used.","line":49,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":49,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'taskId' is defined but never used.","line":65,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":65,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Task Manager\r\n * High-level task management operations (CRUD)\r\n */\r\n\r\nimport { Task, TaskQueue } from './queue';\r\n\r\nexport class TaskManager {\r\n    private queue: TaskQueue;\r\n\r\n    constructor(queue: TaskQueue) {\r\n        this.queue = queue;\r\n    }\r\n\r\n    /**\r\n     * Create a new task\r\n     */\r\n    createTask(\r\n        title: string,\r\n        description: string,\r\n        priority: Task['priority'] = 'medium'\r\n    ): Task {\r\n        const task: Task = {\r\n            taskId: this.generateTaskId(),\r\n            title,\r\n            description,\r\n            priority,\r\n            status: 'pending',\r\n            dependencies: [],\r\n            createdAt: new Date(),\r\n            updatedAt: new Date()\r\n        };\r\n\r\n        this.queue.addTask(task);\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     * Get a task by ID\r\n     */\r\n    getTask(taskId: string): Task | null {\r\n        const allTasks = this.queue.getAllTasks();\r\n        return allTasks.find(t => t.taskId === taskId) || null;\r\n    }\r\n\r\n    /**\r\n     * Update a task\r\n     */\r\n    updateTask(taskId: string, updates: Partial<Task>): boolean {\r\n        const task = this.getTask(taskId);\r\n        if (!task) {\r\n            return false;\r\n        }\r\n\r\n        // TODO: Apply updates to task\r\n        // TODO: Validate changes\r\n        // TODO: Notify listeners\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Delete a task\r\n     */\r\n    deleteTask(taskId: string): boolean {\r\n        // TODO: Remove from queue\r\n        // TODO: Update dependents\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Generate a unique task ID\r\n     */\r\n    private generateTaskId(): string {\r\n        return `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\test\\runTest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\test\\suite\\extension.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\test\\suite\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\test\\suite\\llmConfigManager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\test\\suite\\setupFiles.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1415,1418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1415,1418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ≡ƒº¬ Integration Tests for Workspace Setup Files\r\n * \r\n * Tests the setupMissingFiles() utility that auto-creates configuration\r\n * and plan files on extension startup if they don't exist.\r\n * \r\n * Note: These are integration tests that verify setupMissingFiles is properly\r\n * integrated into the extension. Full unit tests with mocks are in the\r\n * Jest test files.\r\n */\r\n\r\nimport * as assert from 'assert';\r\nimport { setupMissingFiles } from '../../utils/setupFiles';\r\n\r\nsuite('Workspace Setup Files Test Suite', () => {\r\n    // ========================================================================\r\n    // Test: setupMissingFiles exists and is callable\r\n    // ========================================================================\r\n    test('setupMissingFiles should be a callable function', () => {\r\n        assert.strictEqual(\r\n            typeof setupMissingFiles,\r\n            'function',\r\n            'setupMissingFiles should be a function'\r\n        );\r\n    });\r\n\r\n    // ========================================================================\r\n    // Test: setupMissingFiles can be called and returns a Promise\r\n    // ========================================================================\r\n    test('setupMissingFiles should return a Promise', () => {\r\n        const result = setupMissingFiles();\r\n        assert.ok(\r\n            result instanceof Promise || (result && typeof (result as any).then === 'function'),\r\n            'setupMissingFiles should return a Promise'\r\n        );\r\n    });\r\n\r\n    // ========================================================================\r\n    // Test: setupMissingFiles executes without error in test environment\r\n    // ========================================================================\r\n    test('setupMissingFiles should execute without throwing errors', async () => {\r\n        try {\r\n            // In the test environment, there is typically no workspace folder,\r\n            // so setupMissingFiles should return early gracefully\r\n            await setupMissingFiles();\r\n            assert.ok(true, 'Function executed successfully');\r\n        } catch (error) {\r\n            assert.fail(\r\n                `setupMissingFiles threw an error: ${error instanceof Error ? error.message : String(error)}`\r\n            );\r\n        }\r\n    });\r\n\r\n    // ========================================================================\r\n    // Test: setupMissingFiles is available and can be imported\r\n    // ========================================================================\r\n    test('setupMissingFiles should be importable from utils/setupFiles', () => {\r\n        assert.ok(\r\n            setupMissingFiles !== undefined,\r\n            'setupMissingFiles should be defined and importable'\r\n        );\r\n    });\r\n});\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\tree\\CoeTaskTreeProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\types\\__tests__\\agentTeam.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\types\\__tests__\\ticket.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\types\\agentTeam.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\types\\ticket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\ui\\completedTasksTreeProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2054,2057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2054,2057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Completed Tasks Tree View (History)\r\n * Displays completed tasks history from the database in a collapsible tree\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport { TicketDatabase } from '../db/ticketsDb';\r\n\r\n/**\r\n * Completed task data structure (from completed_tasks table)\r\n */\r\ninterface CompletedTask {\r\n    task_id: string;\r\n    original_ticket_id?: string;\r\n    title: string;\r\n    status: string;\r\n    priority: number;\r\n    completed_at: string;\r\n    duration_minutes?: number;\r\n    outcome?: string;\r\n    created_at: string;\r\n}\r\n\r\n/**\r\n * Tree data provider for completed tasks history\r\n */\r\nexport class CompletedTasksTreeProvider implements vscode.TreeDataProvider<CompletedTaskTreeItem> {\r\n    private _onDidChangeTreeData: vscode.EventEmitter<CompletedTaskTreeItem | undefined | null | void> =\r\n        new vscode.EventEmitter<CompletedTaskTreeItem | undefined | null | void>();\r\n    readonly onDidChangeTreeData: vscode.Event<CompletedTaskTreeItem | undefined | null | void> =\r\n        this._onDidChangeTreeData.event;\r\n\r\n    private ticketDb: TicketDatabase;\r\n    private retentionHours: number = 168; // Default 7 days\r\n\r\n    constructor(ticketDb: TicketDatabase) {\r\n        this.ticketDb = ticketDb;\r\n    }\r\n\r\n    /**\r\n     * Refresh the tree view\r\n     */\r\n    refresh(): void {\r\n        this._onDidChangeTreeData.fire();\r\n    }\r\n\r\n    /**\r\n     * Update retention settings (from config)\r\n     */\r\n    updateRetention(maxAgeHours: number): void {\r\n        this.retentionHours = maxAgeHours;\r\n        this.refresh();\r\n    }\r\n\r\n    /**\r\n     * Get tree item for display\r\n     */\r\n    getTreeItem(element: CompletedTaskTreeItem): vscode.TreeItem {\r\n        return element;\r\n    }\r\n\r\n    /**\r\n     * Get children of an element\r\n     */\r\n    async getChildren(element?: CompletedTaskTreeItem): Promise<CompletedTaskTreeItem[]> {\r\n        if (element) {\r\n            // No nested children (flat list)\r\n            return [];\r\n        }\r\n\r\n        try {\r\n            // Fetch completed tasks from database\r\n            const filters: any = {};\r\n\r\n            // Apply retention filter if configured (convert hours to days)\r\n            if (this.retentionHours > 0) {\r\n                filters.minDaysAgo = Math.ceil(this.retentionHours / 24);\r\n            }\r\n\r\n            const completedTasks = await this.ticketDb.getAllCompleted(filters);\r\n\r\n            if (completedTasks.length === 0) {\r\n                // Show placeholder when no history\r\n                return [\r\n                    new CompletedTaskTreeItem(\r\n                        'No completed tasks yet',\r\n                        vscode.TreeItemCollapsibleState.None,\r\n                        null,\r\n                        true // isPlaceholder\r\n                    )\r\n                ];\r\n            }\r\n\r\n            // Map tasks to tree items\r\n            return completedTasks.map(task => {\r\n                const timeAgo = this.getTimeAgo(task.completed_at);\r\n                const icon = this.getStatusIcon(task.status);\r\n                const label = `${icon} ${task.title}`;\r\n\r\n                return new CompletedTaskTreeItem(\r\n                    label,\r\n                    vscode.TreeItemCollapsibleState.None,\r\n                    task,\r\n                    false,\r\n                    timeAgo\r\n                );\r\n            });\r\n\r\n        } catch (error) {\r\n\r\n            // Show error placeholder\r\n            return [\r\n                new CompletedTaskTreeItem(\r\n                    'ΓÜá∩╕Å Error loading history',\r\n                    vscode.TreeItemCollapsibleState.None,\r\n                    null,\r\n                    true\r\n                )\r\n            ];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get icon for task status\r\n     */\r\n    private getStatusIcon(status: string): string {\r\n        switch (status) {\r\n            case 'completed': return 'Γ£à';\r\n            case 'failed': return 'Γ¥î';\r\n            case 'archived': return '≡ƒôª';\r\n            default: return 'Γ£ö∩╕Å';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get human-readable time ago from ISO string\r\n     */\r\n    private getTimeAgo(isoString: string): string {\r\n        const now = new Date().getTime();\r\n        const then = new Date(isoString).getTime();\r\n        const diffMs = now - then;\r\n\r\n        const minutes = Math.floor(diffMs / 60000);\r\n        const hours = Math.floor(minutes / 60);\r\n        const days = Math.floor(hours / 24);\r\n\r\n        if (minutes < 60) {\r\n            return `${minutes}m ago`;\r\n        } else if (hours < 24) {\r\n            return `${hours}h ago`;\r\n        } else if (days < 7) {\r\n            return `${days}d ago`;\r\n        } else {\r\n            const weeks = Math.floor(days / 7);\r\n            return `${weeks}w ago`;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Tree item for completed task\r\n */\r\nexport class CompletedTaskTreeItem extends vscode.TreeItem {\r\n    constructor(\r\n        public readonly label: string,\r\n        public readonly collapsibleState: vscode.TreeItemCollapsibleState,\r\n        public readonly task: CompletedTask | null,\r\n        public readonly isPlaceholder: boolean = false,\r\n        public readonly timeAgo?: string\r\n    ) {\r\n        super(label, collapsibleState);\r\n\r\n        if (task && !isPlaceholder) {\r\n            // Add description (time ago) - set first\r\n            if (timeAgo) {\r\n                this.description = timeAgo;\r\n            }\r\n\r\n            // Add tooltip with task details\r\n            this.tooltip = new vscode.MarkdownString();\r\n            this.tooltip.appendMarkdown(`**${task.title}**\\n\\n`);\r\n            this.tooltip.appendMarkdown(`**Status:** ${task.status}\\n\\n`);\r\n            this.tooltip.appendMarkdown(`**Completed:** ${timeAgo || new Date(task.completed_at).toLocaleString()}\\n\\n`);\r\n\r\n            if (task.duration_minutes) {\r\n                this.tooltip.appendMarkdown(`**Duration:** ${task.duration_minutes} minutes\\n\\n`);\r\n            }\r\n\r\n            if (task.outcome) {\r\n                this.tooltip.appendMarkdown(`**Outcome:** ${task.outcome}\\n\\n`);\r\n            }\r\n\r\n            // Add context value for commands\r\n            this.contextValue = 'completedTask';\r\n        } else if (isPlaceholder) {\r\n            this.contextValue = 'placeholder';\r\n            this.iconPath = new vscode.ThemeIcon('info');\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\ui\\plansPanel.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[916,919],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[916,919],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Plans Panel (Frontend)\r\n * Displays plan.json content in a webview panel\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\n\r\nexport class PlansPanel {\r\n    private panel: vscode.WebviewPanel | undefined;\r\n\r\n    /**\r\n     * Show the plans panel\r\n     */\r\n    show(context: vscode.ExtensionContext): void {\r\n        if (this.panel) {\r\n            this.panel.reveal();\r\n            return;\r\n        }\r\n\r\n        this.panel = vscode.window.createWebviewPanel(\r\n            'coePlans',\r\n            'COE Plans',\r\n            vscode.ViewColumn.Two,\r\n            {\r\n                enableScripts: true,\r\n                retainContextWhenHidden: true\r\n            }\r\n        );\r\n\r\n        this.panel.webview.html = this.getWebviewContent();\r\n\r\n        this.panel.onDidDispose(() => {\r\n            this.panel = undefined;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update panel content\r\n     */\r\n    updatePlanContent(planData: any): void {\r\n        if (this.panel) {\r\n            this.panel.webview.postMessage({\r\n                command: 'updatePlan',\r\n                data: planData\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate HTML content for the webview\r\n     */\r\n    private getWebviewContent(): string {\r\n        return `\r\n            <!DOCTYPE html>\r\n            <html lang=\"en\">\r\n            <head>\r\n                <meta charset=\"UTF-8\">\r\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n                <title>COE Plans</title>\r\n                <style>\r\n                    body {\r\n                        font-family: var(--vscode-font-family);\r\n                        color: var(--vscode-foreground);\r\n                        background-color: var(--vscode-editor-background);\r\n                        padding: 20px;\r\n                    }\r\n                    h1 { color: var(--vscode-textLink-foreground); }\r\n                    .plan-section {\r\n                        margin: 20px 0;\r\n                        padding: 15px;\r\n                        border: 1px solid var(--vscode-panel-border);\r\n                        border-radius: 4px;\r\n                    }\r\n                    .task-item {\r\n                        padding: 8px;\r\n                        margin: 5px 0;\r\n                        background: var(--vscode-editor-inactiveSelectionBackground);\r\n                    }\r\n                </style>\r\n            </head>\r\n            <body>\r\n                <h1>≡ƒôï Project Plan</h1>\r\n                <div id=\"plan-content\">\r\n                    <p>Loading plan data...</p>\r\n                </div>\r\n                \r\n                <script>\r\n                    const vscode = acquireVsCodeApi();\r\n                    \r\n                    window.addEventListener('message', event => {\r\n                        const message = event.data;\r\n                        if (message.command === 'updatePlan') {\r\n                            document.getElementById('plan-content').innerHTML = \r\n                                '<pre>' + JSON.stringify(message.data, null, 2) + '</pre>';\r\n                        }\r\n                    });\r\n                </script>\r\n            </body>\r\n            </html>\r\n        `;\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\ui\\statusBar.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\ui\\tasksTreeView.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\utils\\__tests__\\config.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'COEConfig' is defined but never used.","line":8,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":34},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[567,570],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[567,570],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[594,597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[594,597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[621,624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[621,624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[742,745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[742,745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3890,3893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3890,3893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4756,4759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4756,4759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5949,5952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5949,5952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":189,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6396,6399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6396,6399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6548,6551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6548,6551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":199,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6770,6773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6770,6773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":204,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":204,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6986,6989],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6986,6989],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is assigned a value but never used.","line":266,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":266,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":352,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":352,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13253,13256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13253,13256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":355,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13393,13396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13393,13396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ≡ƒº¬ Comprehensive Tests for ConfigManager\r\n *\r\n * Tests all configuration branches including secure storage and validation\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport { ConfigManager, COEConfig } from '../config';\r\n\r\njest.mock('vscode', () => ({\r\n    workspace: {\r\n        getConfiguration: jest.fn(),\r\n    },\r\n    window: {\r\n        showInputBox: jest.fn(),\r\n        showInformationMessage: jest.fn(),\r\n    },\r\n    ConfigurationTarget: {\r\n        Workspace: 1,\r\n        Global: 2,\r\n    },\r\n}));\r\n\r\ndescribe('ConfigManager', () => {\r\n    let mockConfig: any;\r\n    let mockSecrets: any;\r\n    let mockContext: any;\r\n\r\n    beforeEach(() => {\r\n        jest.clearAllMocks();\r\n\r\n        // Reset token cache\r\n        (ConfigManager as any).tokenCache = null;\r\n\r\n        mockConfig = {\r\n            get: jest.fn(),\r\n            update: jest.fn(),\r\n        };\r\n\r\n        mockSecrets = {\r\n            get: jest.fn(),\r\n            store: jest.fn(),\r\n            delete: jest.fn(),\r\n        };\r\n\r\n        mockContext = {\r\n            secrets: mockSecrets,\r\n        };\r\n\r\n        (vscode.workspace.getConfiguration as jest.Mock).mockReturnValue(mockConfig);\r\n    });\r\n\r\n    describe('get', () => {\r\n        it('should retrieve configuration value', () => {\r\n            mockConfig.get.mockReturnValue('test-value');\r\n\r\n            const result = ConfigManager.get('key1');\r\n\r\n            expect(result).toBe('test-value');\r\n            expect(mockConfig.get).toHaveBeenCalledWith('key1', undefined);\r\n        });\r\n\r\n        it('should return default value when key not found', () => {\r\n            mockConfig.get.mockReturnValue('default-value');\r\n\r\n            const result = ConfigManager.get('missing-key', 'default-value');\r\n\r\n            expect(result).toBe('default-value');\r\n        });\r\n\r\n        it('should handle typed configuration values', () => {\r\n            mockConfig.get.mockReturnValue(true);\r\n\r\n            const result = ConfigManager.get<boolean | undefined>('enabled', false);\r\n\r\n            expect(result).toBe(true);\r\n        });\r\n\r\n        it('should handle numeric configuration values', () => {\r\n            mockConfig.get.mockReturnValue(3000);\r\n\r\n            const result = ConfigManager.get<number | undefined>('port', 8080);\r\n\r\n            expect(result).toBe(3000);\r\n        });\r\n\r\n        it('should handle object configuration values', () => {\r\n            const obj = { nested: 'value' };\r\n            mockConfig.get.mockReturnValue(obj);\r\n\r\n            const result = ConfigManager.get('config');\r\n\r\n            expect(result).toEqual(obj);\r\n        });\r\n    });\r\n\r\n    describe('set', () => {\r\n        it('should set configuration value with default target', async () => {\r\n            await ConfigManager.set('key1', 'value1');\r\n\r\n            expect(mockConfig.update).toHaveBeenCalledWith('key1', 'value1', vscode.ConfigurationTarget.Workspace);\r\n        });\r\n\r\n        it('should set configuration value with custom target', async () => {\r\n            await ConfigManager.set('key1', 'value1', vscode.ConfigurationTarget.Global);\r\n\r\n            expect(mockConfig.update).toHaveBeenCalledWith('key1', 'value1', vscode.ConfigurationTarget.Global);\r\n        });\r\n\r\n        it('should handle setting null value', async () => {\r\n            await ConfigManager.set('key1', null);\r\n\r\n            expect(mockConfig.update).toHaveBeenCalledWith('key1', null, vscode.ConfigurationTarget.Workspace);\r\n        });\r\n\r\n        it('should handle setting object values', async () => {\r\n            const obj = { nested: 'value' };\r\n            await ConfigManager.set('config', obj);\r\n\r\n            expect(mockConfig.update).toHaveBeenCalledWith('config', obj, vscode.ConfigurationTarget.Workspace);\r\n        });\r\n    });\r\n\r\n    describe('getGitHubToken', () => {\r\n        it('should return cached token if available', async () => {\r\n            (ConfigManager as any).tokenCache = 'ghp_cached_token';\r\n\r\n            const result = await ConfigManager.getGitHubToken(mockContext);\r\n\r\n            expect(result).toBe('ghp_cached_token');\r\n            expect(mockSecrets.get).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('should retrieve token from SecretStorage if not cached', async () => {\r\n            mockSecrets.get.mockResolvedValue('ghp_new_token');\r\n\r\n            const result = await ConfigManager.getGitHubToken(mockContext);\r\n\r\n            expect(result).toBe('ghp_new_token');\r\n            expect(mockSecrets.get).toHaveBeenCalledWith('github-token');\r\n        });\r\n\r\n        it('should cache retrieved token for future calls', async () => {\r\n            mockSecrets.get.mockResolvedValue('ghp_token');\r\n\r\n            await ConfigManager.getGitHubToken(mockContext);\r\n            const cache1 = (ConfigManager as any).tokenCache;\r\n\r\n            const result2 = await ConfigManager.getGitHubToken(mockContext);\r\n\r\n            expect(cache1).toBe('ghp_token');\r\n            expect(result2).toBe('ghp_token');\r\n            expect(mockSecrets.get).toHaveBeenCalledTimes(1); // Cached on second call\r\n        });\r\n\r\n        it('should return undefined when no secrets available', async () => {\r\n            mockContext.secrets = null;\r\n\r\n            const result = await ConfigManager.getGitHubToken(mockContext);\r\n\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('should return undefined when token not found in SecretStorage', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n\r\n            const result = await ConfigManager.getGitHubToken(mockContext);\r\n\r\n            expect(result).toBeUndefined();\r\n        });\r\n    });\r\n\r\n    describe('setGitHubToken', () => {\r\n        it('should store token in SecretStorage and update cache', async () => {\r\n            await ConfigManager.setGitHubToken(mockContext, 'ghp_new_token');\r\n\r\n            expect(mockSecrets.store).toHaveBeenCalledWith('github-token', 'ghp_new_token');\r\n            expect((ConfigManager as any).tokenCache).toBe('ghp_new_token');\r\n        });\r\n\r\n        it('should handle missing secrets gracefully', async () => {\r\n            mockContext.secrets = null;\r\n\r\n            await expect(ConfigManager.setGitHubToken(mockContext, 'ghp_token')).resolves.not.toThrow();\r\n            expect(mockSecrets.store).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('should update cache with new token', async () => {\r\n            (ConfigManager as any).tokenCache = 'old_token';\r\n\r\n            await ConfigManager.setGitHubToken(mockContext, 'ghp_new_token');\r\n\r\n            expect((ConfigManager as any).tokenCache).toBe('ghp_new_token');\r\n        });\r\n    });\r\n\r\n    describe('deleteGitHubToken', () => {\r\n        it('should delete token from SecretStorage and clear cache', async () => {\r\n            (ConfigManager as any).tokenCache = 'ghp_token';\r\n\r\n            await ConfigManager.deleteGitHubToken(mockContext);\r\n\r\n            expect(mockSecrets.delete).toHaveBeenCalledWith('github-token');\r\n            expect((ConfigManager as any).tokenCache).toBeNull();\r\n        });\r\n\r\n        it('should handle missing secrets gracefully', async () => {\r\n            mockContext.secrets = null;\r\n\r\n            await expect(ConfigManager.deleteGitHubToken(mockContext)).resolves.not.toThrow();\r\n            expect(mockSecrets.delete).not.toHaveBeenCalled();\r\n        });\r\n    });\r\n\r\n    describe('getGitHubTokenWithPrompt', () => {\r\n        it('should return existing token without prompting', async () => {\r\n            mockSecrets.get.mockResolvedValue('ghp_existing_token');\r\n\r\n            const result = await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            expect(result).toBe('ghp_existing_token');\r\n            expect(vscode.window.showInputBox).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('should prompt user when token not found', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n            (vscode.window.showInputBox as jest.Mock).mockResolvedValue('ghp_user_token');\r\n\r\n            const result = await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            expect(result).toBe('ghp_user_token');\r\n            expect(vscode.window.showInputBox).toHaveBeenCalled();\r\n        });\r\n\r\n        it('should validate token format (ghp_ prefix)', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n            (vscode.window.showInputBox as jest.Mock).mockResolvedValue('ghp_validtoken123');\r\n\r\n            const result = await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            expect(result).toBe('ghp_validtoken123');\r\n        });\r\n\r\n        it('should validate token format (github_pat_ prefix)', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n            (vscode.window.showInputBox as jest.Mock).mockResolvedValue('github_pat_validtoken');\r\n\r\n            const result = await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            expect(result).toBe('github_pat_validtoken');\r\n        });\r\n\r\n        it('should reject empty tokens from user input', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n            (vscode.window.showInputBox as jest.Mock).mockResolvedValue('');\r\n\r\n            const result = await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('should reject invalid token format', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n            (vscode.window.showInputBox as jest.Mock).mockResolvedValue('invalid_token_format');\r\n\r\n            const result = await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            // showInputBox is called, but returns result depends on validation\r\n            expect(vscode.window.showInputBox).toHaveBeenCalled();\r\n        });\r\n\r\n        it('should save token when user provides valid token', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n            (vscode.window.showInputBox as jest.Mock).mockResolvedValue('ghp_newtoken');\r\n\r\n            const result = await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            expect(result).toBe('ghp_newtoken');\r\n            expect(mockSecrets.store).toHaveBeenCalledWith('github-token', 'ghp_newtoken');\r\n        });\r\n\r\n        it('should show success message after saving token', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n            (vscode.window.showInputBox as jest.Mock).mockResolvedValue('ghp_newtoken');\r\n\r\n            await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('GitHub token saved securely');\r\n        });\r\n\r\n        it('should return undefined when user cancels input', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n            (vscode.window.showInputBox as jest.Mock).mockResolvedValue(undefined);\r\n\r\n            const result = await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('should handle whitespace-only tokens as empty', async () => {\r\n            mockSecrets.get.mockResolvedValue(undefined);\r\n            (vscode.window.showInputBox as jest.Mock).mockResolvedValue('   ');\r\n\r\n            const result = await ConfigManager.getGitHubTokenWithPrompt(mockContext);\r\n\r\n            // Should be treated as empty\r\n            expect(result).toBeUndefined();\r\n        });\r\n    });\r\n\r\n    describe('getAll', () => {\r\n        it('should return all COE configuration', () => {\r\n            const allConfig = { key1: 'value1', key2: 'value2' };\r\n            mockConfig.get.mockReturnValue(allConfig);\r\n\r\n            (vscode.workspace.getConfiguration as jest.Mock).mockReturnValue(mockConfig);\r\n\r\n            const result = ConfigManager.getAll();\r\n\r\n            expect(result).toEqual(mockConfig);\r\n            expect(vscode.workspace.getConfiguration).toHaveBeenCalledWith('coe');\r\n        });\r\n\r\n        it('should return configuration object for accessing nested properties', () => {\r\n            (vscode.workspace.getConfiguration as jest.Mock).mockReturnValue(mockConfig);\r\n\r\n            const result = ConfigManager.getAll();\r\n\r\n            expect(result).toHaveProperty('get');\r\n            expect(result).toHaveProperty('update');\r\n        });\r\n    });\r\n\r\n    describe('Edge Cases', () => {\r\n        it('should handle rapid successive token requests with caching', async () => {\r\n            mockSecrets.get.mockResolvedValue('ghp_token');\r\n\r\n            const [result1, result2, result3] = await Promise.all([\r\n                ConfigManager.getGitHubToken(mockContext),\r\n                ConfigManager.getGitHubToken(mockContext),\r\n                ConfigManager.getGitHubToken(mockContext),\r\n            ]);\r\n\r\n            expect(result1).toBe('ghp_token');\r\n            expect(result2).toBe('ghp_token');\r\n            expect(result3).toBe('ghp_token');\r\n            // Should only call SecretStorage once due to caching\r\n            expect(mockSecrets.get).toHaveBeenCalledTimes(1);\r\n        });\r\n\r\n        it('should handle token deletion followed by retrieval', async () => {\r\n            (ConfigManager as any).tokenCache = 'ghp_old_token';\r\n\r\n            await ConfigManager.deleteGitHubToken(mockContext);\r\n            expect((ConfigManager as any).tokenCache).toBeNull();\r\n\r\n            mockSecrets.get.mockResolvedValue('ghp_new_token');\r\n            const result = await ConfigManager.getGitHubToken(mockContext);\r\n\r\n            expect(result).toBe('ghp_new_token');\r\n        });\r\n    });\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\utils\\__tests__\\streamingLLM.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\utils\\config.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[688,691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[688,691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4568,4571],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4568,4571],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Configuration Manager\r\n * Handles extension configuration and settings\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\n\r\nexport class ConfigManager {\r\n    private static readonly CONFIG_SECTION = 'coe';\r\n    private static tokenCache: string | null = null;\r\n    private static tokenPromise: Promise<string | undefined> | null = null;\r\n\r\n    /**\r\n     * Get configuration value\r\n     */\r\n    static get<T>(key: string, defaultValue?: T): T | undefined {\r\n        const config = vscode.workspace.getConfiguration(this.CONFIG_SECTION);\r\n        return config.get<T>(key, defaultValue!);\r\n    }\r\n\r\n    /**\r\n     * Set configuration value\r\n     */\r\n    static async set(key: string, value: any, target: vscode.ConfigurationTarget = vscode.ConfigurationTarget.Workspace): Promise<void> {\r\n        const config = vscode.workspace.getConfiguration(this.CONFIG_SECTION);\r\n        await config.update(key, value, target);\r\n    }\r\n\r\n    /**\r\n     * Get GitHub token from secure storage (with cache)\r\n     */\r\n    static async getGitHubToken(context: vscode.ExtensionContext): Promise<string | undefined> {\r\n        // Return cached token if available (check for not null, not just truthy)\r\n        if (this.tokenCache !== null) {\r\n            return this.tokenCache;\r\n        }\r\n\r\n        // If a request is already in flight, return that promise\r\n        if (this.tokenPromise) {\r\n            return this.tokenPromise;\r\n        }\r\n\r\n        const secrets = context.secrets;\r\n        if (!secrets) {\r\n            return undefined;\r\n        }\r\n\r\n        // Create and store the promise to handle concurrent calls\r\n        this.tokenPromise = (async () => {\r\n            try {\r\n                // Retrieve from SecretStorage\r\n                const token = await secrets.get('github-token');\r\n                // Always cache the result (even if undefined) to prevent repeated lookups\r\n                this.tokenCache = token || '';\r\n                return token;\r\n            } finally {\r\n                // Clear the promise after it resolves\r\n                this.tokenPromise = null;\r\n            }\r\n        })();\r\n\r\n        return this.tokenPromise;\r\n    }\r\n\r\n    /**\r\n     * Set GitHub token in secure storage\r\n     */\r\n    static async setGitHubToken(context: vscode.ExtensionContext, token: string): Promise<void> {\r\n        const secrets = context.secrets;\r\n        if (!secrets) {\r\n            return;\r\n        }\r\n\r\n        await secrets.store('github-token', token);\r\n        this.tokenCache = token; // Update cache\r\n    }\r\n\r\n    /**\r\n     * Delete GitHub token from secure storage\r\n     */\r\n    static async deleteGitHubToken(context: vscode.ExtensionContext): Promise<void> {\r\n        const secrets = context.secrets;\r\n        if (!secrets) {\r\n            return;\r\n        }\r\n\r\n        await secrets.delete('github-token');\r\n        this.tokenCache = null; // Clear cache\r\n        this.tokenPromise = null; // Clear pending promise\r\n    }\r\n\r\n    /**\r\n     * Get GitHub token with user prompt if missing\r\n     * Returns token or undefined if user cancels\r\n     */\r\n    static async getGitHubTokenWithPrompt(context: vscode.ExtensionContext): Promise<string | undefined> {\r\n        // Try to get existing token\r\n        let token = await this.getGitHubToken(context);\r\n\r\n        // If no token, prompt user\r\n        if (!token) {\r\n            token = await vscode.window.showInputBox({\r\n                prompt: 'Enter your GitHub Personal Access Token',\r\n                password: true,\r\n                placeHolder: 'ghp_xxxxxxxxxxxxxxxxxxxx',\r\n                ignoreFocusOut: true,\r\n                validateInput: (value) => {\r\n                    if (!value || value.trim().length === 0) {\r\n                        return 'Token cannot be empty';\r\n                    }\r\n                    if (!value.startsWith('ghp_') && !value.startsWith('github_pat_')) {\r\n                        return 'Invalid token format. Should start with ghp_ or github_pat_';\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n\r\n            // Validate and trim token - return undefined for empty/whitespace input\r\n            if (token && token.trim().length > 0) {\r\n                token = token.trim();\r\n                await this.setGitHubToken(context, token);\r\n                vscode.window.showInformationMessage('GitHub token saved securely');\r\n            } else {\r\n                return undefined;\r\n            }\r\n        }\r\n\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Get all COE configuration\r\n     */\r\n    static getAll(): any {\r\n        return vscode.workspace.getConfiguration(this.CONFIG_SECTION);\r\n    }\r\n}\r\n\r\n/**\r\n * Default configuration structure\r\n */\r\nexport interface COEConfig {\r\n    mcpServer: {\r\n        enabled: boolean;\r\n        port?: number;\r\n    };\r\n    github: {\r\n        enabled: boolean;\r\n        syncInterval: number; // minutes\r\n        repository?: string;\r\n        owner?: string;\r\n    };\r\n    tasks: {\r\n        autoRefresh: boolean;\r\n        refreshInterval: number; // seconds\r\n    };\r\n    ui: {\r\n        showStatusBar: boolean;\r\n        showTaskCount: boolean;\r\n    };\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\utils\\fileConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\utils\\logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[911,914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[911,914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1119,1122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1119,1122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1328,1331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1328,1331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1536,1539],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1536,1539],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1777,1780],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1777,1780],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Logger Utility\r\n * Centralized logging with different levels\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\n\r\nexport enum LogLevel {\r\n    DEBUG = 0,\r\n    INFO = 1,\r\n    WARN = 2,\r\n    ERROR = 3\r\n}\r\n\r\nexport class Logger {\r\n    private static instance: Logger;\r\n    private outputChannel: vscode.OutputChannel;\r\n    private currentLevel: LogLevel = LogLevel.INFO;\r\n\r\n    private constructor() {\r\n        this.outputChannel = vscode.window.createOutputChannel('COE Extension');\r\n    }\r\n\r\n    /**\r\n     * Get logger instance (singleton)\r\n     */\r\n    static getInstance(): Logger {\r\n        if (!Logger.instance) {\r\n            Logger.instance = new Logger();\r\n        }\r\n        return Logger.instance;\r\n    }\r\n\r\n    /**\r\n     * Set log level\r\n     */\r\n    setLevel(level: LogLevel): void {\r\n        this.currentLevel = level;\r\n    }\r\n\r\n    /**\r\n     * Debug log\r\n     */\r\n    debug(message: string, ...args: any[]): void {\r\n        if (this.currentLevel <= LogLevel.DEBUG) {\r\n            this.log('DEBUG', message, ...args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Info log\r\n     */\r\n    info(message: string, ...args: any[]): void {\r\n        if (this.currentLevel <= LogLevel.INFO) {\r\n            this.log('INFO', message, ...args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Warning log\r\n     */\r\n    warn(message: string, ...args: any[]): void {\r\n        if (this.currentLevel <= LogLevel.WARN) {\r\n            this.log('WARN', message, ...args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Error log\r\n     */\r\n    error(message: string, ...args: any[]): void {\r\n        if (this.currentLevel <= LogLevel.ERROR) {\r\n            this.log('ERROR', message, ...args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal log method\r\n     */\r\n    private log(level: string, message: string, ...args: any[]): void {\r\n        const timestamp = new Date().toISOString();\r\n        const formattedMessage = `[${timestamp}] [${level}] ${message}`;\r\n\r\n        this.outputChannel.appendLine(formattedMessage);\r\n\r\n        if (args.length > 0) {\r\n            this.outputChannel.appendLine(JSON.stringify(args, null, 2));\r\n        }\r\n\r\n        // Also log to console for debugging\r\n    }\r\n\r\n    /**\r\n     * Show output channel\r\n     */\r\n    show(): void {\r\n        this.outputChannel.show();\r\n    }\r\n\r\n    /**\r\n     * Dispose output channel\r\n     */\r\n    dispose(): void {\r\n        this.outputChannel.dispose();\r\n    }\r\n}\r\n\r\n// Export singleton instance\r\nexport const logger = Logger.getInstance();\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\utils\\setupFiles.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorMsg' is assigned a value but never used.","line":92,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":92,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorMsg' is assigned a value but never used.","line":115,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":115,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ≡ƒÅù∩╕Å Workspace Setup Files Utility\r\n * \r\n * Auto-creates important COE configuration and plan files on first startup\r\n * if they don't already exist in the workspace. Shows a friendly popup to\r\n * the user with options to open the newly created files.\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\n\r\n/**\r\n * Interface for file creation configuration\r\n */\r\ninterface FileToCreate {\r\n    path: vscode.Uri;\r\n    defaultContent: string;\r\n    description: string;\r\n}\r\n\r\n/**\r\n * ≡ƒÜÇ Setup Missing Workspace Files\r\n * \r\n * Automatically creates important COE files on extension startup:\r\n * - Docs/Plans/current-plan.md - Main task planning file\r\n * - .coe/config.json - LLM configuration settings\r\n * \r\n * Shows a friendly popup to the user if any files were created.\r\n * \r\n * @returns Promise<void>\r\n */\r\nexport async function setupMissingFiles(): Promise<void> {\r\n    const ws = vscode.workspace.workspaceFolders?.[0]?.uri;\r\n    if (!ws) {\r\n        return;\r\n    }\r\n\r\n    // Define the files to check/create with their default content\r\n    const filesToCreate: FileToCreate[] = [\r\n        {\r\n            path: vscode.Uri.joinPath(ws, 'Docs', 'Plans', 'current-plan.md'),\r\n            defaultContent: `# COE Project Plan (auto-created)\r\n\r\n- [ ] First task #P1\r\n- [ ] Second task #P2\r\n- [ ] Third task #P3\r\n\r\n## Instructions\r\nEdit this file to add your own tasks. Each task should follow the format:\r\n\\`- [ ] Task title #P1\\` or \\`#P2\\` or \\`#P3\\` for priority levels.\r\n`,\r\n            description: 'Main task planning file',\r\n        },\r\n        {\r\n            path: vscode.Uri.joinPath(ws, '.coe', 'config.json'),\r\n            defaultContent: JSON.stringify(\r\n                {\r\n                    llm: {\r\n                        url: 'http://192.168.1.205:1234/v1/chat/completions',\r\n                        model: 'mistralai/ministral-3-14b-reasoning',\r\n                        inputTokenLimit: 4000,\r\n                        maxOutputTokens: 2000,\r\n                        timeoutSeconds: 300,\r\n                    },\r\n                    description: 'Edit these settings to customize your LLM configuration',\r\n                },\r\n                null,\r\n                2\r\n            ),\r\n            description: 'LLM configuration settings',\r\n        },\r\n    ];\r\n\r\n    const createdFiles: FileToCreate[] = [];\r\n\r\n    // Check each file and create if missing\r\n    for (const file of filesToCreate) {\r\n        try {\r\n            // Try to stat the file (throws if doesn't exist)\r\n            await vscode.workspace.fs.stat(file.path);\r\n        } catch {\r\n            // File doesn't exist ΓÇô create parent folders + file\r\n            try {\r\n                const parent = vscode.Uri.joinPath(file.path, '..');\r\n                await vscode.workspace.fs.createDirectory(parent);\r\n\r\n                const encoder = new TextEncoder();\r\n                const fileContent = encoder.encode(file.defaultContent);\r\n                await vscode.workspace.fs.writeFile(file.path, fileContent);\r\n\r\n                createdFiles.push(file);\r\n            } catch (createError) {\r\n                const errorMsg = createError instanceof Error ? createError.message : String(createError);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Show friendly popup if any files were created (non-blocking)\r\n    if (createdFiles.length > 0) {\r\n        const fileList = createdFiles.map((f) => `ΓÇó ${f.description}`).join('\\n');\r\n        // Don't await this - let it show asynchronously without blocking activation\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        vscode.window\r\n            .showInformationMessage(\r\n                `Γ£à COE created missing setup files:\\n${fileList}\\n\\nWant to open them?`,\r\n                'Open Files',\r\n                \"Don't show\"\r\n            )\r\n            .then(async (choice) => {\r\n                if (choice === 'Open Files') {\r\n                    for (const file of createdFiles) {\r\n                        try {\r\n                            const doc = await vscode.workspace.openTextDocument(file.path);\r\n                            await vscode.window.showTextDocument(doc, { preserveFocus: false });\r\n                        } catch (openError) {\r\n                            const errorMsg = openError instanceof Error ? openError.message : String(openError);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n    }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\weird\\OneDrive\\Documents\\GitHub\\Plan-To-Code-AI-Helper-\\src\\utils\\streamingLLM.ts","messages":[],"suppressedMessages":[{"ruleId":"no-constant-condition","severity":2,"message":"Unexpected constant condition.","line":226,"column":16,"nodeType":"Literal","messageId":"unexpected","endLine":226,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
